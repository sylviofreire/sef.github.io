/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/main/java/com/alibaba/fastjson/asm/ASMException.java;<<<<<<< MINE
=======
package com.alibaba.fastjson.asm;

import com.alibaba.fastjson.JSONException;

public class ASMException extends JSONException {

	private static final long serialVersionUID = 1L;

    public ASMException(String message){
        super(message);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/test/java/com/alibaba/json/bvt/bug/Bug_for_vikingschow.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.json.bvtVO.OfferRankResultVO;

public class Bug_for_vikingschow extends TestCase {
	public void test_for_vikingschow() throws Exception {
		OfferRankResultVO vo = new OfferRankResultVO();
		String text = JSON.toJSONString(vo);
		JSON.parseObject(text, OfferRankResultVO.class);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/test/java/com/alibaba/json/bvtVO/OfferRankResultVO.java;<<<<<<< MINE
=======
package com.alibaba.json.bvtVO;

import java.util.ArrayList;
import java.util.List;

public class OfferRankResultVO {
	private List<SearchCenterOfferModel> models = new ArrayList<SearchCenterOfferModel>();
	
	public OfferRankResultVO() {
		models.add(new SearchCenterOfferModel());
	}

	public List<SearchCenterOfferModel> getModel() {
		return models;
	}

	public void setModel(List<SearchCenterOfferModel> models) {
		this.models = models;
	}

}

class SearchCenterOfferModel {
	private int id;
	private String name;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/test/java/com/alibaba/json/bvt/parser/deser/SqlDateDeserializerTest2.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser.deser;

import java.sql.Date;
import java.text.SimpleDateFormat;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class SqlDateDeserializerTest2 extends TestCase {
    public void test_sqlDate() throws Exception {
        java.util.Date date = new java.util.Date();
        long millis = date.getTime();
        long millis2 = (millis / 1000)  * 1000;
        String text = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(millis);
        text = text.replace(' ', 'T');
        
        String text2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(millis2);
        
        Assert.assertNull(JSON.parseObject("null", Date.class));
        Assert.assertNull(JSON.parseObject("\"\"", Date.class));
        Assert.assertNull(JSON.parseArray("null", Date.class));
        Assert.assertNull(JSON.parseArray("[null]", Date.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        
        Assert.assertEquals(new Date(millis), JSON.parseObject("" + millis, Date.class));
        Assert.assertEquals(new Date(millis), JSON.parseObject("{\"@type\":\"java.sql.Date\",\"val\":" + millis + "}", Date.class));
        Assert.assertEquals(new Date(millis), JSON.parseObject("\"" + millis + "\"", Date.class));
        Assert.assertEquals(new Date(millis2), JSON.parseObject("\"" + text2 + "\"", Date.class));
        Assert.assertEquals(new Date(millis), JSON.parseObject("\"" + text + "\"", Date.class));
        
        //System.out.println(JSON.toJSONString(new Time(millis), SerializerFeature.WriteClassName));
        
    }

    public static class VO {

        private Date value;

        public Date getValue() {
            return value;
        }

        public void setValue(Date value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/test/java/com/alibaba/json/bvt/parser/deser/StackTraceElementDeserializerTest.java;<<<<<<< MINE
package com.alibaba.json.bvt.parser.deser;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONException;

public class StackTraceElementDeserializerTest extends TestCase {

    public void test_stack() throws Exception {
        Assert.assertNull(JSON.parseObject("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("[null]", StackTraceElement.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        Assert.assertNull(JSON.parseObject("{\"className\":\"int\",\"methodName\":\"parseInt\"}",
                                           StackTraceElement.class).getFileName());
        
        Assert.assertEquals(StackTraceElement.class, ((StackTraceElement) JSON.parse("{\"@type\":\"java.lang.StackTraceElement\",\"className\":\"int\",\"methodName\":\"parseInt\"}")).getClass());
    }

    public void test_stack_error() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("{}", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
    
    public void test_stack_error_1() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("[]", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
    
    public void test_stack_error_2() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("{\"className\":null,\"methodName\":null,\"fileName\":null,\"lineNumber\":null,\"@type\":\"xxx\"}", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
    public void test_stack_error_3() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("{\"@type\":33}", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }

    public static class VO {

        private StackTraceElement value;

        public StackTraceElement getValue() {
            return value;
        }

        public void setValue(StackTraceElement value) {
            this.value = value;
        }

    }
}=======
package com.alibaba.json.bvt.parser.deser;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class StackTraceElementDeserializerTest extends TestCase {

    public void test_stack() throws Exception {
        Assert.assertNull(JSON.parseObject("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("[null]", StackTraceElement.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        Assert.assertNull(JSON.parseObject("{\"className\":\"int\",\"methodName\":\"parseInt\"}", StackTraceElement.class).getFileName());
    }

    public static class VO {

        private StackTraceElement value;

        public StackTraceElement getValue() {
            return value;
        }

        public void setValue(StackTraceElement value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/test/java/com/alibaba/json/bvt/parser/deser/TimeDeserializerTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser.deser;

import java.sql.Time;
import java.text.SimpleDateFormat;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TimeDeserializerTest extends TestCase {
    public void test_time() throws Exception {
        long millis = System.currentTimeMillis();
        String text = new SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date(millis));
        text += "T";
        text += new SimpleDateFormat("HH:mm:ss.SSS").format(new java.util.Date(millis));
        
        Assert.assertNull(JSON.parseObject("null", Time.class));
        Assert.assertNull(JSON.parseObject("\"\"", Time.class));
        Assert.assertNull(JSON.parseArray("null", Time.class));
        Assert.assertNull(JSON.parseArray("[null]", Time.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        
        Assert.assertEquals(new Time(millis), JSON.parseObject("" + millis, Time.class));
        Assert.assertEquals(new Time(millis), JSON.parseObject("{\"@type\":\"java.sql.Time\",\"val\":" + millis + "}", Time.class));
        Assert.assertEquals(new Time(millis), JSON.parseObject("\"" + millis + "\"", Time.class));
        Assert.assertEquals(new Time(millis), JSON.parseObject("\"" + text + "\"", Time.class));
        
        //System.out.println(JSON.toJSONString(new Time(millis), SerializerFeature.WriteClassName));
        
    }

    public static class VO {

        private Time value;

        public Time getValue() {
            return value;
        }

        public void setValue(Time value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_cc0428f_dee22f7/rev_cc0428f-dee22f7/src/test/java/com/alibaba/json/bvt/TestExternal3.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;

import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;


public class TestExternal3 extends TestCase {
    public void test_0 () throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("external.VO");
        Method method = clazz.getMethod("setName", new Class[] {String.class});
        Object obj = clazz.newInstance();
        method.invoke(obj, "jobs");
        
        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSON.parseObject(text);
    }
    
    public static class ExtClassLoader extends ClassLoader {
        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());
            
            byte[] bytes;
            InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/VO.clazz");
            bytes = IOUtils.toByteArray(is);
            is.close();
            
            super.defineClass("external.VO", bytes, 0, bytes.length);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_4.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        JSON.parseObject(jsonString);
        
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_4.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        JSON.parseObject(jsonString);
        
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/parser/ProductViewTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser;

import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;


public class ProductViewTest extends TestCase {
    public void test_parse() throws Exception {
        String text = "{\"code\":0,\"message\":\"Register Successfully!\",\"status\":\"OK\"}";
        Map map = JSON.parseObject(text, Map.class);
        System.out.println(map.get("code").getClass());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/TestExternal4.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal4 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("external.VO2");
        Method method = clazz.getMethod("setName", new Class[] { String.class });
        Method methodSetValue = clazz.getMethod("setValue", new Class[] { Serializable.class });

        Object obj = clazz.newInstance();
        method.invoke(obj, "jobs");
        methodSetValue.invoke(obj, obj);

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "external.VO2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/VO2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("external.VO2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/TestExternal5.java;<<<<<<< MINE
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName, SerializerFeature.WriteMapNullValue);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/TestSerializable.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.Serializable;
import java.util.ArrayList;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class TestSerializable extends TestCase {
    public void test_codec() throws Exception {
        VO vo = new VO();
        vo.setValue(new ArrayList());
        
        JSON.toJSONString(vo);
    }

    public static class VO {

        private long         id;
        private Serializable value;

        public long getId() {
            return id;
        }

        public void setId(long id) {
            this.id = id;
        }

        public Serializable getValue() {
            return value;
        }

        public void setValue(Serializable value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvtVO/ProductView.java;<<<<<<< MINE
=======
package com.alibaba.json.bvtVO;

public class ProductView {

    private Integer id;
    private String  keyword;
    private boolean hasProduct;
    private boolean hasCompany;
    private boolean hasBuyLead;
    private String  country;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getKeyword() {
        return keyword;
    }

    public void setKeyword(String keyword) {
        this.keyword = keyword;
    }

    public boolean isHasProduct() {
        return hasProduct;
    }

    public void setHasProduct(boolean hasProduct) {
        this.hasProduct = hasProduct;
    }

    public boolean isHasCompany() {
        return hasCompany;
    }

    public void setHasCompany(boolean hasCompany) {
        this.hasCompany = hasCompany;
    }

    public boolean isHasBuyLead() {
        return hasBuyLead;
    }

    public void setHasBuyLead(boolean hasBuyLead) {
        this.hasBuyLead = hasBuyLead;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/parser/ProductViewTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser;

import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;


public class ProductViewTest extends TestCase {
    public void test_parse() throws Exception {
        String text = "{\"code\":0,\"message\":\"Register Successfully!\",\"status\":\"OK\"}";
        Map map = JSON.parseObject(text, Map.class);
        System.out.println(map.get("code").getClass());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/TestExternal4.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal4 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("external.VO2");
        Method method = clazz.getMethod("setName", new Class[] { String.class });
        Method methodSetValue = clazz.getMethod("setValue", new Class[] { Serializable.class });

        Object obj = clazz.newInstance();
        method.invoke(obj, "jobs");
        methodSetValue.invoke(obj, obj);

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "external.VO2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/VO2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("external.VO2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/TestExternal5.java;<<<<<<< MINE
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName, SerializerFeature.WriteMapNullValue);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/TestSerializable.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.Serializable;
import java.util.ArrayList;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class TestSerializable extends TestCase {
    public void test_codec() throws Exception {
        VO vo = new VO();
        vo.setValue(new ArrayList());
        
        JSON.toJSONString(vo);
    }

    public static class VO {

        private long         id;
        private Serializable value;

        public long getId() {
            return id;
        }

        public void setId(long id) {
            this.id = id;
        }

        public Serializable getValue() {
            return value;
        }

        public void setValue(Serializable value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvtVO/ProductView.java;<<<<<<< MINE
=======
package com.alibaba.json.bvtVO;

public class ProductView {

    private Integer id;
    private String  keyword;
    private boolean hasProduct;
    private boolean hasCompany;
    private boolean hasBuyLead;
    private String  country;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getKeyword() {
        return keyword;
    }

    public void setKeyword(String keyword) {
        this.keyword = keyword;
    }

    public boolean isHasProduct() {
        return hasProduct;
    }

    public void setHasProduct(boolean hasProduct) {
        this.hasProduct = hasProduct;
    }

    public boolean isHasCompany() {
        return hasCompany;
    }

    public void setHasCompany(boolean hasCompany) {
        this.hasCompany = hasCompany;
    }

    public boolean isHasBuyLead() {
        return hasBuyLead;
    }

    public void setHasBuyLead(boolean hasBuyLead) {
        this.hasBuyLead = hasBuyLead;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_24d779e_3a5c953/rev_24d779e-3a5c953/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_1.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.HashMap;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.TypeReference;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_1 extends TestCase {

    public void test_0() throws Exception {
        Map<String, User> matcherMap = new HashMap<String, User>();
        String matcherMapString = JSON.toJSONString(matcherMap, SerializerFeature.WriteClassName,
                                                    SerializerFeature.WriteMapNullValue);
        
        System.out.println(matcherMapString);
        
        matcherMap = JSONObject.parseObject(matcherMapString, new TypeReference<Map<String, User>>() {
        });
    }

    public static class User {

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/test/java/com/alibaba/json/bvt/bug/Bug_for_42283905.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.List;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class Bug_for_42283905 extends TestCase {

    public void test_0() throws Exception {

        String text;
        {
            List<Group> groups = new ArrayList<Group>();

            Command c0 = new Command(1);
            Command c1 = new Command(2);
            Command c2 = new Command(3);

            c1.setPre(c0);
            c2.setPre(c1);

            {
                Group group = new Group("g0");
                group.getBattleCommandList().add(c0);
                groups.add(group);
            }

            {
                Group group = new Group("g1");
                group.getBattleCommandList().add(c1);
                groups.add(group);
            }
            
            {
                Group group = new Group("g2");
                group.getBattleCommandList().add(c2);
                groups.add(group);
            }
            text = JSON.toJSONString(groups);
        }

        System.out.println(text);

        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {
        });
        Group g0 = groups.get(0);
        Group g1 = groups.get(1);

        System.out.println(JSON.toJSONString(groups));
    }

    public static class Group {

        private String        name;

        private List<Command> battleCommandList = new ArrayList<Command>();

        public Group(){

        }

        public Group(String name){
            this.name = name;
        }

        public List<Command> getBattleCommandList() {
            return battleCommandList;
        }

        public void setBattleCommandList(List<Command> battleCommandList) {
            this.battleCommandList = battleCommandList;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

    }

    public static class Command {

        private int id;

        public Command(){

        }

        public Command(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        private Command pre;

        public Command getPre() {
            return pre;
        }

        public void setPre(Command pre) {
            this.pre = pre;
        }

        public String toString() {
            return "{id:" + id + "}";
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/test/java/com/alibaba/json/bvt/bug/Bug_for_wuzhengmao.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}=======
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(1, result.get(0).getId());
        Assert.assertEquals(2, result.get(1).getId());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/test/java/com/alibaba/json/bvt/ArrayRefTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.util.ArrayList;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class ArrayRefTest extends TestCase {

    public void test_0() throws Exception {
        String text;
        {
            List<Group> groups = new ArrayList<Group>();
            
            Group g0 = new Group(0);
            Group g1 = new Group(1);
            Group g2 = new Group(2);
            
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            
            text = JSON.toJSONString(groups);
        }
        
        System.out.println(text);
        
        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {});
        Assert.assertEquals(6, groups.size());
    }

    public static class Group {

        private int id;

        public Group(){

        }

        public Group(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }
        
        public String toString() {
            return "{id:" + id + "}";
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/test/java/com/alibaba/json/bvt/bug/Bug_for_42283905.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.List;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class Bug_for_42283905 extends TestCase {

    public void test_0() throws Exception {

        String text;
        {
            List<Group> groups = new ArrayList<Group>();

            Command c0 = new Command(1);
            Command c1 = new Command(2);
            Command c2 = new Command(3);

            c1.setPre(c0);
            c2.setPre(c1);

            {
                Group group = new Group("g0");
                group.getBattleCommandList().add(c0);
                groups.add(group);
            }

            {
                Group group = new Group("g1");
                group.getBattleCommandList().add(c1);
                groups.add(group);
            }
            
            {
                Group group = new Group("g2");
                group.getBattleCommandList().add(c2);
                groups.add(group);
            }
            text = JSON.toJSONString(groups);
        }

        System.out.println(text);

        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {
        });
        Group g0 = groups.get(0);
        Group g1 = groups.get(1);

        System.out.println(JSON.toJSONString(groups));
    }

    public static class Group {

        private String        name;

        private List<Command> battleCommandList = new ArrayList<Command>();

        public Group(){

        }

        public Group(String name){
            this.name = name;
        }

        public List<Command> getBattleCommandList() {
            return battleCommandList;
        }

        public void setBattleCommandList(List<Command> battleCommandList) {
            this.battleCommandList = battleCommandList;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

    }

    public static class Command {

        private int id;

        public Command(){

        }

        public Command(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        private Command pre;

        public Command getPre() {
            return pre;
        }

        public void setPre(Command pre) {
            this.pre = pre;
        }

        public String toString() {
            return "{id:" + id + "}";
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/test/java/com/alibaba/json/bvt/bug/Bug_for_wuzhengmao.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(1, result.get(0).getId());
        Assert.assertEquals(2, result.get(1).getId());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}=======
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/test/java/com/alibaba/json/bvt/ArrayRefTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.util.ArrayList;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class ArrayRefTest extends TestCase {

    public void test_0() throws Exception {
        String text;
        {
            List<Group> groups = new ArrayList<Group>();
            
            Group g0 = new Group(0);
            Group g1 = new Group(1);
            Group g2 = new Group(2);
            
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            
            text = JSON.toJSONString(groups);
        }
        
        System.out.println(text);
        
        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {});
        Assert.assertEquals(6, groups.size());
    }

    public static class Group {

        private int id;

        public Group(){

        }

        public Group(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }
        
        public String toString() {
            return "{id:" + id + "}";
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/TimestampDeserializer.java;<<<<<<< MINE
public class TimestampDeserializer implements ObjectDeserializer {
=======
public class TimestampDeserializer extends AbstractDateDeserializer implements ObjectDeserializer {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/AbstractDateDeserializer.java;<<<<<<< MINE
package com.alibaba.fastjson.parser.deserializer;

import java.lang.reflect.Type;

import com.alibaba.fastjson.JSONException;
import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.JSONScanner;
import com.alibaba.fastjson.parser.JSONToken;

public abstract class AbstractDateDeserializer implements ObjectDeserializer {

    @SuppressWarnings("unchecked")
    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {
        Object val;
        if (parser.getResolveStatus() == DefaultJSONParser.TypeNameRedirect) {
            parser.accept(JSONToken.COMMA);

            JSONScanner lexer = (JSONScanner) parser.getLexer();
            if (lexer.token() == JSONToken.LITERAL_STRING) {
                if (!"val".equals(lexer.stringVal())) {
                    throw new JSONException("syntax error");
                }
                lexer.nextToken();
            } else {
                throw new JSONException("syntax error");
            }

            parser.accept(JSONToken.COLON);

            val = parser.parse();

            parser.accept(JSONToken.RBRACE);

            parser.setResolveStatus(DefaultJSONParser.NONE);
        } else {
            val = parser.parse();
        }
        
        return (T) cast(parser, clazz, fieldName, val);
    }

    protected abstract <T> T cast(DefaultJSONParser parser, Type clazz, Object fieldName, Object value);
}=======
package com.alibaba.fastjson.parser.deserializer;

import java.lang.reflect.Type;

import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.JSONScanner;
import com.alibaba.fastjson.parser.JSONToken;
import com.google.gson.JsonParseException;

public abstract class AbstractDateDeserializer implements ObjectDeserializer {

    @SuppressWarnings("unchecked")
    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {
        Object val;
        if (parser.getResolveStatus() == DefaultJSONParser.TypeNameRedirect) {
            parser.accept(JSONToken.COMMA);

            JSONScanner lexer = (JSONScanner) parser.getLexer();
            if (lexer.token() == JSONToken.LITERAL_STRING) {
                if (!"val".equals(lexer.stringVal())) {
                    throw new JsonParseException("syntax error");
                }
                lexer.nextToken();
            } else {
                throw new JsonParseException("syntax error");
            }

            parser.accept(JSONToken.COLON);

            val = parser.parse();

            parser.accept(JSONToken.RBRACE);

            parser.setResolveStatus(DefaultJSONParser.NONE);
        } else {
            val = parser.parse();
        }
        
        return (T) cast(parser, clazz, fieldName, val);
    }

    protected abstract <T> T cast(DefaultJSONParser parser, Type clazz, Object fieldName, Object value);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
public class SqlDateDeserializer implements ObjectDeserializer {
=======
public class SqlDateDeserializer extends AbstractDateDeserializer implements ObjectDeserializer {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/DateDeserializer.java;<<<<<<< MINE
public class DateDeserializer implements ObjectDeserializer {
=======
public class DateDeserializer extends AbstractDateDeserializer implements ObjectDeserializer {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_6.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_6 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("id", 1);
        map.put("name", "leno.lix");
        map.put("birthday", new Date());
        map.put("gmtCreate", new java.sql.Date(new Date().getTime()));
        map.put("gmtModified", new java.sql.Timestamp(new Date().getTime()));

        String userJSON = JSON.toJSONString(map, SerializerFeature.WriteClassName,
                SerializerFeature.WriteMapNullValue);
        
        System.out.println(userJSON);

        Object object = JSON.parse(userJSON);
        
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_12d54d2_7f38646/rev_12d54d2-7f38646/src/main/java/com/alibaba/fastjson/parser/deserializer/MapResolveFieldDeserializer.java;<<<<<<< MINE
=======
package com.alibaba.fastjson.parser.deserializer;

import java.lang.reflect.Type;
import java.util.Map;

import com.alibaba.fastjson.parser.DefaultJSONParser;

@SuppressWarnings("rawtypes")
public final class MapResolveFieldDeserializer extends FieldDeserializer {

    private final String              key;
    private final Map map;

    public MapResolveFieldDeserializer(Map map, String index){
        super(null, null);
        this.key = index;
        this.map = map;
    }

    @SuppressWarnings("unchecked")
    public void setValue(Object object, Object value) {
        map.put(key, value);
    }


    @Override
    public void parseField(DefaultJSONParser parser, Object object, Type objectType, Map<String, Object> fieldValues) {

    }

    @Override
    public int getFastMatchToken() {
        return 0;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_12d54d2_7f38646/rev_12d54d2-7f38646/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_9.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.HashMap;
import java.util.Map;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_9 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<String, Object> submap4 = new HashMap<String, Object>();
        Address address = new Address();
        address.setCity("hangzhou");
        address.setStreet("wangshang.RD");
        address.setPostCode(310002);
        submap4.put("address1", address);
        submap4.put("address2", address);

        String mapString4 = JSON.toJSONString(submap4, SerializerFeature.WriteClassName,
                                              SerializerFeature.WriteMapNullValue);
        
        System.out.println(mapString4);
        Object object4 = JSON.parse(mapString4);
        Assert.assertNotNull(object4);
        
        Map<String, Object> map = (Map<String, Object>) object4;
        
        Assert.assertNotNull(map.get("address1"));
        Assert.assertNotNull(map.get("address2"));

    }

    public static class Address {

        private String city;
        private String street;
        private int postCode;

        public String getCity() {
            return city;
        }

        public void setCity(String city) {
            this.city = city;
        }

        public String getStreet() {
            return street;
        }

        public void setStreet(String street) {
            this.street = street;
        }

        public int getPostCode() {
            return postCode;
        }

        public void setPostCode(int postCode) {
            this.postCode = postCode;
        }

    }
}=======
package com.alibaba.json.bvt.bug;

import java.util.HashMap;
import java.util.Map;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_9 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<String, Object> submap4 = new HashMap<String, Object>();
        Address address = new Address();
        address.setCity("hangzhou");
        address.setStreet("wangshang.RD");
        address.setPostCode(310002);
        submap4.put("address1", address);
        submap4.put("address2", address);

        String mapString4 = JSON.toJSONString(submap4, SerializerFeature.WriteClassName,
                                              SerializerFeature.WriteMapNullValue);
        
        System.out.println(mapString4);
        Object object4 = JSON.parse(mapString4);
        Assert.assertNotNull(object4);

    }

    public static class Address {

        private String city;
        private String street;
        private int postCode;

        public String getCity() {
            return city;
        }

        public void setCity(String city) {
            this.city = city;
        }

        public String getStreet() {
            return street;
        }

        public void setStreet(String street) {
            this.street = street;
        }

        public int getPostCode() {
            return postCode;
        }

        public void setPostCode(int postCode) {
            this.postCode = postCode;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/test/java/com/alibaba/json/bvt/bug/Bug_for_hmy8.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.json.bvtVO.IEvent;
import com.alibaba.json.bvtVO.IEventDto;

public class Bug_for_hmy8 extends TestCase {

    public void test_ser() throws Exception {
        IEventDto dto = new IEventDto();
        dto.getEventList().add(new IEvent());
        
        JSON.toJSONString(dto);
    }
}=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.json.bvtVO.IEventDto;

public class Bug_for_hmy8 extends TestCase {

    public void test_ser() throws Exception {
        IEventDto dto = new IEventDto();
        
        JSON.toJSONString(dto);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/test/java/com/alibaba/json/bvtVO/IEventDto.java;<<<<<<< MINE
/**
 * Project: eve.services
 * 
 * File Created at 2011-12-21
 * $Id$
 * 
 * Copyright 2008 Alibaba.com Corporation Limited.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Alibaba Company. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Alibaba.com.
 */
package com.alibaba.json.bvtVO;

import java.io.Serializable;
import java.util.ArrayList;

/**
 * @author wb_jianhui.shijh
 */
public class IEventDto implements Serializable {

    private static final long serialVersionUID = -3903138261314727539L;

    private String            source;

    private ArrayList<IEvent> eventList = new ArrayList<IEvent>();

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }
    
    public ArrayList<IEvent> getEventList() {
        return eventList;
    }

    public void setEventList(ArrayList<IEvent> eventList) {
        this.eventList = eventList;
    }

    @Override
    public String toString() {
        return "IEventDto [source=" + source + ", eventList=" + eventList + "]";
    }

}=======
/**
 * Project: eve.services
 * 
 * File Created at 2011-12-21
 * $Id$
 * 
 * Copyright 2008 Alibaba.com Corporation Limited.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Alibaba Company. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Alibaba.com.
 */
package com.alibaba.json.bvtVO;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * @author wb_jianhui.shijh
 */
public class IEventDto implements Serializable {

    private static final long serialVersionUID = -3903138261314727539L;

    private String            source;

    private ArrayList<IEvent> eventList;

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }
    
    public ArrayList<IEvent> getEventList() {
        return eventList;
    }

    public void setEventList(ArrayList<IEvent> eventList) {
        this.eventList = eventList;
    }

    @Override
    public String toString() {
        return "IEventDto [source=" + source + ", eventList=" + eventList + "]";
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/test/java/com/alibaba/json/bvtVO/IEvent.java;<<<<<<< MINE
=======
/**
 * Project: eve.services
 * 
 * File Created at 2011-12-21
 * $Id$
 * 
 * Copyright 2008 Alibaba.com Corporation Limited.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Alibaba Company. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Alibaba.com.
 */
package com.alibaba.json.bvtVO;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.Map;

/**
 * 
 * 
 * @author wb_jianhui.shijh
 */
public class IEvent implements Serializable {

    private static final long   serialVersionUID = -791431935700654454L;

    /**
     * 
     */
    private String              name;

    /**
     * 
     */
    private String              source;

    /**
     * 
     */
    private Map<String, Object> detailData;

    /**
     * 
     */
    private Timestamp           generateTime;

    /**
     * ID.
     */
    private String              externalId;

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public Map<String, Object> getDetailData() {
        return detailData;
    }

    public void setDetailData(Map<String, Object> detailData) {
        this.detailData = detailData;
    }

    public Timestamp getGenerateTime() {
        return generateTime;
    }

    public void setGenerateTime(Timestamp generateTime) {
        this.generateTime = generateTime;
    }

    @Override
    public String toString() {
        return "IEvent [name=" + name + ", source=" + source + ", externalId=" + externalId
                + ", generateTime=" + generateTime + ", detailData=" + detailData + "]";
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_int.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_int extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private int value;

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_short.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_short extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private short value;

        public short getValue() {
            return value;
        }

        public void setValue(short value) {
            throw new UnsupportedOperationException();
        }

    }
}=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_short extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }

    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }

    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private short value;

        public short getValue() {
            return value;
        }

        public void setValue(short value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_float.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_float extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private float value;

        public float getValue() {
            return value;
        }

        public void setValue(float value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_long.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_long extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private long value;

        public long getValue() {
            return value;
        }

        public void setValue(long value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_byte.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_byte extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private byte value;

        public byte getValue() {
            return value;
        }

        public void setValue(byte value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_json_array.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_json_array extends TestCase {

    public void test_bug() throws Exception {
        String jsonStr = "{\"state\":0,\"data\":[{\"items\":[{\"tip\":\"\u5218\u82e5\u82f1\",\"url\":\"xiami:\\/\\/artist\\/1930\"},{\"tip\":\"\u5218\u5fb7\u534e\",\"url\":\"xiami:\\/\\/artist\\/648\"}],\"type\":\"artist\"},{\"items\":[{\"tip\":\"\u6f02\u6d0b\u8fc7\u6d77\u6765\u770b\u4f60 (Live) - \u5218\u660e\u6e58\",\"url\":\"xiami:\\/\\/song\\/1773431302\"},{\"tip\":\"\\u6211\\u4eec\\u6ca1\\u6709\\u5728\\u4e00\\u8d77 - \\u5218\\u82e5\\u82f1\",\"url\":\"xiami:\\/\\/song\\/1769471863\"},{\"tip\":\"\\u54ed\u7802 (Live)(\\u5218\\u660e\\u6e58\\u80dc\\u51fa) - \\u5218\u660e\u6e58\",\"url\":\"xiami:\\/\\/ song\\/1773484887\"}],\"type\":\"song\"},{\"items\":[{\"tip\":\"\\u4eb2\\u7231\\u7684\\u8def\\u4eba - \\u5218\\u82e5\\u82f1\",\"url\":\"xiami:\\/\\/album\\/55230\"},{\"tip\":\"\\u5728\\u4e00\\u8d77 - \\u5218\\u82e5\\u82f1\",\"url\":\"xiami:\\/\\/album\\/377241\"}],\"type\":\"album\"}],\"status\":\"ok\",\"err\":null} ";

        Parser parser = JSON.parseObject(jsonStr, Parser.class);

        System.out.println(JSON.toJSONString(parser));
    }

    public static class Parser {

        public int    state;
        public JSON   data;
        public String status;
        public String err;

        public int getState() {
            return state;
        }

        public void setState(int state) {
            this.state = state;
        }

        public JSON getData() {
            return data;
        }

        public void setData(JSON data) {
            this.data = data;
        }

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }

        public String getErr() {
            return err;
        }

        public void setErr(String err) {
            this.err = err;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_boolean.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_boolean extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private boolean value;

        public boolean getValue() {
            return value;
        }

        public void setValue(boolean value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_double.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_double extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private double value;

        public double getValue() {
            return value;
        }

        public void setValue(double value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_a3e83d9_441164d/rev_a3e83d9-441164d/src/test/java/com/alibaba/json/bvt/parser/JSONLexerAllowCommentTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser;

import java.io.IOException;
import java.io.InputStream;

import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;
import org.junit.Assert;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.JSONReaderScanner;

public class JSONLexerAllowCommentTest extends TestCase {
    public void test_0() throws Exception {
        
        String jsonWithComment = "{ /*tes****\n\r\n*t*/\"a\":1 /*****test88888*****/ /*test*/ , /*test*/ //test\n //est\n \"b\":2}";
        JSONObject object = JSON.parseObject(jsonWithComment, Feature.AllowComment);
        System.out.println(object.toJSONString());
        Assert.assertEquals("{\"b\":2,\"a\":1}",object.toJSONString());

        DefaultJSONParser parser = new DefaultJSONParser(new JSONReaderScanner(jsonWithComment,
            Feature.AllowComment.getMask()));
        JSONObject object1 = parser.parseObject();
        Assert.assertEquals("{\"b\":2,\"a\":1}",object1.toJSONString());
        System.out.println(object1.toJSONString());

    }

    public void test_1() throws IOException {
        String resource = "json/json_with_comment.json";
        InputStream is = Thread.currentThread().getContextClassLoader()
            .getResourceAsStream(resource);
        String text = IOUtils.toString(is);
        is.close();

        JSONObject object = JSON.parseObject(text, Feature.AllowComment);
        System.out.println(object.toJSONString());

        Assert
            .assertEquals(
                "{\"hello\":\"asafsadf\",\"test\":1,\"object\":{\"teset\":1000},\"array\":[\"10000sfsaf\",100,{\"nihao\":{\"test\":\"sdfasdf\"}}]}",
                object.toJSONString());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
public class FastJsonHttpMessageConverter extends AbstractHttpMessageConverter<Object> {
=======
public class FastJsonHttpMessageConverter extends AbstractHttpMessageConverter<Object> implements GenericHttpMessageConverter<Object> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java;<<<<<<< MINE
    public static class UnitTests {

        static AtomicInteger counter = new AtomicInteger();

        @Before
        public void init() {
            counter.set(0);
            // since we're going to modify properties of the same class between tests, wipe the cache each time
            reset();
            /* we must call this to simulate a new request lifecycle running and clearing caches */
            HystrixRequestContext.initializeContext();
        }

        @After
        public void cleanup() {
            // instead of storing the reference from initialize we'll just get the current state and shutdown
            if (HystrixRequestContext.getContextForCurrentThread() != null) {
                // it may be null if a test shuts the context down manually
                HystrixRequestContext.getContextForCurrentThread().shutdown();
            }
        }

        @Test
        public void testTwoRequests() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testMultipleBatches() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());

            assertEquals(1, counter.get());

            // now request more
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("3", response3.get());

            // we should have had it execute twice now
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testMaxRequestsInBatch() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1, 2, 10).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2, 2, 10).queue();
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3, 2, 10).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());

            // we should have had it execute twice because the batch size was 2
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestsOverTime() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            timer.incrementTime(5);
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(6);
            Future<String> response4 = new TestRequestCollapser(timer, counter, 4).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response5 = new TestRequestCollapser(timer, counter, 5).queue();
            timer.incrementTime(10);
            // should execute here

            // wait for all tasks to complete
            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());
            assertEquals("5", response5.get());

            System.out.println("number of executions: " + counter.get());
            assertEquals(3, counter.get());
            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testUnsubscribeOnOneDoesntKillBatch() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();

            // kill the first
            response1.cancel(true);

            timer.incrementTime(10); // let time pass that equals the default delay/period

            // the first is cancelled so should return null
            assertEquals(null, response1.get());
            // we should still get a response on the second
            assertEquals("2", response2.get());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testShardedRequests() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestShardedRequestCollapser(timer, counter, "1a").queue();
            Future<String> response2 = new TestShardedRequestCollapser(timer, counter, "2b").queue();
            Future<String> response3 = new TestShardedRequestCollapser(timer, counter, "3b").queue();
            Future<String> response4 = new TestShardedRequestCollapser(timer, counter, "4a").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1a", response1.get());
            assertEquals("2b", response2.get());
            assertEquals("3b", response3.get());
            assertEquals("4a", response4.get());

            /* we should get 2 batches since it gets sharded */
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestScope() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, "2").queue();

            // simulate a new request
            RequestCollapserFactory.resetRequest();

            Future<String> response3 = new TestRequestCollapser(timer, counter, "3").queue();
            Future<String> response4 = new TestRequestCollapser(timer, counter, "4").queue();

            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());

            // 2 different batches should execute, 1 per request
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testGlobalScope() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestGloballyScopedRequestCollapser(timer, counter, "1").queue();
            Future<String> response2 = new TestGloballyScopedRequestCollapser(timer, counter, "2").queue();

            // simulate a new request
            RequestCollapserFactory.resetRequest();

            Future<String> response3 = new TestGloballyScopedRequestCollapser(timer, counter, "3").queue();
            Future<String> response4 = new TestGloballyScopedRequestCollapser(timer, counter, "4").queue();

            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());

            // despite having cleared the cache in between we should have a single execution because this is on the global not request cache
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testErrorHandlingViaFutureException() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapserWithFaultyCreateCommand(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapserWithFaultyCreateCommand(timer, counter, "2").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            try {
                response1.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }
            try {
                response2.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }

            assertEquals(0, counter.get());
            assertEquals(0, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testErrorHandlingWhenMapToResponseFails() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapserWithFaultyMapToResponse(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapserWithFaultyMapToResponse(timer, counter, "2").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            try {
                response1.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }
            try {
                response2.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }

            // the batch failed so no executions
            assertEquals(0, counter.get());
            // but it still executed the command once
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestVariableLifecycle1() throws Exception {
            // simulate request lifecycle
            HystrixRequestContext requestContext = HystrixRequestContext.initializeContext();

            // do actual work
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            timer.incrementTime(5);
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(6);
            Future<String> response4 = new TestRequestCollapser(timer, counter, 4).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response5 = new TestRequestCollapser(timer, counter, 5).queue();
            timer.incrementTime(10);
            // should execute here

            // wait for all tasks to complete
            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());
            assertEquals("5", response5.get());

            // each task should have been executed 3 times
            for (TestCollapserTimer.ATask t : timer.tasks) {
                assertEquals(3, t.task.count.get());
            }

            System.out.println("timer.tasks.size() A: " + timer.tasks.size());
            System.out.println("tasks in test: " + timer.tasks);

            // simulate request lifecycle
            requestContext.shutdown();

            System.out.println("timer.tasks.size() B: " + timer.tasks.size());

            HystrixRequestVariableHolder<RequestCollapser<?, ?, ?>> rv = RequestCollapserFactory.getRequestVariable(new TestRequestCollapser(timer, counter, 1).getCollapserKey().name());

            assertNotNull(rv);
            // they should have all been removed as part of ThreadContext.remove()
            assertEquals(0, timer.tasks.size());
        }

        @Test
        public void testRequestVariableLifecycle2() throws Exception {
            // simulate request lifecycle
            HystrixRequestContext requestContext = HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            final ConcurrentLinkedQueue<Future<String>> responses = new ConcurrentLinkedQueue<Future<String>>();
            ConcurrentLinkedQueue<Thread> threads = new ConcurrentLinkedQueue<Thread>();

            // kick off work (simulating a single request with multiple threads)
            for (int t = 0; t < 5; t++) {
                Thread th = new Thread(new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {

                    @Override
                    public void run() {
                        for (int i = 0; i < 100; i++) {
                            responses.add(new TestRequestCollapser(timer, counter, 1).queue());
                        }
                    }
                }));

                threads.add(th);
                th.start();
            }

            for (Thread th : threads) {
                // wait for each thread to finish
                th.join();
            }

            // we expect 5 threads * 100 responses each
            assertEquals(500, responses.size());

            for (Future<String> f : responses) {
                // they should not be done yet because the counter hasn't incremented
                assertFalse(f.isDone());
            }

            timer.incrementTime(5);
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(6);
            Future<String> response4 = new TestRequestCollapser(timer, counter, 4).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response5 = new TestRequestCollapser(timer, counter, 5).queue();
            timer.incrementTime(10);
            // should execute here

            // wait for all tasks to complete
            for (Future<String> f : responses) {
                assertEquals("1", f.get());
            }
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());
            assertEquals("5", response5.get());

            // each task should have been executed 3 times
            for (TestCollapserTimer.ATask t : timer.tasks) {
                assertEquals(3, t.task.count.get());
            }

            // simulate request lifecycle
            requestContext.shutdown();

            HystrixRequestVariableHolder<RequestCollapser<?, ?, ?>> rv = RequestCollapserFactory.getRequestVariable(new TestRequestCollapser(timer, counter, 1).getCollapserKey().name());

            assertNotNull(rv);
            // they should have all been removed as part of ThreadContext.remove()
            assertEquals(0, timer.tasks.size());
        }

        /**
         * Test Request scoped caching of commands so that a 2nd duplicate call doesn't execute but returns the previous Future
         */
        @Test
        public void testRequestCache1() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("A", f2.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f3 = command1.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should still have executed only one command
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test Request scoped caching doesn't prevent different ones from executing
         */
        @Test
        public void testRequestCache2() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", true);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f3 = command1.queue();
            Future<String> f4 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
                assertEquals("B", f4.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should still have executed only one command
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testRequestCache3() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", true);
            SuccessfulCacheableCollapsedCommand command3 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", true);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("B", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f4 = command1.queue();
            Future<String> f5 = command2.queue();
            Future<String> f6 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f4.get());
                assertEquals("B", f5.get());
                assertEquals("B", f6.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should still have executed only one command
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testNoRequestCache3() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", false);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", false);
            SuccessfulCacheableCollapsedCommand command3 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", false);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("B", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f4 = command1.queue();
            Future<String> f5 = command2.queue();
            Future<String> f6 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f4.get());
                assertEquals("B", f5.get());
                assertEquals("B", f6.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // request caching is turned off on this so we expect 2 command executions
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            // we expect to see it with SUCCESS and COLLAPSED and both
            HystrixCommand<?> commandA = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[2])[0];
            assertEquals(2, commandA.getExecutionEvents().size());
            assertTrue(commandA.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(commandA.getExecutionEvents().contains(HystrixEventType.COLLAPSED));

            // we expect to see it with SUCCESS and COLLAPSED and both
            HystrixCommand<?> commandB = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[2])[1];
            assertEquals(2, commandB.getExecutionEvents().size());
            assertTrue(commandB.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(commandB.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test that a command that throws an Exception when cached will re-throw the exception.
         */
        @Test
        public void testRequestCacheWithException() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            ConcurrentLinkedQueue<HystrixCommand<List<String>>> commands = new ConcurrentLinkedQueue<HystrixCommand<List<String>>>();

            final TestCollapserTimer timer = new TestCollapserTimer();
            // pass in 'null' which will cause an NPE to be thrown
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, null, true, commands);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, null, true, commands);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("A", f2.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should have executed 1 command
            assertEquals(1, commands.size());
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.FAILURE));
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.COLLAPSED));

            SuccessfulCacheableCollapsedCommand command3 = new SuccessfulCacheableCollapsedCommand(timer, counter, null, true, commands);
            Future<String> f3 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should still be 1 ... no new executions
            assertEquals(1, commands.size());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.FAILURE));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test that a command that times out will still be cached and when retrieved will re-throw the exception.
         */
        @Test
        public void testRequestCacheWithTimeout() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            ConcurrentLinkedQueue<HystrixCommand<List<String>>> commands = new ConcurrentLinkedQueue<HystrixCommand<List<String>>>();

            final TestCollapserTimer timer = new TestCollapserTimer();
            // pass in 'null' which will cause an NPE to be thrown
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "TIMEOUT", true, commands);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "TIMEOUT", true, commands);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("A", f2.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should have executed 1 command
            assertEquals(1, commands.size());
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.TIMEOUT));
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.COLLAPSED));

            Future<String> f3 = command1.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should still be 1 ... no new executions
            assertEquals(1, commands.size());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test how the collapser behaves when the circuit is short-circuited
         */
        @Test
        public void testRequestWithCommandShortCircuited() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapserWithShortCircuitedCommand(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapserWithShortCircuitedCommand(timer, counter, "2").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            try {
                response1.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                //                e.printStackTrace();
                // what we expect
            }
            try {
                response2.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                //                e.printStackTrace();
                // what we expect
            }

            assertEquals(0, counter.get());
            // it will execute once (short-circuited)
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a Void response type - null being set as response.
         * 
         * @throws Exception
         */
        @Test
        public void testVoidResponseTypeFireAndForgetCollapsing1() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<Void> response1 = new TestCollapserWithVoidResponseType(timer, counter, 1).queue();
            Future<Void> response2 = new TestCollapserWithVoidResponseType(timer, counter, 2).queue();
            timer.incrementTime(100); // let time pass that equals the default delay/period

            // normally someone wouldn't wait on these, but we need to make sure they do in fact return
            // and not block indefinitely in case someone does call get()
            assertEquals(null, response1.get());
            assertEquals(null, response2.get());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a Void response type - response never being set in mapResponseToRequest
         * 
         * @throws Exception
         */
        @Test
        public void testVoidResponseTypeFireAndForgetCollapsing2() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<Void> response1 = new TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests(timer, counter, 1).queue();
            Future<Void> response2 = new TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests(timer, counter, 2).queue();
            timer.incrementTime(100); // let time pass that equals the default delay/period

            // we will fetch one of these just so we wait for completion ... but expect an error
            try {
                assertEquals(null, response1.get());
                fail("expected an error as mapResponseToRequests did not set responses");
            } catch (ExecutionException e) {
                assertTrue(e.getCause() instanceof IllegalStateException);
                assertTrue(e.getCause().getMessage().startsWith("No response set by"));
            }

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }
        
        /**
         * Test a Void response type with execute - response being set in mapResponseToRequest to null
         * 
         * @throws Exception
         */
        @Test
        public void testVoidResponseTypeFireAndForgetCollapsing3() throws Exception {
            CollapserTimer timer = new RealCollapserTimer();
            assertNull(new TestCollapserWithVoidResponseType(timer, counter, 1).execute());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        private static class TestRequestCollapser extends HystrixCollapser<List<String>, String, String> {

            private final AtomicInteger count;
            private final String value;
            private ConcurrentLinkedQueue<HystrixCommand<List<String>>> commandsExecuted;

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, int value) {
                this(timer, counter, String.valueOf(value));
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value) {
                this(timer, counter, value, 10000, 10);
            }

            public TestRequestCollapser(Scope scope, TestCollapserTimer timer, AtomicInteger counter, String value) {
                this(scope, timer, counter, value, 10000, 10);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                this(timer, counter, value, 10000, 10, executionLog);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, int value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds) {
                this(timer, counter, String.valueOf(value), defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds) {
                this(timer, counter, value, defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds, null);
            }

            public TestRequestCollapser(Scope scope, TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds) {
                this(scope, timer, counter, value, defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds, null);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                this(Scope.REQUEST, timer, counter, value, defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds, executionLog);
            }

            public TestRequestCollapser(Scope scope, TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                // use a CollapserKey based on the CollapserTimer object reference so it's unique for each timer as we don't want caching
                // of properties to occur and we're using the default HystrixProperty which typically does caching
                super(collapserKeyFromString(timer), scope, timer, HystrixCollapserProperties.Setter().withMaxRequestsInBatch(defaultMaxRequestsInBatch).withTimerDelayInMilliseconds(defaultTimerDelayInMilliseconds));
                this.count = counter;
                this.value = value;
                this.commandsExecuted = executionLog;
            }

            @Override
            public String getRequestArgument() {
                return value;
            }

            @Override
            public HystrixCommand<List<String>> createCommand(final Collection<CollapsedRequest<String, String>> requests) {
                /* return a mocked command */
                HystrixCommand<List<String>> command = new TestCollapserCommand(requests);
                if (commandsExecuted != null) {
                    commandsExecuted.add(command);
                }
                return command;
            }

            @Override
            public void mapResponseToRequests(List<String> batchResponse, Collection<CollapsedRequest<String, String>> requests) {
                // count how many times a batch is executed (this method is executed once per batch)
                System.out.println("increment count: " + count.incrementAndGet());

                // for simplicity I'll assume it's a 1:1 mapping between lists ... in real implementations they often need to index to maps
                // to allow random access as the response size does not match the request size
                if (batchResponse.size() != requests.size()) {
                    throw new RuntimeException("lists don't match in size => " + batchResponse.size() + " : " + requests.size());
                }
                int i = 0;
                for (CollapsedRequest<String, String> request : requests) {
                    request.setResponse(batchResponse.get(i++));
                }

            }

        }

        /**
         * Shard on the artificially provided 'type' variable.
         */
        private static class TestShardedRequestCollapser extends TestRequestCollapser {

            public TestShardedRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            protected Collection<Collection<CollapsedRequest<String, String>>> shardRequests(Collection<CollapsedRequest<String, String>> requests) {
                Collection<CollapsedRequest<String, String>> typeA = new ArrayList<CollapsedRequest<String, String>>();
                Collection<CollapsedRequest<String, String>> typeB = new ArrayList<CollapsedRequest<String, String>>();

                for (CollapsedRequest<String, String> request : requests) {
                    if (request.getArgument().endsWith("a")) {
                        typeA.add(request);
                    } else if (request.getArgument().endsWith("b")) {
                        typeB.add(request);
                    }
                }

                ArrayList<Collection<CollapsedRequest<String, String>>> shards = new ArrayList<Collection<CollapsedRequest<String, String>>>();
                shards.add(typeA);
                shards.add(typeB);
                return shards;
            }

        }

        /**
         * Test the global scope
         */
        private static class TestGloballyScopedRequestCollapser extends TestRequestCollapser {

            public TestGloballyScopedRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(Scope.GLOBAL, timer, counter, value);
            }

        }

        /**
         * Throw an exception when creating a command.
         */
        private static class TestRequestCollapserWithFaultyCreateCommand extends TestRequestCollapser {

            public TestRequestCollapserWithFaultyCreateCommand(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            public HystrixCommand<List<String>> createCommand(Collection<CollapsedRequest<String, String>> requests) {
                throw new RuntimeException("some failure");
            }

        }

        /**
         * Throw an exception when creating a command.
         */
        private static class TestRequestCollapserWithShortCircuitedCommand extends TestRequestCollapser {

            public TestRequestCollapserWithShortCircuitedCommand(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            public HystrixCommand<List<String>> createCommand(Collection<CollapsedRequest<String, String>> requests) {
                // args don't matter as it's short-circuited
                return new ShortCircuitedCommand();
            }

        }

        /**
         * Throw an exception when mapToResponse is invoked
         */
        private static class TestRequestCollapserWithFaultyMapToResponse extends TestRequestCollapser {

            public TestRequestCollapserWithFaultyMapToResponse(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            public void mapResponseToRequests(List<String> batchResponse, Collection<CollapsedRequest<String, String>> requests) {
                // pretend we blow up with an NPE
                throw new NullPointerException("batchResponse was null and we blew up");
            }

        }

        private static class TestCollapserCommand extends TestHystrixCommand<List<String>> {

            private final Collection<CollapsedRequest<String, String>> requests;

            TestCollapserCommand(Collection<CollapsedRequest<String, String>> requests) {
                super(testPropsBuilder().setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(50)));
                this.requests = requests;
            }

            @Override
            protected List<String> run() {
                System.out.println(">>> TestCollapserCommand run() ... batch size: " + requests.size());
                // simulate a batch request
                ArrayList<String> response = new ArrayList<String>();
                for (CollapsedRequest<String, String> request : requests) {
                    if (request.getArgument() == null) {
                        throw new NullPointerException("Simulated Error");
                    }
                    if (request.getArgument() == "TIMEOUT") {
                        try {
                            Thread.sleep(200);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    response.add(request.getArgument());
                }
                return response;
            }

        }

        /**
         * A Command implementation that supports caching.
         */
        private static class SuccessfulCacheableCollapsedCommand extends TestRequestCollapser {

            private final boolean cacheEnabled;

            public SuccessfulCacheableCollapsedCommand(TestCollapserTimer timer, AtomicInteger counter, String value, boolean cacheEnabled) {
                super(timer, counter, value);
                this.cacheEnabled = cacheEnabled;
            }

            public SuccessfulCacheableCollapsedCommand(TestCollapserTimer timer, AtomicInteger counter, String value, boolean cacheEnabled, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                super(timer, counter, value, executionLog);
                this.cacheEnabled = cacheEnabled;
            }

            @Override
            public String getCacheKey() {
                if (cacheEnabled)
                    return "aCacheKey_" + super.value;
                else
                    return null;
            }
        }

        private static class ShortCircuitedCommand extends HystrixCommand<List<String>> {

            protected ShortCircuitedCommand() {
                super(HystrixCommand.Setter.withGroupKey(
                        HystrixCommandGroupKey.Factory.asKey("shortCircuitedCommand"))
                        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter
                                .getUnitTestPropertiesSetter()
                                .withCircuitBreakerForceOpen(true)));
            }

            @Override
            protected List<String> run() throws Exception {
                System.out.println("*** execution (this shouldn't happen)");
                // this won't ever get called as we're forcing short-circuiting
                ArrayList<String> values = new ArrayList<String>();
                values.add("hello");
                return values;
            }

        }

        private static class FireAndForgetCommand extends HystrixCommand<Void> {

            protected FireAndForgetCommand(List<Integer> values) {
                super(HystrixCommand.Setter.withGroupKey(
                        HystrixCommandGroupKey.Factory.asKey("fireAndForgetCommand"))
                        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter()));
            }

            @Override
            protected Void run() throws Exception {
                System.out.println("*** FireAndForgetCommand execution: " + Thread.currentThread());
                return null;
            }

        }

        private static class TestCollapserTimer implements CollapserTimer {

            private final ConcurrentLinkedQueue<ATask> tasks = new ConcurrentLinkedQueue<ATask>();

            @Override
            public Reference<TimerListener> addListener(final TimerListener collapseTask) {
                System.out.println("add listener: " + collapseTask);
                tasks.add(new ATask(new TestTimerListener(collapseTask)));

                /**
                 * This is a hack that overrides 'clear' of a WeakReference to match the required API
                 * but then removes the strong-reference we have inside 'tasks'.
                 * <p>
                 * We do this so our unit tests know if the WeakReference is cleared correctly, and if so then the ATack is removed from 'tasks'
                 */
                return new SoftReference<TimerListener>(collapseTask) {
                    @Override
                    public void clear() {
                        System.out.println("tasks: " + tasks);
                        System.out.println("**** clear TimerListener: tasks.size => " + tasks.size());
                        // super.clear();
                        for (ATask t : tasks) {
                            if (t.task.actualListener.equals(collapseTask)) {
                                tasks.remove(t);
                            }
                        }
                    }

                };
            }

            /**
             * Increment time by X. Note that incrementing by multiples of delay or period time will NOT execute multiple times.
             * <p>
             * You must call incrementTime multiple times each increment being larger than 'period' on subsequent calls to cause multiple executions.
             * <p>
             * This is because executing multiple times in a tight-loop would not achieve the correct behavior, such as batching, since it will all execute "now" not after intervals of time.
             * 
             * @param timeInMilliseconds
             */
            public synchronized void incrementTime(int timeInMilliseconds) {
                for (ATask t : tasks) {
                    t.incrementTime(timeInMilliseconds);
                }
            }

            private static class ATask {
                final TestTimerListener task;
                final int delay = 10;

                // our relative time that we'll use
                volatile int time = 0;
                volatile int executionCount = 0;

                private ATask(TestTimerListener task) {
                    this.task = task;
                }

                public synchronized void incrementTime(int timeInMilliseconds) {
                    time += timeInMilliseconds;
                    if (task != null) {
                        if (executionCount == 0) {
                            System.out.println("ExecutionCount 0 => Time: " + time + " Delay: " + delay);
                            if (time >= delay) {
                                // first execution, we're past the delay time
                                executeTask();
                            }
                        } else {
                            System.out.println("ExecutionCount 1+ => Time: " + time + " Delay: " + delay);
                            if (time >= delay) {
                                // subsequent executions, we're past the interval time
                                executeTask();
                            }
                        }
                    }
                }

                private synchronized void executeTask() {
                    System.out.println("Executing task ...");
                    task.tick();
                    this.time = 0; // we reset time after each execution
                    this.executionCount++;
                    System.out.println("executionCount: " + executionCount);
                }
            }

        }

        private static class TestTimerListener implements TimerListener {

            private final TimerListener actualListener;
            private final AtomicInteger count = new AtomicInteger();

            public TestTimerListener(TimerListener actual) {
                this.actualListener = actual;
            }

            @Override
            public void tick() {
                count.incrementAndGet();
                actualListener.tick();
            }

            @Override
            public int getIntervalTimeInMilliseconds() {
                return 10;
            }

        }

        private static HystrixCollapserKey collapserKeyFromString(final Object o) {
            return new HystrixCollapserKey() {

                @Override
                public String name() {
                    return String.valueOf(o);
                }

            };
        }

        private static class TestCollapserWithVoidResponseType extends HystrixCollapser<Void, Void, Integer> {

            private final AtomicInteger count;
            private final Integer value;

            public TestCollapserWithVoidResponseType(CollapserTimer timer, AtomicInteger counter, int value) {
                super(collapserKeyFromString(timer), Scope.REQUEST, timer, HystrixCollapserProperties.Setter().withMaxRequestsInBatch(1000).withTimerDelayInMilliseconds(50));
                this.count = counter;
                this.value = value;
            }

            @Override
            public Integer getRequestArgument() {
                return value;
            }

            @Override
            protected HystrixCommand<Void> createCommand(Collection<CollapsedRequest<Void, Integer>> requests) {

                ArrayList<Integer> args = new ArrayList<Integer>();
                for (CollapsedRequest<Void, Integer> request : requests) {
                    args.add(request.getArgument());
                }
                return new FireAndForgetCommand(args);
            }

            @Override
            protected void mapResponseToRequests(Void batchResponse, Collection<CollapsedRequest<Void, Integer>> requests) {
                count.incrementAndGet();
                for (CollapsedRequest<Void, Integer> r : requests) {
                    r.setResponse(null);
                }
            }

        }

        private static class TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests extends HystrixCollapser<Void, Void, Integer> {

            private final AtomicInteger count;
            private final Integer value;

            public TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests(CollapserTimer timer, AtomicInteger counter, int value) {
                super(collapserKeyFromString(timer), Scope.REQUEST, timer, HystrixCollapserProperties.Setter().withMaxRequestsInBatch(1000).withTimerDelayInMilliseconds(50));
                this.count = counter;
                this.value = value;
            }

            @Override
            public Integer getRequestArgument() {
                return value;
            }

            @Override
            protected HystrixCommand<Void> createCommand(Collection<CollapsedRequest<Void, Integer>> requests) {

                ArrayList<Integer> args = new ArrayList<Integer>();
                for (CollapsedRequest<Void, Integer> request : requests) {
                    args.add(request.getArgument());
                }
                return new FireAndForgetCommand(args);
            }

            @Override
            protected void mapResponseToRequests(Void batchResponse, Collection<CollapsedRequest<Void, Integer>> requests) {
                count.incrementAndGet();
            }

        }
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java;<<<<<<< MINE
    
    public static class UnitTest {
        
        @Before
        public void prepareForTest() {
            /* we must call this to simulate a new request lifecycle running and clearing caches */
            HystrixRequestContext.initializeContext();
        }

        @After
        public void cleanup() {
            // instead of storing the reference from initialize we'll just get the current state and shutdown
            if (HystrixRequestContext.getContextForCurrentThread() != null) {
                // it could have been set NULL by the test
                HystrixRequestContext.getContextForCurrentThread().shutdown();
            }

            // force properties to be clean as well
            ConfigurationManager.getConfigInstance().clear();
        }
        
        /**
         * If the RequestContext does not get transferred across threads correctly this blows up. 
         * No specific assertions are necessary.
         */
        @Test
        public void testRequestContextPropagatesAcrossObserveOnPool() {
            new SimpleCommand().execute();
            new SimpleCommand().observe().map(new Func1<String, String>() {

                @Override
                public String call(String s) {
                    System.out.println("Map => Commands: " + HystrixRequestLog.getCurrentRequest().getExecutedCommands());
                    return s;
                }
            }).toBlockingObservable().forEach(new Action1<String>() {

                @Override
                public void call(String s) {
                    System.out.println("Result [" + s + "] => Commands: " + HystrixRequestLog.getCurrentRequest().getExecutedCommands());
                }
            });
        }
        
        private static class SimpleCommand extends HystrixCommand<String> {

            public SimpleCommand() {
                super(HystrixCommandGroupKey.Factory.asKey("SimpleCommand"));
            }
            
            @Override
            protected String run() throws Exception {
                System.out.println("Executing => Commands: " + HystrixRequestLog.getCurrentRequest().getExecutedCommands());
                return "Hello";
            }
            
        }
        
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextFunc2.java;<<<<<<< MINE
/**
 * Copyright 2012 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.hystrix.strategy.concurrency;

import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicReference;

import rx.Scheduler;
import rx.Subscription;
import rx.util.functions.Func2;

import com.netflix.hystrix.strategy.HystrixPlugins;

/**
 * Wrapper around {@link Func2} that manages the {@link HystrixRequestContext} initialization and cleanup for the execution of the {@link Func2}
 * 
 * @param <T>
 *            Return type of {@link Func2}
 * 
 * @ExcludeFromJavadoc
 */
public class HystrixContextFunc2<T> implements Func2<Scheduler, T, Subscription> {

    private final Func2<? super Scheduler, ? super T, ? extends Subscription> actual;
    private final HystrixRequestContext parentThreadState;
    private final Callable<Subscription> c;

    /*
     * This is a workaround to needing to use Callable<Subscription> but
     * needing to pass `Scheduler t1, T t2` into it after construction.
     * 
     * Think of it like sticking t1 and t2 on the stack and then calling the function
     * that uses them.
     * 
     * This should all be thread-safe without issues despite multi-step execution
     * because this Func2 is only ever executed once by Hystrix and construction will always
     * precede `call` being invoked once. 
     * 
     */
    private final AtomicReference<Scheduler> t1Holder = new AtomicReference<Scheduler>();
    private final AtomicReference<T> t2Holder = new AtomicReference<T>();

    public HystrixContextFunc2(Func2<? super Scheduler, ? super T, ? extends Subscription> action) {
        this(HystrixPlugins.getInstance().getConcurrencyStrategy(), action);
    }
    
    public HystrixContextFunc2(final HystrixConcurrencyStrategy concurrencyStrategy, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {
        this.actual = action;
        this.parentThreadState = HystrixRequestContext.getContextForCurrentThread();

        this.c = concurrencyStrategy.wrapCallable(new Callable<Subscription>() {

            @Override
            public Subscription call() throws Exception {
                HystrixRequestContext existingState = HystrixRequestContext.getContextForCurrentThread();
                try {
                    // set the state of this thread to that of its parent
                    HystrixRequestContext.setContextOnCurrentThread(parentThreadState);
                    // execute actual Func2 with the state of the parent
                    return actual.call(new HystrixContextScheduler(concurrencyStrategy, t1Holder.get()), t2Holder.get());
                } finally {
                    // restore this thread back to its original state
                    HystrixRequestContext.setContextOnCurrentThread(existingState);
                }
            }
        });
    }

    @Override
    public Subscription call(Scheduler t1, T t2) {
        try {
            this.t1Holder.set(t1);
            this.t2Holder.set(t2);
            return c.call();
        } catch (Exception e) {
            throw new RuntimeException("Failed executing wrapped Func2", e);
        }
    }

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java;<<<<<<< MINE
    public static class UnitTest {

        @After
        public void reset() {
            // use private access to reset so we can test different initializations via the public static flow
            HystrixPlugins.getInstance().concurrencyStrategy.set(null);
            HystrixPlugins.getInstance().metricsPublisher.set(null);
            HystrixPlugins.getInstance().notifier.set(null);
            HystrixPlugins.getInstance().propertiesFactory.set(null);
        }

        @Test
        public void testEventNotifierDefaultImpl() {
            HystrixEventNotifier impl = HystrixPlugins.getInstance().getEventNotifier();
            assertTrue(impl instanceof HystrixEventNotifierDefault);
        }

        @Test
        public void testEventNotifierViaRegisterMethod() {
            HystrixPlugins.getInstance().registerEventNotifier(new HystrixEventNotifierTestImpl());
            HystrixEventNotifier impl = HystrixPlugins.getInstance().getEventNotifier();
            assertTrue(impl instanceof HystrixEventNotifierTestImpl);
        }

        @Test
        public void testEventNotifierViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixEventNotifierTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixEventNotifier.implementation", fullClass);
                HystrixEventNotifier impl = HystrixPlugins.getInstance().getEventNotifier();
                assertTrue(impl instanceof HystrixEventNotifierTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixEventNotifier.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixEventNotifierTestImpl extends HystrixEventNotifier {
            // just use defaults
        }

        @Test
        public void testConcurrencyStrategyDefaultImpl() {
            HystrixConcurrencyStrategy impl = HystrixPlugins.getInstance().getConcurrencyStrategy();
            assertTrue(impl instanceof HystrixConcurrencyStrategyDefault);
        }

        @Test
        public void testConcurrencyStrategyViaRegisterMethod() {
            HystrixPlugins.getInstance().registerConcurrencyStrategy(new HystrixConcurrencyStrategyTestImpl());
            HystrixConcurrencyStrategy impl = HystrixPlugins.getInstance().getConcurrencyStrategy();
            assertTrue(impl instanceof HystrixConcurrencyStrategyTestImpl);
        }

        @Test
        public void testConcurrencyStrategyViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixConcurrencyStrategyTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixConcurrencyStrategy.implementation", fullClass);
                HystrixConcurrencyStrategy impl = HystrixPlugins.getInstance().getConcurrencyStrategy();
                assertTrue(impl instanceof HystrixConcurrencyStrategyTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixConcurrencyStrategy.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixConcurrencyStrategyTestImpl extends HystrixConcurrencyStrategy {
            // just use defaults
        }

        @Test
        public void testMetricsPublisherDefaultImpl() {
            HystrixMetricsPublisher impl = HystrixPlugins.getInstance().getMetricsPublisher();
            assertTrue(impl instanceof HystrixMetricsPublisherDefault);
        }

        @Test
        public void testMetricsPublisherViaRegisterMethod() {
            HystrixPlugins.getInstance().registerMetricsPublisher(new HystrixMetricsPublisherTestImpl());
            HystrixMetricsPublisher impl = HystrixPlugins.getInstance().getMetricsPublisher();
            assertTrue(impl instanceof HystrixMetricsPublisherTestImpl);
        }

        @Test
        public void testMetricsPublisherViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixMetricsPublisherTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixMetricsPublisher.implementation", fullClass);
                HystrixMetricsPublisher impl = HystrixPlugins.getInstance().getMetricsPublisher();
                assertTrue(impl instanceof HystrixMetricsPublisherTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixMetricsPublisher.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixMetricsPublisherTestImpl extends HystrixMetricsPublisher {
            // just use defaults
        }

        @Test
        public void testPropertiesStrategyDefaultImpl() {
            HystrixPropertiesStrategy impl = HystrixPlugins.getInstance().getPropertiesStrategy();
            assertTrue(impl instanceof HystrixPropertiesStrategyDefault);
        }

        @Test
        public void testPropertiesStrategyViaRegisterMethod() {
            HystrixPlugins.getInstance().registerPropertiesStrategy(new HystrixPropertiesStrategyTestImpl());
            HystrixPropertiesStrategy impl = HystrixPlugins.getInstance().getPropertiesStrategy();
            assertTrue(impl instanceof HystrixPropertiesStrategyTestImpl);
        }

        @Test
        public void testPropertiesStrategyViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixPropertiesStrategyTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixPropertiesStrategy.implementation", fullClass);
                HystrixPropertiesStrategy impl = HystrixPlugins.getInstance().getPropertiesStrategy();
                assertTrue(impl instanceof HystrixPropertiesStrategyTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixPropertiesStrategy.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixPropertiesStrategyTestImpl extends HystrixPropertiesStrategy {
            // just use defaults
        }

        private static String getFullClassNameForTestClass(Class<?> cls) {
            return HystrixPlugins.class.getPackage().getName() + "." + HystrixPlugins.class.getSimpleName() + "$UnitTest$" + cls.getSimpleName();
        }
        
        
        private static final ThreadLocal<String> testRequestIdThreadLocal = new ThreadLocal<String>();

        public static class DummyCommand extends HystrixCommand<Void> {

            public DummyCommand() {
                super(HystrixCommandGroupKey.Factory.asKey("Dummy"));
            }

            @Override
            protected Void run() throws Exception {
                System.out.println("requestId (run) = " + testRequestIdThreadLocal.get());
                Thread.sleep(2000);
                return null;
            }
        }

        @Test
        public void testRequestContextViaPluginInTimeout() {
            HystrixPlugins.getInstance().registerConcurrencyStrategy(new HystrixConcurrencyStrategy() {
                @Override
                public <T> Callable<T> wrapCallable(final Callable<T> callable) {
                    return new RequestIdCallable<T>(callable);
                }
            });

            HystrixRequestContext context = HystrixRequestContext.initializeContext();

            testRequestIdThreadLocal.set("foobar");
            final AtomicReference<String> valueInTimeout = new AtomicReference<String>();

            new DummyCommand().toObservable()
                    .doOnError(new Action1<Throwable>() {
                        @Override
                        public void call(Throwable throwable) {
                            System.out.println("initialized = " + HystrixRequestContext.isCurrentThreadInitialized());
                            System.out.println("requestId (timeout) = " + testRequestIdThreadLocal.get());
                            valueInTimeout.set(testRequestIdThreadLocal.get());
                        }
                    })
                    .materialize()
                    .toBlockingObservable().single();

            context.shutdown();
            Hystrix.reset();
            
            assertEquals("foobar", valueInTimeout.get());
        }

        private static class RequestIdCallable<T> implements Callable<T> {
            private final Callable<T> callable;
            private final String requestId;

            public RequestIdCallable(Callable<T> callable) {
                this.callable = callable;
                this.requestId = testRequestIdThreadLocal.get();
            }

            @Override
            public T call() throws Exception {
                String original = testRequestIdThreadLocal.get();
                testRequestIdThreadLocal.set(requestId);
                try {
                    return callable.call();
                } finally {
                    testRequestIdThreadLocal.set(original);
                }
            }
        }
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java;<<<<<<< MINE
            }, commandOfDuplicateCall);
            this.originalObservable = originalObservable;
        }

        /*
         * This is a cached response so we want the command of the observable we're wrapping.
         */
        public HystrixCommand<R> getCommand() {
            return originalObservable.originalCommand;
        }
    }

    private static class TimeoutObservable<R> extends Observable<R> {

        public TimeoutObservable(final Observable<R> o, final HystrixCommand<R> originalCommand, final boolean isNonBlocking) {
            super(new OnSubscribeFunc<R>() {

                @Override
                public Subscription onSubscribe(final Observer<? super R> observer) {
                    // TODO this is using a private API of Rx so either move off of it or get Rx to make it public
                    // TODO better yet, get TimeoutObservable part of Rx
                    final SafeObservableSubscription s = new SafeObservableSubscription();

                    /*
                     * Define the action to perform on timeout outside of the TimerListener to it can capture the HystrixRequestContext
                     * of the calling thread which doesn't exist on the Timer thread.
                     */
                    final HystrixContextRunnable timeoutRunnable = new HystrixContextRunnable(originalCommand.concurrencyStrategy, new Runnable() {

                        @Override
                        public void run() {
                            try {
                                R v = originalCommand.getFallbackOrThrowException(HystrixEventType.TIMEOUT, FailureType.TIMEOUT, "timed-out", new TimeoutException());
                                observer.onNext(v);
                                observer.onCompleted();
                            } catch (HystrixRuntimeException re) {
                                observer.onError(re);
                            }
                        }
                    });
                    
                    TimerListener listener = new TimerListener() {

                        @Override
                        public void tick() {
                            // if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath
                            // otherwise it means we lost a race and the run() execution completed
                            if (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) {
                                // do fallback logic

                                // report timeout failure
                                originalCommand.metrics.markTimeout(System.currentTimeMillis() - originalCommand.invocationStartTime);

                                // we record execution time because we are returning before 
                                originalCommand.recordTotalExecutionTime(originalCommand.invocationStartTime);

                                timeoutRunnable.run();
                            }

                            s.unsubscribe();
                        }

                        @Override
                        public int getIntervalTimeInMilliseconds() {
                            return originalCommand.properties.executionIsolationThreadTimeoutInMilliseconds().get();
                        }
                    };

                    Reference<TimerListener> _tl = null;
                    if (isNonBlocking) {
                        /*
                         * Scheduling a separate timer to do timeouts is more expensive
                         * so we'll only do it if we're being used in a non-blocking manner.
                         */
                        _tl = HystrixTimer.getInstance().addTimerListener(listener);
                    } else {
                        /*
                         * Otherwise we just set the hook that queue().get() can trigger if a timeout occurs.
                         * 
                         * This allows the blocking and non-blocking approaches to be coded basically the same way
                         * though it is admittedly awkward if we were just blocking (the use of Reference annoys me for example)
                         */
                        _tl = new SoftReference<TimerListener>(listener);
                    }
                    final Reference<TimerListener> tl = _tl;

                    // set externally so execute/queue can see this
                    originalCommand.timeoutTimer.set(tl);

                    return s.wrap(o.subscribe(new Observer<R>() {
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/test/java/com/alibaba/json/bvt/serializer/ListFieldTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.serializer;

import java.util.ArrayList;
import java.util.List;

import org.junit.Assert;

import com.alibaba.fastjson.JSON;

import junit.framework.TestCase;

public class ListFieldTest extends TestCase {

    public void test_for_list() throws Exception {
        Model model = new Model();
        model.id = 1000;
        Assert.assertEquals("{\"id\":1000,\"values\":[]}", JSON.toJSONString(model));
        
        model.values.add("1001");
        Assert.assertEquals("{\"id\":1000,\"values\":[\"1001\"]}", JSON.toJSONString(model));
        
        model.values.add("1002");
        Assert.assertEquals("{\"id\":1000,\"values\":[\"1001\",\"1002\"]}", JSON.toJSONString(model));
        
        model.values.add("1003");
        Assert.assertEquals("{\"id\":1000,\"values\":[\"1001\",\"1002\",\"1003\"]}", JSON.toJSONString(model));
    }

    public static class Model {

        private int          id;
        private List<String> values = new ArrayList<String>();

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public List<String> getValues() {
            return values;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2292e51_354d504/rev_2292e51-354d504/src/test/java/com/alibaba/json/bvt/issue_1200/Issue1254.java;<<<<<<< MINE
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.json.bvt.bug.Bug_101_for_rongganlin_case2;
import junit.framework.TestCase;
import org.apache.commons.beanutils.BeanUtils;

import java.util.Map;

/**
 * Created by kimmking on 09/06/2017.
 */
public class Issue1254 extends TestCase {
    public void test_for_issue() throws Exception {
        A a = new A();
        a._parentId = "001";
        String test = JSON.toJSONString(a);
        System.out.println(test);
        assertEquals("{\"_parentId\":\"001\"}", test);

        B b = new B();
        b.set_parentId("001");


//        Object o = BeanUtils.getProperty(b,"_parentId");
//        System.out.println(o); //test ok, println 001
//
//        //BeanUtils.getProperty(b,"parentId"); //java.lang.NoSuchMethodException: Unknown property 'parentId' on class 'class com.alibaba.json.bvt.issue_1200.Issue1254$B'

        String testB = JSON.toJSONString(b);
        System.out.println(testB);
        assertEquals("{\"_parentId\":\"001\"}", testB);

    }

    public static class A {
        public String _parentId;
    }

    public static class B {
        private String _parentId;

        public String get_parentId() {
            return _parentId;
        }

        public void set_parentId(String _parentId) {
            this._parentId = _parentId;
        }
    }
}=======
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.json.bvt.bug.Bug_101_for_rongganlin_case2;
import junit.framework.TestCase;
import org.apache.commons.beanutils.BeanUtils;

import java.util.Map;

/**
 * Created by kimmking on 09/06/2017.
 */
public class Issue1254 extends TestCase {
    public void test_for_issue() throws Exception {
        A a = new A();
        a._parentId = "001";
        String test = JSON.toJSONString(a);
        System.out.println(test);
        assertEquals("{\"_parentId\":\"001\"}", test);

        B b = new B();
        b.set_parentId("001");


        String testB = JSON.toJSONString(b);
        System.out.println(testB);
        assertEquals("{\"_parentId\":\"001\"}", testB);

    }

    public static class A {
        public String _parentId;
    }

    public static class B {
        @JSONField(name = "_parentId")
        private String _parentId;

        public String get_parentId() {
            return _parentId;
        }

        public void set_parentId(String _parentId) {
            this._parentId = _parentId;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/test/java/com/alibaba/json/bvt/bug/Bug_for_luogongwu.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.fastjson.annotation.JSONType;
import com.alibaba.fastjson.parser.ParserConfig;
import com.alibaba.fastjson.serializer.SerializeConfig;
import com.alibaba.fastjson.serializer.SerializerFeature;
import junit.framework.TestCase;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by wenshao on 15/06/2017.
 */
public class Bug_for_luogongwu extends TestCase {

    public void test_for_issue() throws Exception {
        List<IflowItemImage> imageList = new ArrayList<IflowItemImage>();
        IflowItemImage image = new IflowItemImage();
        image.id = "72c7275c6b";
        imageList.add(image);

        imageList = new ArrayList();
        image = new IflowItemImage();
        image.id = "72c7275c6c";
        imageList.add(image);

        // force ASM
        boolean asm = SerializeConfig.globalInstance.isAsmEnable();
        SerializeConfig.globalInstance.setAsmEnable(true);

        // Test ASM
        Foo foo = new Foo();
        foo.thumbnails = imageList;

        String jsonString = JSON.toJSONString(foo);
        System.out.println(jsonString);

        Foo foo1 = JSON.parseObject(jsonString, Foo.class);

        assertEquals(1, foo1.thumbnails.size());
        assertNotNull(foo1.thumbnails.get(0));
        assertSame(foo1.getThumbnail(), foo1.thumbnails.get(0));


        // test Not ASM
        SerializeConfig.globalInstance.setAsmEnable(false);
        FooNotAsm fooNotAsm = new FooNotAsm();
        fooNotAsm.thumbnails = imageList;

        jsonString = JSON.toJSONString(foo);
        System.out.println(jsonString);

        FooNotAsm fooNotAsm1 = JSON.parseObject(jsonString, FooNotAsm.class);

        assertEquals(1, fooNotAsm1.thumbnails.size());
        assertNotNull(fooNotAsm1.thumbnails.get(0));
        assertSame(fooNotAsm1.getThumbnail(), fooNotAsm1.thumbnails.get(0));

        // restore
        SerializeConfig.globalInstance.setAsmEnable(asm);
    }

    @JSONType(asm=false)
    public static class FooNotAsm {
        @JSONField(serialzeFeatures = SerializerFeature.DisableCircularReferenceDetect)
        public List<IflowItemImage> thumbnails;

        public IflowItemImage getThumbnail() {
            return thumbnails != null && thumbnails.size() > 0 ? thumbnails.get(0) : null;
        }
    }

    public static class Foo {
        @JSONField(serialzeFeatures = SerializerFeature.DisableCircularReferenceDetect)
        public List<IflowItemImage> thumbnails;

        public IflowItemImage getThumbnail() {
            return thumbnails != null && thumbnails.size() > 0 ? thumbnails.get(0) : null;
        }
    }

    public static class IflowItemImage {
        public String id;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/test/java/com/alibaba/json/bvt/issue_1200/Issue1262.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by wenshao on 15/06/2017.
 */
public class Issue1262 extends TestCase {
    public void test_for_issue() throws Exception {
        Model model = JSON.parseObject("{\"chatterMap\":{}}", Model.class);
    }

    public static class Model {
        public Map<String, Chatter> chatterMap = new ConcurrentHashMap<String, Chatter>();
    }

    public static class Chatter {

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/test/java/com/alibaba/json/bvt/issue_1200/Issue1276.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;

/**
 * Created by wenshao on 18/06/2017.
 */
public class Issue1276 extends TestCase {
    public void test_for_issue() throws Exception {
        MyException myException = new MyException(100,"error msg");
        String str = JSON.toJSONString(myException);
        System.out.println(str);

        MyException myException1 = JSON.parseObject(str, MyException.class);
        assertEquals(myException.getCode(), myException1.getCode());

        String str1 = JSON.toJSONString(myException1);
        assertEquals(str, str1);

    }

    public static class MyException extends RuntimeException{
        private static final long serialVersionUID = 7815426752583648734L;
        private long code;

        public MyException() {
            super();
        }

        public MyException(String message, Throwable cause) {
            super(message, cause);
        }

        public MyException(String message) {
            super(message);
        }

        public MyException(Throwable cause) {
            super(cause);
        }

        public MyException(long code) {
            super();
            this.code = code;
        }

        public MyException(long code, String message, Throwable cause) {
            super(message, cause);
            this.code = code;
        }

        public MyException(long code, String message) {
            super(message);
            this.code = code;
        }

        public MyException(long code, Throwable cause) {
            super(cause);
            this.code = code;
        }

        public void setCode(long code) {
            this.code = code;
        }

        public long getCode() {
            return code;
        }

        @Override
        public String toString() {
            return "MyException{" +
                    "code=" + code +
                    '}';
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_e68ed42_ae7aedd/rev_e68ed42-ae7aedd/hystrix-core/src/jmh/java/com/netflix/hystrix/perf/RollingMaxPerfTest.java;<<<<<<< MINE
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingMaxPerfTest {
    @State(Scope.Thread)
    public static class CounterState {
        HystrixRollingNumber counter;

        @Setup(Level.Iteration)
        public void setUp() {
            counter = new HystrixRollingNumber(
                    HystrixProperty.Factory.asProperty(100),
                    HystrixProperty.Factory.asProperty(10));
        }
    }

    @State(Scope.Thread)
    public static class ValueState {
        final Random r = new Random();

        int value;

        @Setup(Level.Invocation)
        public void setUp() {
            value = r.nextInt(100);
        }
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readOnly(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeHeavyUpdateMax(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long writeHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber evenSplitUpdateMax(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long evenSplitReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber readHeavyUpdateMax(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }
}=======
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingMaxPerfTest {
	@State(Scope.Thread)
	public static class CounterState {
		HystrixRollingNumber counter;

		@Setup(Level.Iteration)
		public void setUp() {
			counter = new HystrixRollingNumber(
					HystrixProperty.Factory.asProperty(100),
					HystrixProperty.Factory.asProperty(10));
		}
	}

	@State(Scope.Thread)
	public static class ValueState {
		final Random r = new Random();

		int value;

		@Setup(Level.Invocation)
		public void setUp() {
			value = r.nextInt(100);
		}
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readOnly(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeHeavyUpdateMax(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long writeHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber evenSplitUpdateMax(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long evenSplitReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber readHeavyUpdateMax(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_e68ed42_ae7aedd/rev_e68ed42-ae7aedd/hystrix-core/src/jmh/java/com/netflix/hystrix/perf/RollingNumberPerfTest.java;<<<<<<< MINE
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingNumberPerfTest {
    @State(Scope.Thread)
    public static class CounterState {
        HystrixRollingNumber counter;

        @Setup(Level.Iteration)
        public void setUp() {
            counter = new HystrixRollingNumber(
                    HystrixProperty.Factory.asProperty(100),
                    HystrixProperty.Factory.asProperty(10));
        }
    }

    @State(Scope.Thread)
    public static class ValueState {
        final Random r = new Random();

        int value;
        HystrixRollingNumberEvent type;

        @Setup(Level.Invocation)
        public void setUp() {
            value = r.nextInt(100);
            int typeInt = r.nextInt(3);
            switch(typeInt) {
                case 0:
                    type = HystrixRollingNumberEvent.SUCCESS;
                    break;
                case 1:
                    type = HystrixRollingNumberEvent.FAILURE;
                    break;
                case 2:
                    type = HystrixRollingNumberEvent.TIMEOUT;
                    break;
                default: throw new RuntimeException("Unexpected : " + typeInt);
            }
        }
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readOnly(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeHeavyCounterAdd(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long writeHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber evenSplitCounterAdd(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long evenSplitReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber readHeavyCounterAdd(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }
}=======
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingNumberPerfTest {
	@State(Scope.Thread)
	public static class CounterState {
		HystrixRollingNumber counter;

		@Setup(Level.Iteration)
		public void setUp() {
			counter = new HystrixRollingNumber(
					HystrixProperty.Factory.asProperty(100),
					HystrixProperty.Factory.asProperty(10));
		}
	}

	@State(Scope.Thread)
	public static class ValueState {
		final Random r = new Random();

		int value;
		HystrixRollingNumberEvent type;

		@Setup(Level.Invocation)
		public void setUp() {
			value = r.nextInt(100);
			int typeInt = r.nextInt(3);
			switch(typeInt) {
				case 0:
					type = HystrixRollingNumberEvent.SUCCESS;
					break;
				case 1:
					type = HystrixRollingNumberEvent.FAILURE;
					break;
				case 2:
					type = HystrixRollingNumberEvent.TIMEOUT;
					break;
				default: throw new RuntimeException("Unexpected : " + typeInt);
			}
		}
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readOnly(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeHeavyCounterAdd(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long writeHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber evenSplitCounterAdd(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long evenSplitReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber readHeavyCounterAdd(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1341.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1300;


import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONPObject;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.support.config.FastJsonConfig;
import com.alibaba.fastjson.support.jaxrs.FastJsonProvider;
import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.internal.InternalProperties;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.server.JSONP;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;
import org.junit.Assert;
import org.junit.Test;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Feature;
import javax.ws.rs.core.FeatureContext;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.MessageBodyWriter;
import java.util.Date;

import static org.junit.Assert.assertTrue;

public class Issue1341 extends JerseyTest {
    static class Book {

        private int bookId;
        private String bookName;
        private String publisher;
        private String isbn;
        private Date publishTime;
        private Object hello;

        public int getBookId() {
            return bookId;
        }

        public void setBookId(int bookId) {
            this.bookId = bookId;
        }

        public String getBookName() {
            return bookName;
        }

        public void setBookName(String bookName) {
            this.bookName = bookName;
        }

        public String getPublisher() {
            return publisher;
        }

        public void setPublisher(String publisher) {
            this.publisher = publisher;
        }

        public String getIsbn() {
            return isbn;
        }

        public void setIsbn(String isbn) {
            this.isbn = isbn;
        }

        public Date getPublishTime() {
            return publishTime;
        }

        public void setPublishTime(Date publishTime) {
            this.publishTime = publishTime;
        }

        public Object getHello() {
            return hello;
        }

        public void setHello(Object hello) {
            this.hello = hello;
        }
    }

    static class FastJsonFeature implements Feature {

        private final static String JSON_FEATURE = FastJsonFeature.class.getSimpleName();

        public boolean configure(final FeatureContext context) {
            final Configuration config = context.getConfiguration();
            final String jsonFeature = CommonProperties.getValue(config.getProperties(), config.getRuntimeType(), InternalProperties.JSON_FEATURE, JSON_FEATURE,
                    String.class);
            // Other JSON providers registered.
            if (!JSON_FEATURE.equalsIgnoreCase(jsonFeature)) {
                return false;
            }
            // Disable other JSON providers.
            context.property(PropertiesHelper.getPropertyNameForRuntime(InternalProperties.JSON_FEATURE, config.getRuntimeType()), JSON_FEATURE);
            // Register FastJson.
            if (!config.isRegistered(FastJsonProvider.class)) {
                //DisableCircularReferenceDetect
                FastJsonProvider fastJsonProvider = new FastJsonProvider();
                FastJsonConfig fastJsonConfig = new FastJsonConfig();
                //fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect,SerializerFeature.BrowserSecure);

                fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect);

                fastJsonProvider.setFastJsonConfig(fastJsonConfig);

                context.register(fastJsonProvider, MessageBodyReader.class, MessageBodyWriter.class);
            }
            return true;
        }
    }


    @Path("book")
    public static class BookRestFul {

        @GET
        @Path("{id}")
        @Produces({"application/javascript", "application/json"})
        @JSONP(queryParam = "callback")
        public Book getBookById(@PathParam("id") Long id) {

            Book book = new Book();
            book.setBookId(2);
            book.setBookName("Python");
            book.setPublisher("");
            book.setPublishTime(new Date());
            book.setIsbn("911122");

            return book;
        }
    }

    @Override
    protected void configureClient(ClientConfig config) {
        config.register(new FastJsonFeature()).register(FastJsonProvider.class);
    }

    @Override
    protected Application configure() {
        enable(TestProperties.LOG_TRAFFIC);
        enable(TestProperties.DUMP_ENTITY);

        ResourceConfig config = new ResourceConfig();

        config.register(new FastJsonFeature()).register(FastJsonProvider.class);
        config.packages("com.alibaba.json");
        return config;
    }

    @Test
    public void test() {

        final String reponse = target("book").path("123").request().accept("application/javascript").get(String.class);

        Assert.assertTrue(reponse.indexOf("Python") > 0);
        Assert.assertTrue(reponse.indexOf("") > 0);
        Assert.assertTrue(reponse.indexOf("\"hello\":null") > 0);
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1367.java;<<<<<<< MINE
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
import com.alibaba.fastjson.support.spring.FastJsonpHttpMessageConverter4;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;

import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import java.io.Serializable;
import java.util.List;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Created by songlingdong on 8/5/17.
 */
@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration
public class Issue1367 {

    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac) //
                .addFilter(new CharacterEncodingFilter("UTF-8", true)) // UTF-8
                .build();
    }





    public static class AbstractController<ID extends Serializable, PO extends GenericEntity<ID>> {

        @PostMapping(path = "/typeVariableBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public PO save(@RequestBody PO dto) {
            //do something
            return dto;
        }

    }

    @RestController
    @RequestMapping()
    public static class BeanController extends AbstractController<Long, TypeVariableBean> {



        @PostMapping(path = "/parameterizedTypeBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public String parameterizedTypeBean(@RequestBody ParameterizedTypeBean<String> parameterizedTypeBean){
            return parameterizedTypeBean.t;
        }


    }


    @ComponentScan(basePackages = "com.alibaba.json.bvt.issue_1300")
    @Configuration
    @Order(Ordered.LOWEST_PRECEDENCE + 1)
    @EnableWebMvc
    public static class WebMvcConfig extends WebMvcConfigurerAdapter {
        @Override
        public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
            FastJsonpHttpMessageConverter4 converter = new FastJsonpHttpMessageConverter4();
            converters.add(converter);
        }


    }


    @Test
    public void testParameterizedTypeBean() throws Exception {
        mockMvc.perform(
                (post("/parameterizedTypeBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"t\": \"neil dong\"}")
                        )).andExpect(status().isOk()).andDo(print());
    }

    @Test
    public void testTypeVariableBean() throws Exception {
        mockMvc.perform(
                (post("/typeVariableBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"id\": 1}")
                        )).andExpect(status().isOk()).andDo(print());

    }





    static abstract class GenericEntity<ID extends Serializable> {
        public abstract ID getId();
    }

    static class TypeVariableBean extends GenericEntity<Long> {
        private Long id;

        @Override
        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }
    }

    static class ParameterizedTypeBean<T> {
        private T t;

        public T getT() {
            return t;
        }

        public void setT(T t) {
            this.t = t;
        }



    }
}=======
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
import com.alibaba.fastjson.support.spring.FastJsonpHttpMessageConverter4;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import java.io.Serializable;
import java.util.List;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Created by songlingdong on 8/5/17.
 */
@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration
public class Issue1367 {

    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac) //
                .addFilter(new CharacterEncodingFilter("UTF-8", true)) // UTF-8
                .build();
    }





    public static class AbstractController<ID extends Serializable, PO extends GenericEntity<ID>> {

        @PostMapping(path = "/typeVariableBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public PO save(@RequestBody PO dto) {
            //do something
            return dto;
        }

    }

    @RestController
    @RequestMapping()
    public static class BeanController extends AbstractController<Long, TypeVariableBean> {



        @PostMapping(path = "/parameterizedTypeBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public String parameterizedTypeBean(@RequestBody ParameterizedTypeBean<String> parameterizedTypeBean){
            return parameterizedTypeBean.t;
        }


    }


    @ComponentScan(basePackages = "com.alibaba.json.bvt.issue_1300")
    @Configuration
    @Order(Ordered.LOWEST_PRECEDENCE + 1)
    @EnableWebMvc
    public static class WebMvcConfig extends WebMvcConfigurerAdapter {
        @Override
        public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
            FastJsonpHttpMessageConverter4 converter = new FastJsonpHttpMessageConverter4();
            converters.add(converter);
        }


    }


    @Test
    public void testParameterizedTypeBean() throws Exception {
        mockMvc.perform(
                (post("/parameterizedTypeBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"t\": \"neil dong\"}")
                        )).andExpect(status().isOk()).andDo(print());
    }

    @Test
    public void testTypeVariableBean() throws Exception {
        mockMvc.perform(
                (post("/typeVariableBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"id\": 1}")
                        )).andExpect(status().isOk()).andDo(print());

    }





    static abstract class GenericEntity<ID extends Serializable> {
        public abstract ID getId();
    }

    static class TypeVariableBean extends GenericEntity<Long> {
        private Long id;

        @Override
        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }
    }

    static class ParameterizedTypeBean<T> {
        private T t;

        public T getT() {
            return t;
        }

        public void setT(T t) {
            this.t = t;
        }



    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_75cc1dc_f28a067/rev_75cc1dc-f28a067/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1369.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;
import org.junit.Assert;

/**
 * Created by kimmking on 03/08/2017.
 */
public class Issue1369 extends TestCase {
    public void test_for_issue() throws Exception {
        Foo foo = new Foo();
        foo.a = 1;
        foo.b = "b";
        foo.bars = new Bar();
        foo.bars.c = 3;
        String json = JSON.toJSONString(foo);
        System.out.println(json);
        Assert.assertTrue(json.indexOf("\\")<0);
    }

    public static class Foo {
        public int a;
        public String b;
        public Bar bars;
    }
    public static class Bar {
        public int c;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_75cc1dc_f28a067/rev_75cc1dc-f28a067/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1368.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;
import org.junit.Assert;
import org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder;

/**
 * Created by kimmking on 03/08/2017.
 */
public class Issue1368 extends TestCase {
    public void test_for_issue() throws Exception {
        ExtendedServletRequestDataBinder binder = new ExtendedServletRequestDataBinder(new Object());
        String json = JSON.toJSONString(binder);
        System.out.println(json);
        Assert.assertTrue(json.indexOf("$ref")>=0);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/testing/MemoryBackingMap.java;<<<<<<< MINE
=======
package storm.trident.testing;

import storm.trident.state.map.IBackingMap;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MemoryBackingMap implements IBackingMap<Object> {
    Map _vals = new HashMap();

    @Override
    public List<Object> multiGet(List<List<Object>> keys) {
        List ret = new ArrayList();
        for(List key: keys) {
            ret.add(_vals.get(key));
        }
        return ret;
    }

    @Override
    public void multiPut(List<List<Object>> keys, List<Object> vals) {
        for(int i=0; i<keys.size(); i++) {
            List key = keys.get(i);
            Object val = vals.get(i);
            _vals.put(key, val);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
public class CachedBatchReadsMap<T> implements MapState<T> {
=======

public class CachedBatchReadsMap<T> {
    public static class RetVal<T> {
        public boolean cached;
        public T val;

        public RetVal(T v, boolean c) {
            val = v;
            cached = c;
        }
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_8e69347_af2c793/rev_8e69347-af2c793/src/jvm/backtype/storm/utils/NimbusClient.java;<<<<<<< MINE
public class NimbusClient extends ThriftClient {	
=======
public class NimbusClient extends ThriftClient {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_dea4c8b_d12c335/rev_dea4c8b-d12c335/src/jvm/storm/trident/topology/state/RotatingTransactionalState.java;<<<<<<< MINE
=======
package storm.trident.topology.state;

import backtype.storm.utils.Utils;
import org.apache.zookeeper.KeeperException;

import java.util.HashSet;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;

public class RotatingTransactionalState {
    public static interface StateInitializer {
        Object init(long txid, Object lastState);
    }    

    private TransactionalState _state;
    private String _subdir;
    
    private TreeMap<Long, Object> _curr = new TreeMap<Long, Object>();
    
    public RotatingTransactionalState(TransactionalState state, String subdir) {
        _state = state;
        _subdir = subdir;
        state.mkdir(subdir);
        sync();
    }


    public Object getLastState() {
        if(_curr.isEmpty()) return null;
        else return _curr.lastEntry().getValue();
    }
    
    public void overrideState(long txid, Object state) {
        _state.setData(txPath(txid), state);
        _curr.put(txid, state);
    }

    public void removeState(long txid) {
        if(_curr.containsKey(txid)) {
            _curr.remove(txid);
            _state.delete(txPath(txid));
        }
    }
    
    public Object getState(long txid) {
        return _curr.get(txid);
    }
    
    public Object getState(long txid, StateInitializer init) {
        if(!_curr.containsKey(txid)) {
            SortedMap<Long, Object> prevMap = _curr.headMap(txid);
            SortedMap<Long, Object> afterMap = _curr.tailMap(txid);            
            
            Long prev = null;
            if(!prevMap.isEmpty()) prev = prevMap.lastKey();            
            
            Object data;
            if(afterMap.isEmpty()) {
                Object prevData;
                if(prev!=null) {
                    prevData = _curr.get(prev);
                } else {
                    prevData = null;
                }
                data = init.init(txid, prevData);
            } else {
                data = null;
            }
            _curr.put(txid, data);
            _state.setData(txPath(txid), data);
        }
        return _curr.get(txid);
    }
    
    public Object getPreviousState(long txid) {
        SortedMap<Long, Object> prevMap = _curr.headMap(txid);
        if(prevMap.isEmpty()) return null;
        else return prevMap.get(prevMap.lastKey());
    }
    
    public boolean hasCache(long txid) {
        return _curr.containsKey(txid);
    }
       
    /**
     * Returns null if it was created, the value otherwise.
     */
    public Object getStateOrCreate(long txid, StateInitializer init) {
        if(_curr.containsKey(txid)) {
            return _curr.get(txid);
        } else {
            getState(txid, init);
            return null;
        }
    }
    
    public void cleanupBefore(long txid) {
        SortedMap<Long, Object> toDelete = _curr.headMap(txid);
        for(long tx: new HashSet<Long>(toDelete.keySet())) {
            _curr.remove(tx);
            try {
                _state.delete(txPath(tx));
            } catch(RuntimeException e) {
                // Ignore NoNodeExists exceptions because when sync() it may populate _curr with stale data since
                // zookeeper reads are eventually consistent.
                if(!Utils.exceptionCauseIsInstanceOf(KeeperException.NoNodeException.class, e)) {
                    throw e;
                }
            }
        }
    }
    
    private void sync() {
        List<String> txids = _state.list(_subdir);
        for(String txid_s: txids) {
            Object data = _state.getData(txPath(txid_s));
            _curr.put(Long.parseLong(txid_s), data);
        }
    }
    
    private String txPath(long tx) {
        return txPath("" + tx);
    }

    private String txPath(String tx) {
        return _subdir + "/" + tx;
    }    
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_dea4c8b_d12c335/rev_dea4c8b-d12c335/src/jvm/backtype/storm/utils/Utils.java;<<<<<<< MINE
=======
package backtype.storm.utils;

import backtype.storm.Config;
import backtype.storm.generated.ComponentCommon;
import backtype.storm.generated.ComponentObject;
import backtype.storm.generated.StormTopology;
import clojure.lang.IFn;
import clojure.lang.RT;
import com.netflix.curator.framework.CuratorFramework;
import com.netflix.curator.framework.CuratorFrameworkFactory;
import com.netflix.curator.retry.RetryNTimes;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.WritableByteChannel;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;
import org.apache.commons.lang.StringUtils;
import org.apache.thrift7.TException;
import org.json.simple.JSONValue;
import org.yaml.snakeyaml.Yaml;

public class Utils {
    public static final String DEFAULT_STREAM_ID = "default";

    public static Object newInstance(String klass) {
        try {
            Class c = Class.forName(klass);
            return c.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    public static byte[] serialize(Object obj) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(obj);
            oos.close();
            return bos.toByteArray();
        } catch(IOException ioe) {
            throw new RuntimeException(ioe);
        }
    }

    public static Object deserialize(byte[] serialized) {
        try {
            ByteArrayInputStream bis = new ByteArrayInputStream(serialized);
            ObjectInputStream ois = new ObjectInputStream(bis);
            Object ret = ois.readObject();
            ois.close();
            return ret;
        } catch(IOException ioe) {
            throw new RuntimeException(ioe);
        } catch(ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    public static <T> String join(Iterable<T> coll, String sep) {
        Iterator<T> it = coll.iterator();
        String ret = "";
        while(it.hasNext()) {
            ret = ret + it.next();
            if(it.hasNext()) {
                ret = ret + sep;
            }
        }
        return ret;
    }

    public static void sleep(long millis) {
        try {
            Time.sleep(millis);
        } catch(InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    
    public static List<URL> findResources(String name) {
        try {
            Enumeration<URL> resources = Thread.currentThread().getContextClassLoader().getResources(name);
            List<URL> ret = new ArrayList<URL>();
            while(resources.hasMoreElements()) {
                ret.add(resources.nextElement());
            }
            return ret;
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map findAndReadConfigFile(String name, boolean mustExist) {
        try {
            List<URL> resources = findResources(name);
            if(resources.isEmpty()) {
                if(mustExist) throw new RuntimeException("Could not find config file on classpath " + name);
                else return new HashMap();
            }
            if(resources.size() > 1) {
                throw new RuntimeException("Found multiple " + name + " resources. You're probably bundling the Storm jars with your topology jar.");
            }
            URL resource = resources.get(0);
            Yaml yaml = new Yaml();
            Map ret = (Map) yaml.load(new InputStreamReader(resource.openStream()));
            if(ret==null) ret = new HashMap();
            

            return new HashMap(ret);
            
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map findAndReadConfigFile(String name) {
       return findAndReadConfigFile(name, true);
    }

    public static Map readDefaultConfig() {
        return findAndReadConfigFile("defaults.yaml", true);
    }
    
    public static Map readCommandLineOpts() {
        Map ret = new HashMap();
        String commandOptions = System.getProperty("storm.options");
        if(commandOptions != null) {
            commandOptions = commandOptions.replaceAll("%%%%", " ");
            String[] configs = commandOptions.split(",");
            for (String config : configs) {
                String[] options = config.split("=");
                if (options.length == 2) {
                    ret.put(options[0], options[1]);
                }
            }
        }
        return ret;
    }

    public static Map readStormConfig() {
        Map ret = readDefaultConfig();
        String confFile = System.getProperty("storm.conf.file");
        Map storm;
        if (confFile==null || confFile.equals("")) {
            storm = findAndReadConfigFile("storm.yaml", false);
        } else {
            storm = findAndReadConfigFile(confFile, true);
        }
        ret.putAll(storm);
        ret.putAll(readCommandLineOpts());
        return ret;
    }
    
    private static Object normalizeConf(Object conf) {
        if(conf==null) return new HashMap();
        if(conf instanceof Map) {
            Map confMap = new HashMap((Map) conf);
            for(Object key: confMap.keySet()) {
                Object val = confMap.get(key);
                confMap.put(key, normalizeConf(val));
            }
            return confMap;
        } else if(conf instanceof List) {
            List confList =  new ArrayList((List) conf);
            for(int i=0; i<confList.size(); i++) {
                Object val = confList.get(i);
                confList.set(i, normalizeConf(val));
            }
            return confList;
        } else if (conf instanceof Integer) {
            return ((Integer) conf).longValue();
        } else if(conf instanceof Float) {
            return ((Float) conf).doubleValue();
        } else {
            return conf;
        }
    }
    
    public static boolean isValidConf(Map<String, Object> stormConf) {
        return normalizeConf(stormConf).equals(normalizeConf((Map) JSONValue.parse(JSONValue.toJSONString(stormConf))));
    }

    public static Object getSetComponentObject(ComponentObject obj) {
        if(obj.getSetField()==ComponentObject._Fields.SERIALIZED_JAVA) {
            return Utils.deserialize(obj.get_serialized_java());
        } else if(obj.getSetField()==ComponentObject._Fields.JAVA_OBJECT) {
            return obj.get_java_object();
        } else {
            return obj.get_shell();
        }
    }

    public static <S, T> T get(Map<S, T> m, S key, T def) {
        T ret = m.get(key);
        if(ret==null) {
            ret = def;
        }
        return ret;
    }
    
    public static List<Object> tuple(Object... values) {
        List<Object> ret = new ArrayList<Object>();
        for(Object v: values) {
            ret.add(v);
        }
        return ret;
    }

    public static void downloadFromMaster(Map conf, String file, String localFile) throws IOException, TException {
        NimbusClient client = NimbusClient.getConfiguredClient(conf);
        String id = client.getClient().beginFileDownload(file);
        WritableByteChannel out = Channels.newChannel(new FileOutputStream(localFile));
        while(true) {
            ByteBuffer chunk = client.getClient().downloadChunk(id);
            int written = out.write(chunk);
            if(written==0) break;
        }
        out.close();
    }
    
    public static IFn loadClojureFn(String namespace, String name) {
        try {
          clojure.lang.Compiler.eval(RT.readString("(require '" + namespace + ")"));
        } catch (Exception e) {
          //if playing from the repl and defining functions, file won't exist
        }
        return (IFn) RT.var(namespace, name).deref();        
    }
    
    public static boolean isSystemId(String id) {
        return id.startsWith("__");
    }
        
    public static <K, V> Map<V, K> reverseMap(Map<K, V> map) {
        Map<V, K> ret = new HashMap<V, K>();
        for(K key: map.keySet()) {
            ret.put(map.get(key), key);
        }
        return ret;
    }
    
    public static ComponentCommon getComponentCommon(StormTopology topology, String id) {
        if(topology.get_spouts().containsKey(id)) {
            return topology.get_spouts().get(id).get_common();
        }
        if(topology.get_bolts().containsKey(id)) {
            return topology.get_bolts().get(id).get_common();
        }
        if(topology.get_state_spouts().containsKey(id)) {
            return topology.get_state_spouts().get(id).get_common();
        }
        throw new IllegalArgumentException("Could not find component with id " + id);
    }
    
    public static Integer getInt(Object o) {
        if(o instanceof Long) {
            return ((Long) o ).intValue();
        } else if (o instanceof Integer) {
            return (Integer) o;
        } else if (o instanceof Short) {
            return ((Short) o).intValue();
        } else {
            throw new IllegalArgumentException("Don't know how to convert " + o + " + to int");
        }
    }
    
    public static long secureRandomLong() {
        return UUID.randomUUID().getLeastSignificantBits();
    }
    
    
    public static CuratorFramework newCurator(Map conf, List<String> servers, Object port, String root) {
        return newCurator(conf, servers, port, root, null);
    }
    
    public static CuratorFramework newCurator(Map conf, List<String> servers, Object port, String root, ZookeeperAuthInfo auth) {
        List<String> serverPorts = new ArrayList<String>();
        for(String zkServer: (List<String>) servers) {
            serverPorts.add(zkServer + ":" + Utils.getInt(port));
        }
        String zkStr = StringUtils.join(serverPorts, ",") + root; 
        try {
            
            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()
                    .connectString(zkStr)
                    .connectionTimeoutMs(Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_CONNECTION_TIMEOUT)))
                    .sessionTimeoutMs(Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_SESSION_TIMEOUT)))
                    .retryPolicy(new RetryNTimes(Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_RETRY_TIMES)), Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_RETRY_INTERVAL))));
            if(auth!=null && auth.scheme!=null) {
                builder = builder.authorization(auth.scheme, auth.payload);
            }            
            return builder.build();
        } catch (IOException e) {
           throw new RuntimeException(e);
        }
    }

    public static CuratorFramework newCurator(Map conf, List<String> servers, Object port) {
        return newCurator(conf, servers, port, "");
    }

    public static CuratorFramework newCuratorStarted(Map conf, List<String> servers, Object port, String root) {
        CuratorFramework ret = newCurator(conf, servers, port, root);
        ret.start();
        return ret;
    }

    public static CuratorFramework newCuratorStarted(Map conf, List<String> servers, Object port) {
        CuratorFramework ret = newCurator(conf, servers, port);
        ret.start();
        return ret;
    }    
    
    /**
     *
(defn integer-divided [sum num-pieces]
  (let [base (int (/ sum num-pieces))
        num-inc (mod sum num-pieces)
        num-bases (- num-pieces num-inc)]
    (if (= num-inc 0)
      {base num-bases}
      {base num-bases (inc base) num-inc}
      )))
     * @param sum
     * @param numPieces
     * @return 
     */
    
    public static TreeMap<Integer, Integer> integerDivided(int sum, int numPieces) {
        int base = sum / numPieces;
        int numInc = sum % numPieces;
        int numBases = numPieces - numInc;
        TreeMap<Integer, Integer> ret = new TreeMap<Integer, Integer>();
        ret.put(base, numBases);
        if(numInc!=0) {
            ret.put(base+1, numInc);
        }
        return ret;
    }

    public static byte[] toByteArray(ByteBuffer buffer) {
        byte[] ret = new byte[buffer.remaining()];
        buffer.get(ret, 0, ret.length);
        return ret;
    }

    public static boolean exceptionCauseIsInstanceOf(Class klass, Throwable throwable) {
        Throwable t = throwable;
        while(t != null) {
            if(klass.isInstance(t)) {
                return true;
            }
            t = t.getCause();
        }
        return false;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_dea4c8b_d12c335/rev_dea4c8b-d12c335/src/jvm/backtype/storm/metric/SystemBolt.java;<<<<<<< MINE
=======
package backtype.storm.metric;

import backtype.storm.Config;
import backtype.storm.metric.api.AssignableMetric;
import backtype.storm.metric.api.IMetric;
import backtype.storm.task.IBolt;
import backtype.storm.task.OutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.tuple.Tuple;
import clojure.lang.AFn;
import clojure.lang.IFn;
import clojure.lang.RT;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.management.*;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


// There is one task inside one executor for each worker of the topology.
// TaskID is always -1, therefore you can only send-unanchored tuples to co-located SystemBolt.
// This bolt was conceived to export worker stats via metrics api.
public class SystemBolt implements IBolt {
    private static Logger LOG = LoggerFactory.getLogger(SystemBolt.class);
    private static boolean _prepareWasCalled = false;

    private static class MemoryUsageMetric implements IMetric {
        IFn _getUsage;
        public MemoryUsageMetric(IFn getUsage) {
            _getUsage = getUsage;
        }
        @Override
        public Object getValueAndReset() {
            MemoryUsage memUsage = (MemoryUsage)_getUsage.invoke();
            HashMap m = new HashMap();
            m.put("maxBytes", memUsage.getMax());
            m.put("committedBytes", memUsage.getCommitted());
            m.put("initBytes", memUsage.getInit());
            m.put("usedBytes", memUsage.getUsed());
            m.put("virtualFreeBytes", memUsage.getMax() - memUsage.getUsed());
            m.put("unusedBytes", memUsage.getCommitted() - memUsage.getUsed());
            return m;
        }
    }

    // canonically the metrics data exported is time bucketed when doing counts.
    // convert the absolute values here into time buckets.
    private static class GarbageCollectorMetric implements IMetric {
        GarbageCollectorMXBean _gcBean;
        Long _collectionCount;
        Long _collectionTime;
        public GarbageCollectorMetric(GarbageCollectorMXBean gcBean) {
            _gcBean = gcBean;
        }
        @Override
        public Object getValueAndReset() {
            Long collectionCountP = _gcBean.getCollectionCount();
            Long collectionTimeP = _gcBean.getCollectionCount();

            Map ret = null;
            if(_collectionCount!=null && _collectionTime!=null) {
                ret = new HashMap();
                ret.put("count", collectionCountP - _collectionCount);
                ret.put("timeMs", collectionTimeP - _collectionTime);
            }

            _collectionCount = collectionCountP;
            _collectionTime = collectionTimeP;
            return ret;
        }
    }

    @Override
    public void prepare(final Map stormConf, TopologyContext context, OutputCollector collector) {
        if(_prepareWasCalled && stormConf.get(Config.STORM_CLUSTER_MODE) != "local") {
            throw new RuntimeException("A single worker should have 1 SystemBolt instance.");
        }
        _prepareWasCalled = true;

        int bucketSize = RT.intCast(stormConf.get(Config.TOPOLOGY_BUILTIN_METRICS_BUCKET_SIZE_SECS));

        final RuntimeMXBean jvmRT = ManagementFactory.getRuntimeMXBean();

        context.registerMetric("uptimeSecs", new IMetric() {
            @Override
            public Object getValueAndReset() {
                return jvmRT.getUptime()/1000.0;
            }
        }, bucketSize);

        context.registerMetric("startTimeSecs", new IMetric() {
            @Override
            public Object getValueAndReset() {
                return jvmRT.getStartTime()/1000.0;
            }
        }, bucketSize);

        context.registerMetric("newWorkerEvent", new IMetric() {
            boolean doEvent = true;

            @Override
            public Object getValueAndReset() {
                if (doEvent) {
                    doEvent = false;
                    return 1;
                } else return 0;
            }
        }, bucketSize);

        final MemoryMXBean jvmMemRT = ManagementFactory.getMemoryMXBean();

        context.registerMetric("memory/heap", new MemoryUsageMetric(new AFn() {
            public Object invoke() {
                return jvmMemRT.getHeapMemoryUsage();
            }
        }), bucketSize);
        context.registerMetric("memory/nonHeap", new MemoryUsageMetric(new AFn() {
            public Object invoke() {
                return jvmMemRT.getNonHeapMemoryUsage();
            }
        }), bucketSize);

        for(GarbageCollectorMXBean b : ManagementFactory.getGarbageCollectorMXBeans()) {
            context.registerMetric("GC/" + b.getName().replaceAll("\\W", ""), new GarbageCollectorMetric(b), bucketSize);
        }
    }

    @Override
    public void execute(Tuple input) {
        throw new RuntimeException("Non-system tuples should never be sent to __system bolt.");
    }

    @Override
    public void cleanup() {
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/main/java/io/vertx/core/spi/cluster/AsyncMap.java;<<<<<<< MINE
/*
 * Copyright (c) 2011-2013 The original author or authors
 * ------------------------------------------------------
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Apache License v2.0 which accompanies this distribution.
 *
 *     The Eclipse Public License is available at
 *     http://www.eclipse.org/legal/epl-v10.html
 *
 *     The Apache License v2.0 is available at
 *     http://www.opensource.org/licenses/apache2.0.php
 *
 * You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.spi.cluster;

import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;


/**
 *
 * An asynchronous map.
 *
 * The cluster implementation should ensure that any entries placed in the map from any node are available on any
 * node of the cluster.
 *
 * @author <a href="http://tfox.org">Tim Fox</a>
 *
 */
public interface AsyncMap<K, V> {

  /**
   * Get a value from the map, asynchronously.
   * @param k The key
   * @param resultHandler - this will be called some time later with the async result.
   */
  void get(K k, Handler<AsyncResult<V>> resultHandler);

  /**
   * Put a value in the map, asynchronously.
   * @param k The key
   * @param v The value
   * @param completionHandler - this will be called some time later to signify the value has been put
   */
  void put(K k, V v, Handler<AsyncResult<Void>> completionHandler);

  /**
   * Remove a value from the map, asynchronously.
   * @param k The key
   * @param resultHandler - this will be called some time later to signify the value has been removed
   */
  void remove(K k, Handler<AsyncResult<Void>> resultHandler);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/test/java/io/vertx/test/core/SharedDataTest.java;<<<<<<< MINE
/*
 * Copyright 2014 Red Hat, Inc.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Apache License v2.0 which accompanies this distribution.
 *
 * The Eclipse Public License is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * The Apache License v2.0 is available at
 * http://www.opensource.org/licenses/apache2.0.php
 *
 * You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.test.core;

import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.shareddata.SharedData;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Map;
import java.util.Random;
import java.util.Set;

import static org.junit.Assert.*;

/**
 * @author <a href="http://tfox.org">Tim Fox</a>
 */
public class SharedDataTest {

  private Vertx vertx;
  private SharedData sharedData;

  @Before
  public void setUp() {
    vertx = Vertx.vertx();
    sharedData = vertx.sharedData();
  }

  @After
  public void teardown() {
    vertx.close();
  }

  @Test
  public void testMap() throws Exception {

    Map<String, String> map = sharedData.getMap("foo");
    Map<String, String> map2 = sharedData.getMap("foo");
    assertTrue(map == map2);
    Map<String, String> map3 = sharedData.getMap("bar");
    assertFalse(map3 == map2);
    assertTrue(sharedData.removeMap("foo"));
    Map<String, String> map4 = sharedData.getMap("foo");
    assertFalse(map4 == map3);
  }

  @Test
  public void testMapTypes() throws Exception {

    Map<String, Object> map = sharedData.getMap("foo");

    String key = "key";

    double d = new Random().nextDouble();
    map.put(key, d);
    assertEquals(d, map.get(key));

    float f = new Random().nextFloat();
    map.put(key, f);
    assertEquals(f, map.get(key));

    byte b = (byte)new Random().nextInt();
    map.put(key, b);
    assertEquals(b, map.get(key));

    short s = (short)new Random().nextInt();
    map.put(key, s);
    assertEquals(s, map.get(key));

    int i = new Random().nextInt();
    map.put(key, i);
    assertEquals(i, map.get(key));

    long l = new Random().nextLong();
    map.put(key, l);
    assertEquals(l, map.get(key));

    map.put(key, true);
    assertTrue((Boolean)map.get(key));

    map.put(key, false);
    assertFalse((Boolean) map.get(key));

    char c = (char)new Random().nextLong();
    map.put(key, c);
    assertEquals(c, map.get(key));

    Buffer buff = TestUtils.randomBuffer(100);
    map.put(key, buff);
    Buffer got1 = (Buffer)map.get(key);
    assertTrue(got1 != buff); // Make sure it's copied
    assertEquals(buff, map.get(key));
    Buffer got2 = (Buffer)map.get(key);
    assertTrue(got1 != got2); // Should be copied each time
    assertTrue(got2 != buff);
    assertEquals(buff, map.get(key));


    byte[] bytes = TestUtils.randomByteArray(100);
    map.put(key, bytes);
    byte[] bgot1 = (byte[]) map.get(key);
    assertTrue(bgot1 != bytes);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot1));
    byte[] bgot2 = (byte[]) map.get(key);
    assertTrue(bgot2 != bytes);
    assertTrue(bgot1 != bgot2);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot2));

    try {
      map.put(key, new SomeOtherClass());
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      //OK
    }
  }

  @Test
  public void testSetTypes() throws Exception {

    Set<Object> set = sharedData.getSet("foo");

    double d = new Random().nextDouble();
    set.add(d);
    assertEquals(d, set.iterator().next());
    set.clear();

    float f = new Random().nextFloat();
    set.add(f);
    assertEquals(f, set.iterator().next());
    set.clear();

    byte b = (byte)new Random().nextInt();
    set.add(b);
    assertEquals(b, set.iterator().next());
    set.clear();

    short s = (short)new Random().nextInt();
    set.add(s);
    assertEquals(s, set.iterator().next());
    set.clear();

    int i = new Random().nextInt();
    set.add(i);
    assertEquals(i, set.iterator().next());
    set.clear();

    long l = new Random().nextLong();
    set.add(l);
    assertEquals(l, set.iterator().next());
    set.clear();

    set.add(true);
    assertTrue((Boolean)set.iterator().next());
    set.clear();

    set.add(false);
    assertFalse((Boolean) set.iterator().next());
    set.clear();

    char c = (char)new Random().nextLong();
    set.add(c);
    assertEquals(c, set.iterator().next());
    set.clear();

    Buffer buff = TestUtils.randomBuffer(100);
    set.add(buff);
    Buffer got1 = (Buffer)set.iterator().next();
    assertTrue(got1 != buff); // Make sure it's copied
    assertEquals(buff, set.iterator().next());
    Buffer got2 = (Buffer)set.iterator().next();
    assertTrue(got1 != got2); // Should be copied on each get
    assertTrue(got2 != buff);
    assertEquals(buff, set.iterator().next());
    set.clear();


    byte[] bytes = TestUtils.randomByteArray(100);
    set.add(bytes);
    byte[] bgot1 = (byte[]) set.iterator().next();
    assertTrue(bgot1 != bytes);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot1));
    byte[] bgot2 = (byte[]) set.iterator().next();
    assertTrue(bgot2 != bytes);
    assertTrue(bgot1 != bgot2);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot2));
    set.clear();

    try {
      set.add(new SomeOtherClass());
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      //OK
    }
  }


  @Test
  public void testSet() throws Exception {

    Set<String> set = sharedData.getSet("foo");
    Set<String> set2 = sharedData.getSet("foo");
    assert (set == set2);
    Set<String> set3 = sharedData.getSet("bar");
    assert (set3 != set2);
    assert (sharedData.removeSet("foo"));
    Set<String> set4 = sharedData.getSet("foo");
    assert (set4 != set3);
  }

  class SomeOtherClass {
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_fdb03e8_2e78ec2/rev_fdb03e8-2e78ec2/vertx-core/src/main/java/io/vertx/core/datagram/DatagramSocket.java;<<<<<<< MINE
public interface DatagramSocket extends ReadStream<DatagramPacket> {
=======
public interface DatagramSocket extends Measured {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/BlockedThreadCheckerTest.java;<<<<<<< MINE
=======
package io.vertx.test.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Verticle;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;

import org.junit.Test;

/**
 * please note that this test class does not assert anything about the log output (this would require a kind of log
 * mock), it just runs the different methods to get coverage
 *
 * @author <a href="http://oss.lehmann.cx/">Alexander Lehmann</a>
 */
public class BlockedThreadCheckerTest extends VertxTestBase {

  @Test
  public void testBlockCheckDefault() throws Exception {
    Verticle verticle = new AbstractVerticle() {
      @Override
      public void start() throws InterruptedException {
        Thread.sleep(6000);
        testComplete();
      }
    };
    vertx.deployVerticle(verticle);
    await();
  }

  @Test
  public void testBlockCheckExceptionTimeLimit() throws Exception {
    Verticle verticle = new AbstractVerticle() {
      @Override
      public void start() throws InterruptedException {
        Thread.sleep(2000);
        testComplete();
      }
    };
    // set warning threshold to 1s and the exception threshold as well
    VertxOptions vertxOptions = new VertxOptions();
    vertxOptions.setMaxEventLoopExecuteTime(1000000000);
    vertxOptions.setWarningExceptionTime(1000000000);
    Vertx newVertx = Vertx.vertx(vertxOptions);
    newVertx.deployVerticle(verticle);
    await();
  }

  @Test
  public void testBlockCheckWorker() throws Exception {
    Verticle verticle = new AbstractVerticle() {
      @Override
      public void start() throws InterruptedException {
        Thread.sleep(2000);
        testComplete();
      }
    };
    // set warning threshold to 1s and the exception threshold as well
    VertxOptions vertxOptions = new VertxOptions();
    vertxOptions.setMaxWorkerExecuteTime(1000000000);
    vertxOptions.setWarningExceptionTime(1000000000);
    Vertx newVertx = Vertx.vertx(vertxOptions);
    DeploymentOptions depolymentOptions = new DeploymentOptions();
    depolymentOptions.setWorker(true);
    newVertx.deployVerticle(verticle, depolymentOptions);
    await();
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_9276cbb_a2331d0/rev_9276cbb-a2331d0/src/main/java/io/vertx/core/json/impl/Json.java;<<<<<<< MINE
=======
/*
 * Copyright (c) 2011-2014 The original author or authors
 * ------------------------------------------------------
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Apache License v2.0 which accompanies this distribution.
 *
 *     The Eclipse Public License is available at
 *     http://www.eclipse.org/legal/epl-v10.html
 *
 *     The Apache License v2.0 is available at
 *     http://www.opensource.org/licenses/apache2.0.php
 *
 * You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.json.impl;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.module.SimpleModule;
import io.vertx.core.json.DecodeException;
import io.vertx.core.json.EncodeException;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Base64;
import java.util.List;
import java.util.Map;

/**
 * @author <a href="http://tfox.org">Tim Fox</a>
 */
public class Json {

  private final static ObjectMapper mapper = new ObjectMapper();
  private final static ObjectMapper prettyMapper = new ObjectMapper();

  static {
    // Non-standard JSON but we allow C style comments in our JSON
    mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);

    prettyMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
    prettyMapper.configure(SerializationFeature.INDENT_OUTPUT, true);

    SimpleModule module = new SimpleModule();
    module.addSerializer(JsonObject.class, new JsonObjectSerializer());
    module.addSerializer(JsonArray.class, new JsonArraySerializer());
    mapper.registerModule(module);
    prettyMapper.registerModule(module);
  }

  @SuppressWarnings("unchecked")
  public static Object checkAndCopy(Object val, boolean copy) {
    if (val == null) {
      // OK
    } else if (val instanceof Number && !(val instanceof BigDecimal)) {
      // OK
    } else if (val instanceof Boolean) {
      // OK
    } else if (val instanceof String) {
      // OK
    } else if (val instanceof CharSequence) {
      val = val.toString();
    } else if (val instanceof JsonObject) {
      if (copy) {
        val = ((JsonObject) val).copy();
      }
    } else if (val instanceof JsonArray) {
      if (copy) {
        val = ((JsonArray) val).copy();
      }
    } else if (val instanceof Map) {
      if (copy) {
        val = (new JsonObject((Map)val)).copy();
      } else {
        val = new JsonObject((Map)val);
      }
    } else if (val instanceof List) {
      if (copy) {
        val = (new JsonArray((List)val)).copy();
      } else {
        val = new JsonArray((List)val);
      }
    } else if (val instanceof byte[]) {
      val = Base64.getEncoder().encodeToString((byte[])val);
    } else {
      throw new IllegalStateException("Illegal type in JsonObject: " + val.getClass());
    }
    return val;
  }

  public static String encode(Object obj) throws EncodeException {
    try {
      return mapper.writeValueAsString(obj);
    } catch (Exception e) {
      throw new EncodeException("Failed to encode as JSON: " + e.getMessage());
    }
  }

  public static String encodePrettily(Object obj) throws EncodeException {
    try {
      return prettyMapper.writeValueAsString(obj);
    } catch (Exception e) {
      throw new EncodeException("Failed to encode as JSON: " + e.getMessage());
    }
  }

  public static <T> T decodeValue(String str, Class<T> clazz) throws DecodeException {
    try {
      return mapper.readValue(str, clazz);
    }
    catch (Exception e) {
      throw new DecodeException("Failed to decode:" + e.getMessage());
    }
  }

  private static class JsonObjectSerializer extends JsonSerializer<JsonObject> {
    @Override
    public void serialize(JsonObject value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
      jgen.writeObject(value.getMap());
    }
  }

  private static class JsonArraySerializer extends JsonSerializer<JsonArray> {
    @Override
    public void serialize(JsonArray value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
      jgen.writeObject(value.getList());
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/StartCommandFactory.java;<<<<<<< MINE
=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.impl.launcher.commands;

import io.vertx.core.spi.launcher.DefaultCommandFactory;

/**
 * Defines the `start` command.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class StartCommandFactory extends DefaultCommandFactory<StartCommand> {

  /**
   * Creates a new instance of {@link StartCommandFactory}.
   */
  public StartCommandFactory() {
    super(StartCommand.class);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/StopCommandFactory.java;<<<<<<< MINE
=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.impl.launcher.commands;

import io.vertx.core.spi.launcher.DefaultCommandFactory;

/**
 * Defines the `stop` command.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class StopCommandFactory extends DefaultCommandFactory<StopCommand> {

  /**
   * Creates a new instance of {@link StopCommandFactory}.
   */
  public StopCommandFactory() {
    super(StopCommand.class);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/ExecUtils.java;<<<<<<< MINE
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */
package io.vertx.core.impl.launcher.commands;

import java.util.List;

/**
 * A couple of utility methods easing process creation.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class ExecUtils {

  private static final String SINGLE_QUOTE = "\'";
  private static final String DOUBLE_QUOTE = "\"";

  /**
   * The {@code os.name} property is mandatory (from the Java Virtual Machine specification).
   */
  private static String osName = System.getProperty("os.name").toLowerCase();

  /**
   * Puts quotes around the given String if necessary.
   * <p>
   * If the argument doesn't include spaces or quotes, return it as is. If it
   * contains double quotes, use single quotes - else surround the argument by
   * double quotes.
   * </p>
   *
   * @param argument the argument to be quoted
   * @return the quoted argument
   * @throws IllegalArgumentException If argument contains both types of quotes
   */
  public static String quoteArgument(final String argument) {

    String cleanedArgument = argument.trim();

    // strip the quotes from both ends
    while (cleanedArgument.startsWith(SINGLE_QUOTE) || cleanedArgument.startsWith(DOUBLE_QUOTE)) {
      cleanedArgument = cleanedArgument.substring(1);
    }

    while (cleanedArgument.endsWith(SINGLE_QUOTE) || cleanedArgument.endsWith(DOUBLE_QUOTE)) {
      cleanedArgument = cleanedArgument.substring(0, cleanedArgument.length() - 1);
    }

    final StringBuilder buf = new StringBuilder();
    if (cleanedArgument.contains(DOUBLE_QUOTE)) {
      if (cleanedArgument.contains(SINGLE_QUOTE)) {
        throw new IllegalArgumentException(
            "Can't handle single and double quotes in same argument");
      }
      return buf.append(SINGLE_QUOTE).append(cleanedArgument).append(
          SINGLE_QUOTE).toString();
    } else if (cleanedArgument.contains(SINGLE_QUOTE)
        || cleanedArgument.contains(" ")) {
      return buf.append(DOUBLE_QUOTE).append(cleanedArgument).append(
          DOUBLE_QUOTE).toString();
    } else {
      return cleanedArgument;
    }
  }

  /**
   * Adds an argument to the given list. It automatially add quotes to the argument if necessary.
   *
   * @param args the list of arguments
   * @param argument the argument to add
   */
  public static void addArgument(List<String> args, String argument) {
    args.add(quoteArgument(argument));
  }

  /**
   * @return {@code true} if the current operating system belongs to the "windows" family.
   */
  public static boolean isWindows() {
    return osName.contains("windows");
  }


}=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */
package io.vertx.core.impl.launcher.commands;

import java.util.List;

/**
 * A couple of utility methods easing process creation.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class ExecUtils {

  private static final String SINGLE_QUOTE = "\'";
  private static final String DOUBLE_QUOTE = "\"";

  /**
   * The {@code os.name} property is mandatory (from the Java Virtual Machine specification).
   */
  private static String osName = System.getProperty("os.name").toLowerCase();

  /**
   * Puts quotes around the given String if necessary.
   * <p>
   * If the argument doesn't include spaces or quotes, return it as is. If it
   * contains double quotes, use single quotes - else surround the argument by
   * double quotes.
   * </p>
   *
   * @param argument the argument to be quoted
   * @return the quoted argument
   * @throws IllegalArgumentException If argument contains both types of quotes
   */
  public static String quoteArgument(final String argument) {

    String cleanedArgument = argument.trim();

    // strip the quotes from both ends
    while (cleanedArgument.startsWith(SINGLE_QUOTE) && cleanedArgument.endsWith(SINGLE_QUOTE)
        || cleanedArgument.startsWith(DOUBLE_QUOTE)  && cleanedArgument.endsWith(DOUBLE_QUOTE)) {
      cleanedArgument = cleanedArgument.substring(1, cleanedArgument.length() - 1);
    }

    final StringBuilder buf = new StringBuilder();
    if (cleanedArgument.contains(DOUBLE_QUOTE)) {
      if (cleanedArgument.contains(SINGLE_QUOTE)) {
        throw new IllegalArgumentException(
            "Can't handle single and double quotes in same argument");
      }
      return buf.append(SINGLE_QUOTE).append(cleanedArgument).append(
          SINGLE_QUOTE).toString();
    } else if (cleanedArgument.contains(SINGLE_QUOTE)
        || cleanedArgument.contains(" ")) {
      return buf.append(DOUBLE_QUOTE).append(cleanedArgument).append(
          DOUBLE_QUOTE).toString();
    } else {
      return cleanedArgument;
    }
  }

  /**
   * Adds an argument to the given list. It automatially add quotes to the argument if necessary.
   *
   * @param args the list of arguments
   * @param argument the argument to add
   */
  public static void addArgument(List<String> args, String argument) {
    args.add(quoteArgument(argument));
  }

  /**
   * @return {@code true} if the current operating system belongs to the "windows" family.
   */
  public static boolean isWindows() {
    return osName.contains("windows");
  }


}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/ListCommandFactory.java;<<<<<<< MINE
=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.impl.launcher.commands;

import io.vertx.core.spi.launcher.DefaultCommandFactory;

/**
 * Defines the `list` command.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class ListCommandFactory extends DefaultCommandFactory<ListCommand> {
  /**
   * Creates a new {@link ListCommandFactory}.
   */
  public ListCommandFactory() {
    super(ListCommand.class);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_1ff48fe_08f2ffc/rev_1ff48fe-08f2ffc/src/test/java/io/vertx/test/core/JsonMapperTest.java;<<<<<<< MINE

  @Test
  public void encodeCustomTypeInstant() {
    Instant now = Instant.now();
    String json = Json.encode(now);
    assertNotNull(json);
    // the RFC is one way only
    Instant decoded = Instant.from(ISO_INSTANT.parse(json.substring(1, json.length() - 1)));
    assertEquals(now, decoded);

  }

  @Test
  public void encodeCustomTypeInstantNull() {
    Instant now = null;
    String json = Json.encode(now);
    assertNotNull(json);
    assertEquals("null", json);
  }

  @Test
  public void encodeCustomTypeBinary() {
    byte[] data = new byte[] { 'h', 'e', 'l', 'l', 'o'};
    String json = Json.encode(data);
    assertNotNull(json);
    // base64 encoded hello
    assertEquals("\"aGVsbG8=\"", json);
  }

  @Test
  public void encodeCustomTypeBinaryNull() {
    byte[] data = null;
    String json = Json.encode(data);
    assertNotNull(json);
    assertEquals("null", json);
  }
=======

  @Test
  public void testGenericDecoding() {
    Pojo original = new Pojo();
    original.value = "test";

    String json = Json.encode(Collections.singletonList(original));

    List<Pojo> correct = Json.decodeValue(json, new TypeReference<List<Pojo>>() {});
    assertTrue(((List)correct).get(0) instanceof Pojo);
    assertEquals(original.value, correct.get(0).value);

    List incorrect = Json.decodeValue(json, List.class);
    assertFalse(incorrect.get(0) instanceof Pojo);
    assertTrue(incorrect.get(0) instanceof Map);
    assertEquals(original.value, ((Map)(incorrect.get(0))).get("value"));
  }

  private static class Pojo {
    @JsonProperty
    String value;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_f3e0802_d71e802/rev_f3e0802-d71e802/src/test/java/io/vertx/test/core/JsonMapperTest.java;<<<<<<< MINE

  @Test
  public void encodeToBuffer() {
    Buffer json = Json.encodeToBuffer("Hello World!");
    assertNotNull(json);
    // json strings are always UTF8
    assertEquals("\"Hello World!\"", json.toString("UTF-8"));
  }
=======

  @Test
  public void testGenericDecoding() {
    Pojo original = new Pojo();
    original.value = "test";

    String json = Json.encode(Collections.singletonList(original));

    List<Pojo> correct = Json.decodeValue(json, new TypeReference<List<Pojo>>() {});
    assertTrue(((List)correct).get(0) instanceof Pojo);
    assertEquals(original.value, correct.get(0).value);

    List incorrect = Json.decodeValue(json, List.class);
    assertFalse(incorrect.get(0) instanceof Pojo);
    assertTrue(incorrect.get(0) instanceof Map);
    assertEquals(original.value, ((Map)(incorrect.get(0))).get("value"));
  }

  private static class Pojo {
    @JsonProperty
    String value;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_cff6c96_6e8180b/rev_cff6c96-6e8180b/websocket/binary/src/test/java/org/javaee7/websocket/binary/test/WebsocketByteBufferEndpointTest.java;<<<<<<< MINE
=======
/**
 *
 */
package org.javaee7.websocket.binary.test;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import javax.websocket.ContainerProvider;
import javax.websocket.DeploymentException;
import javax.websocket.WebSocketContainer;

import org.javaee7.websocket.binary.MyEndpointByteArray;
import org.javaee7.websocket.binary.MyEndpointByteBuffer;
import org.javaee7.websocket.binary.MyEndpointClient;
import org.javaee7.websocket.binary.MyEndpointInputStream;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.container.test.api.TargetsContainer;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * @author Nikos "cirix" Ballas
 *
 */
@RunWith(Arquillian.class)
public class WebsocketByteBufferEndpointTest {

    private static final String WEBAPP_SRC = "src/main/webapp";

    /**
     * Arquillian specific method for creating a file which can be deployed
     * while executing the test.
     *
     * @return a war file
     */
    @Deployment(testable = false)
    @TargetsContainer("wildfly-arquillian")
    public static WebArchive createDeployment() {
        WebArchive war = ShrinkWrap.create(WebArchive.class).
                addClass(MyEndpointByteBuffer.class).
                addClass(MyEndpointByteArray.class).
                addClass(MyEndpointInputStream.class).
                addAsWebResource(new File(WEBAPP_SRC, "index.jsp")).
                addAsWebResource(new File(WEBAPP_SRC, "websocket.js"));
        return war;
    }

    /**
     * The basic test method for the class {@link MyEndpointByteBuffer}
     *
     * @throws URISyntaxException
     * @throws DeploymentException
     * @throws IOException
     */
    @Test
    public void testEndPointByteBuffer() throws URISyntaxException, DeploymentException, IOException {
        WebSocketContainer wSocketContainer = ContainerProvider.getWebSocketContainer();
        wSocketContainer.connectToServer(MyEndpointClient.class, new URI("ws://localhost:8080/binary/bytearray"));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_b77bf39_ed4cb65/rev_b77bf39-ed4cb65/cdi/decorators/src/test/java/org/javaee7/cdi/decorators/DecoratorTest.java;<<<<<<< MINE
=======
package org.javaee7.cdi.decorators;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Test;
import org.junit.runner.RunWith;

import javax.inject.Inject;
import java.io.File;
import java.net.URISyntaxException;

import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;

/**
 * @author Korneliusz Rabczak
 */
@RunWith(Arquillian.class)
public class DecoratorTest {

    @Inject
    Greeting greeting;

    @Deployment
    public static Archive<?> deploy() throws URISyntaxException {
        return ShrinkWrap.create(JavaArchive.class)
                .addAsManifestResource(new File("src/main/webapp/WEB-INF/beans.xml"), "beans.xml")
                .addPackage(SimpleGreeting.class.getPackage());
    }

    @Test
    public void test() {
        assertThat(greeting.greet("Duke"), is("Hello Duke very much!"));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/main/java/org/javaee7/jaspic/asyncauthentication/sam/SamAutoRegistrationListener.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication.sam;

import javax.servlet.ServletContextEvent;
import javax.servlet.annotation.WebListener;

import org.javaee7.jaspic.common.BaseServletContextListener;
import org.javaee7.jaspic.common.JaspicUtils;

/**
 * 
 * @author Arjan Tijms
 * 
 */
@WebListener
public class SamAutoRegistrationListener extends BaseServletContextListener {

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        JaspicUtils.registerSAM(sce.getServletContext(), new TestServerAuthModule());
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/main/java/org/javaee7/jaspic/asyncauthentication/servlet/AsyncServlet.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication.servlet;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.AsyncContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.javaee7.jaspic.asyncauthentication.bean.AsyncBean;

/**
 * 
 * @author Arjan Tijms
 * 
 */
@WebServlet(urlPatterns = "/public/asyncServlet", asyncSupported = true)
public class AsyncServlet extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @EJB
    private AsyncBean asyncBean;
    
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        
        AsyncContext asyncContext = request.startAsync();
        asyncContext.setTimeout(5000);
        
        asyncBean.doAsync(asyncContext);
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/main/java/org/javaee7/jaspic/asyncauthentication/bean/AsyncBean.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication.bean;

import static java.lang.Thread.interrupted;
import static java.lang.Thread.sleep;

import java.io.IOException;

import javax.ejb.Asynchronous;
import javax.ejb.Stateless;
import javax.servlet.AsyncContext;

/**
 * 
 * @author Arjan Tijms
 *
 */
@Stateless
public class AsyncBean {

    @Asynchronous
    public void doAsync(AsyncContext asyncContext) {
        
        try {
            sleep(1000);
        } catch (InterruptedException e) {
            interrupted();
        }
        
        try {
            asyncContext.getResponse().getWriter().write("async response");
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        asyncContext.complete();
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/test/java/org/javaee7/jaspic/asyncauthentication/AsyncAuthenticationPublicTest.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication;

import static org.junit.Assert.assertTrue;

import java.io.IOException;

import org.javaee7.jaspic.common.ArquillianBase;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.xml.sax.SAXException;

/**
 * 
 * 
 * @author Arjan Tijms
 * 
 */
@RunWith(Arquillian.class)
public class AsyncAuthenticationPublicTest extends ArquillianBase {

    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return defaultArchive();
    }

    /**
     * This tests that an async response works at all in the mere presence of
     * a JASPIC SAM (that does nothing)
     */
    @Test
    public void testBasicAsync() throws IOException, SAXException {

        String response = getFromServerPath("public/asyncServlet");
        assertTrue(response.contains("async response"));
    }

}>>>>>>> YOURS
