file;linedbasedConf
/home/paper219/Desktop/analysis/demonstration/projects/Mybatis-3/revisions/rev_22fcbef_cd9a221/rev_22fcbef-cd9a221/src/main/java/org/apache/ibatis/type/JdbcType.java;<<<<<<< MINE
/**
 *    Copyright 2009-2015 the original author or authors.
=======
/*
 *    Copyright 2009-2015 the original author or authors.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Mybatis-3/revisions/rev_413f62d_09f86b6/rev_413f62d-09f86b6/src/main/java/org/apache/ibatis/io/ExternalResources.java;<<<<<<< MINE
 *    Copyright 2009-2015 the original author or authors.
=======
 *    Copyright 2009-2016 the original author or authors.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Mybatis-3/revisions/rev_b195e2e_5d213fc/rev_b195e2e-5d213fc/src/test/java/org/apache/ibatis/submitted/ancestor_ref/Reputation.java;<<<<<<< MINE
=======
/**
 *    Copyright 2009-2016 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Mybatis-3/revisions/rev_da6dca2_151e90e/rev_da6dca2-151e90e/src/test/java/org/apache/ibatis/type/usesjava8/Jsr310TypeHandlerRegistryTest.java;<<<<<<< MINE
import static org.hamcrest.core.IsInstanceOf.*;
import static org.junit.Assert.*;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Month;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.Year;
import java.time.YearMonth;
import java.time.ZonedDateTime;
import java.time.chrono.JapaneseDate;

import org.apache.ibatis.type.InstantTypeHandler;
import org.apache.ibatis.type.JapaneseDateTypeHandler;
import org.apache.ibatis.type.LocalDateTimeTypeHandler;
import org.apache.ibatis.type.LocalDateTypeHandler;
import org.apache.ibatis.type.LocalTimeTypeHandler;
import org.apache.ibatis.type.MonthTypeHandler;
import org.apache.ibatis.type.OffsetDateTimeTypeHandler;
import org.apache.ibatis.type.OffsetTimeTypeHandler;
import org.apache.ibatis.type.TypeHandlerRegistry;
import org.apache.ibatis.type.YearMonthTypeHandler;
import org.apache.ibatis.type.YearTypeHandler;
import org.apache.ibatis.type.ZonedDateTimeTypeHandler;
=======
import static org.assertj.core.api.Assertions.assertThat;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.type.*;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Mybatis-3/revisions/rev_da6dca2_151e90e/rev_da6dca2-151e90e/src/test/java/org/apache/ibatis/type/usesjava8/Jsr310TypeHandlerRegistryTest.java;<<<<<<< MINE
import static org.junit.Assert.*;
import static org.hamcrest.core.IsInstanceOf.*;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Mybatis-3/revisions/rev_da6dca2_151e90e/rev_da6dca2-151e90e/src/test/java/org/apache/ibatis/type/usesjava8/Jsr310TypeHandlerRegistryTest.java;<<<<<<< MINE
  public void shouldRegisterJsr310TypeHandlers() throws ClassNotFoundException {
    assertThat(typeHandlerRegistry.getTypeHandler(Instant.class), instanceOf(InstantTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(LocalDateTime.class), instanceOf(LocalDateTimeTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(LocalDate.class), instanceOf(LocalDateTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(LocalTime.class), instanceOf(LocalTimeTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(OffsetDateTime.class), instanceOf(OffsetDateTimeTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(OffsetTime.class), instanceOf(OffsetTimeTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(ZonedDateTime.class), instanceOf(ZonedDateTimeTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(Month.class), instanceOf(MonthTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(Year.class), instanceOf(YearTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(YearMonth.class), instanceOf(YearMonthTypeHandler.class));
    assertThat(typeHandlerRegistry.getTypeHandler(JapaneseDate.class), instanceOf(JapaneseDateTypeHandler.class));
=======
  public void testFor_v1_0_0() throws ClassNotFoundException {
    assertThat(getTypeHandler("java.time.Instant")).isInstanceOf(InstantTypeHandler.class);
    assertThat(getTypeHandler("java.time.LocalDateTime")).isInstanceOf(LocalDateTimeTypeHandler.class);
    assertThat(getTypeHandler("java.time.LocalDate")).isInstanceOf(LocalDateTypeHandler.class);
    assertThat(getTypeHandler("java.time.LocalTime")).isInstanceOf(LocalTimeTypeHandler.class);
    assertThat(getTypeHandler("java.time.OffsetDateTime")).isInstanceOf(OffsetDateTimeTypeHandler.class);
    assertThat(getTypeHandler("java.time.OffsetTime")).isInstanceOf(OffsetTimeTypeHandler.class);
    assertThat(getTypeHandler("java.time.ZonedDateTime")).isInstanceOf(ZonedDateTimeTypeHandler.class);
  }

  @Test
  public void testFor_v1_0_1() throws ClassNotFoundException {
    assertThat(getTypeHandler("java.time.Month")).isInstanceOf(MonthTypeHandler.class);
    assertThat(getTypeHandler("java.time.Year")).isInstanceOf(YearTypeHandler.class);
  }

  @Test
  public void testFor_v1_0_2() throws ClassNotFoundException {
    assertThat(getTypeHandler("java.time.YearMonth")).isInstanceOf(YearMonthTypeHandler.class);
    assertThat(getTypeHandler("java.time.chrono.JapaneseDate")).isInstanceOf(JapaneseDateTypeHandler.class);
  }

  private TypeHandler<?> getTypeHandler(String fqcn) throws ClassNotFoundException {
    return typeHandlerRegistry.getTypeHandler(Resources.classForName(fqcn));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.asm.ASMException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.asm.ASMException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java;<<<<<<< MINE
=======
        } catch (ASMException asmError) {
        	return new JavaBeanDeserializer(this, clazz);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/main/java/com/alibaba/fastjson/asm/ASMException.java;<<<<<<< MINE
=======
package com.alibaba.fastjson.asm;

import com.alibaba.fastjson.JSONException;

public class ASMException extends JSONException {

	private static final long serialVersionUID = 1L;

    public ASMException(String message){
        super(message);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                if (elementType instanceof Class<?>) {
=======
                if (elementClass != null && Modifier.isPublic(elementClass.getModifiers())) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                if (elementType instanceof Class<?>) {
=======
                if (elementClass != null && Modifier.isPublic(elementClass.getModifiers())) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/test/java/com/alibaba/json/bvt/bug/Bug_for_vikingschow.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.json.bvtVO.OfferRankResultVO;

public class Bug_for_vikingschow extends TestCase {
	public void test_for_vikingschow() throws Exception {
		OfferRankResultVO vo = new OfferRankResultVO();
		String text = JSON.toJSONString(vo);
		JSON.parseObject(text, OfferRankResultVO.class);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_f65ddcf_0b063a2/rev_f65ddcf-0b063a2/src/test/java/com/alibaba/json/bvtVO/OfferRankResultVO.java;<<<<<<< MINE
=======
package com.alibaba.json.bvtVO;

import java.util.ArrayList;
import java.util.List;

public class OfferRankResultVO {
	private List<SearchCenterOfferModel> models = new ArrayList<SearchCenterOfferModel>();
	
	public OfferRankResultVO() {
		models.add(new SearchCenterOfferModel());
	}

	public List<SearchCenterOfferModel> getModel() {
		return models;
	}

	public void setModel(List<SearchCenterOfferModel> models) {
		this.models = models;
	}

}

class SearchCenterOfferModel {
	private int id;
	private String name;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java;<<<<<<< MINE
=======
import java.util.Locale;
import java.util.TimeZone;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java;<<<<<<< MINE
        calendar = Calendar.getInstance();
=======
        Locale local = Locale.getDefault();
        calendar = Calendar.getInstance(TimeZone.getDefault(), local);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/TimeDeserializer.java;<<<<<<< MINE
=======
            long longVal;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/TimeDeserializer.java;<<<<<<< MINE
                return (T) dateLexer.getCalendar().getTime();
=======
                longVal = dateLexer.getCalendar().getTimeInMillis();
            } else {
                longVal = Long.parseLong(strVal);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/TimeDeserializer.java;<<<<<<< MINE

            long longVal = Long.parseLong(strVal);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
            SimpleDateFormat dateFormat = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT);
            try {
                java.util.Date date = (java.util.Date) dateFormat.parse(strVal);
                return (T) new java.sql.Date(date.getTime());
            } catch (ParseException e) {
                // skip
=======

            long longVal;

            JSONScanner dateLexer = new JSONScanner(strVal);
            if (dateLexer.scanISO8601DateIfMatch()) {
                longVal = dateLexer.getCalendar().getTimeInMillis();
            } else {

                SimpleDateFormat dateFormat = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT);
                try {
                    java.util.Date date = (java.util.Date) dateFormat.parse(strVal);
                    return (T) new java.sql.Date(date.getTime());
                } catch (ParseException e) {
                    // skip
                }

                longVal = Long.parseLong(strVal);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
            
            long longVal = Long.parseLong(strVal);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/test/java/com/alibaba/json/bvt/parser/deser/SqlDateDeserializerTest2.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser.deser;

import java.sql.Date;
import java.text.SimpleDateFormat;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class SqlDateDeserializerTest2 extends TestCase {
    public void test_sqlDate() throws Exception {
        java.util.Date date = new java.util.Date();
        long millis = date.getTime();
        long millis2 = (millis / 1000)  * 1000;
        String text = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(millis);
        text = text.replace(' ', 'T');
        
        String text2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(millis2);
        
        Assert.assertNull(JSON.parseObject("null", Date.class));
        Assert.assertNull(JSON.parseObject("\"\"", Date.class));
        Assert.assertNull(JSON.parseArray("null", Date.class));
        Assert.assertNull(JSON.parseArray("[null]", Date.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        
        Assert.assertEquals(new Date(millis), JSON.parseObject("" + millis, Date.class));
        Assert.assertEquals(new Date(millis), JSON.parseObject("{\"@type\":\"java.sql.Date\",\"val\":" + millis + "}", Date.class));
        Assert.assertEquals(new Date(millis), JSON.parseObject("\"" + millis + "\"", Date.class));
        Assert.assertEquals(new Date(millis2), JSON.parseObject("\"" + text2 + "\"", Date.class));
        Assert.assertEquals(new Date(millis), JSON.parseObject("\"" + text + "\"", Date.class));
        
        //System.out.println(JSON.toJSONString(new Time(millis), SerializerFeature.WriteClassName));
        
    }

    public static class VO {

        private Date value;

        public Date getValue() {
            return value;
        }

        public void setValue(Date value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/test/java/com/alibaba/json/bvt/parser/deser/StackTraceElementDeserializerTest.java;<<<<<<< MINE
package com.alibaba.json.bvt.parser.deser;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONException;

public class StackTraceElementDeserializerTest extends TestCase {

    public void test_stack() throws Exception {
        Assert.assertNull(JSON.parseObject("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("[null]", StackTraceElement.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        Assert.assertNull(JSON.parseObject("{\"className\":\"int\",\"methodName\":\"parseInt\"}",
                                           StackTraceElement.class).getFileName());
        
        Assert.assertEquals(StackTraceElement.class, ((StackTraceElement) JSON.parse("{\"@type\":\"java.lang.StackTraceElement\",\"className\":\"int\",\"methodName\":\"parseInt\"}")).getClass());
    }

    public void test_stack_error() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("{}", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
    
    public void test_stack_error_1() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("[]", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
    
    public void test_stack_error_2() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("{\"className\":null,\"methodName\":null,\"fileName\":null,\"lineNumber\":null,\"@type\":\"xxx\"}", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
    public void test_stack_error_3() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject("{\"@type\":33}", StackTraceElement.class);
        } catch (JSONException ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }

    public static class VO {

        private StackTraceElement value;

        public StackTraceElement getValue() {
            return value;
        }

        public void setValue(StackTraceElement value) {
            this.value = value;
        }

    }
}=======
package com.alibaba.json.bvt.parser.deser;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class StackTraceElementDeserializerTest extends TestCase {

    public void test_stack() throws Exception {
        Assert.assertNull(JSON.parseObject("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("null", StackTraceElement.class));
        Assert.assertNull(JSON.parseArray("[null]", StackTraceElement.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        Assert.assertNull(JSON.parseObject("{\"className\":\"int\",\"methodName\":\"parseInt\"}", StackTraceElement.class).getFileName());
    }

    public static class VO {

        private StackTraceElement value;

        public StackTraceElement getValue() {
            return value;
        }

        public void setValue(StackTraceElement value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_77a6605_f48bb05/rev_77a6605-f48bb05/src/test/java/com/alibaba/json/bvt/parser/deser/TimeDeserializerTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser.deser;

import java.sql.Time;
import java.text.SimpleDateFormat;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TimeDeserializerTest extends TestCase {
    public void test_time() throws Exception {
        long millis = System.currentTimeMillis();
        String text = new SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date(millis));
        text += "T";
        text += new SimpleDateFormat("HH:mm:ss.SSS").format(new java.util.Date(millis));
        
        Assert.assertNull(JSON.parseObject("null", Time.class));
        Assert.assertNull(JSON.parseObject("\"\"", Time.class));
        Assert.assertNull(JSON.parseArray("null", Time.class));
        Assert.assertNull(JSON.parseArray("[null]", Time.class).get(0));
        Assert.assertNull(JSON.parseObject("{\"value\":null}", VO.class).getValue());
        
        Assert.assertEquals(new Time(millis), JSON.parseObject("" + millis, Time.class));
        Assert.assertEquals(new Time(millis), JSON.parseObject("{\"@type\":\"java.sql.Time\",\"val\":" + millis + "}", Time.class));
        Assert.assertEquals(new Time(millis), JSON.parseObject("\"" + millis + "\"", Time.class));
        Assert.assertEquals(new Time(millis), JSON.parseObject("\"" + text + "\"", Time.class));
        
        //System.out.println(JSON.toJSONString(new Time(millis), SerializerFeature.WriteClassName));
        
    }

    public static class VO {

        private Time value;

        public Time getValue() {
            return value;
        }

        public void setValue(Time value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE

            if (seperator != 0) {
                buf[count - 2] = '\"';
                buf[count - 1] = seperator;
            } else {
                buf[count - 1] = '\"';
            }
=======

            buf[count - 1] = '\"';
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
            if (ch < CharTypes.specicalFlags_doubleQuotes.length && CharTypes.specicalFlags_doubleQuotes[ch] //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
=======

            if (ch < CharTypes.specicalFlags_doubleQuotes.length
                && CharTypes.specicalFlags_doubleQuotes[ch] //
                || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch < CharTypes.specicalFlags_doubleQuotes.length && CharTypes.specicalFlags_doubleQuotes[ch] //
                        || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                        || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
=======
                if (ch < CharTypes.specicalFlags_doubleQuotes.length
                    && CharTypes.specicalFlags_doubleQuotes[ch] //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
=======
        writeKeyWithDoubleQuote(text, true);
    }

    public void writeKeyWithDoubleQuote(String text, boolean checkSpecial) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        for (int i = start; i < end; ++i) {
            char ch = buf[i];
            if (ch < specicalFlags_doubleQuotes.length && specicalFlags_doubleQuotes[ch] //
                || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                newcount++;
                if (newcount > buf.length) {
                    expandCapacity(newcount);
=======
        if (checkSpecial) {
            for (int i = start; i < end; ++i) {
                char ch = buf[i];
                if (ch < specicalFlags_doubleQuotes.length
                    && specicalFlags_doubleQuotes[ch] //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                    newcount++;
                    if (newcount > buf.length) {
                        expandCapacity(newcount);
                    }
                    count = newcount;

                    System.arraycopy(buf, i + 1, buf, i + 2, end - i - 1);
                    buf[i] = '\\';
                    buf[++i] = replaceChars[(int) ch];
                    end++;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                count = newcount;

                System.arraycopy(buf, i + 1, buf, i + 2, end - i - 1);
                buf[i] = '\\';
                buf[++i] = replaceChars[(int) ch];
                end++;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                    writeFieldValueStringWithDoubleQuote(seperator, name, value);                    
=======
                    writeFieldValueStringWithDoubleQuote(seperator, name, value);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '"' //
=======
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                    || ch == '"' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '"' //
=======
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                || ch == '"' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '"' //
=======
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                    || ch == '"' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '\'' //
=======
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                || ch == '\'' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '\'' //
=======
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                    || ch == '\'' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
=======
    
    public void writeFieldName(String key) {
        writeFieldName(key, false);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
    public void writeFieldName(String key) {
=======
    public void writeFieldName(String key, boolean checkSpecial) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                writeKeyWithDoubleQuote(key);
=======
                writeKeyWithDoubleQuote(key, checkSpecial);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            if (ch < specicalFlags_singleQuotes.length && specicalFlags_singleQuotes[ch] //
=======
            if (ch < specicalFlags_singleQuotes.length
                && specicalFlags_singleQuotes[ch] //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/main/java/com/alibaba/fastjson/serializer/MapSerializer.java;<<<<<<< MINE
                    out.writeFieldName(key);
=======
                    out.writeFieldName(key, true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/codec/FastjsonCodec.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.serializer.SerializerFeature;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/codec/FastjsonCodec.java;<<<<<<< MINE
=======
        out.config(SerializerFeature.DisableCircularReferenceDetect, true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
import com.alibaba.json.test.benchmark.decode.EishayDecode;
import com.alibaba.json.test.benchmark.decode.EishayDecodeBytes;
=======
import com.alibaba.json.test.benchmark.encode.EishayEncode;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
        executor.setExecuteCount(5);
=======
        executor.setExecuteCount(4);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
        executor.getCodecList().add(new JacksonCodec());
=======
//        executor.getCodecList().add(new JacksonCodec());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
        executor.getCaseList().add(new EishayDecodeBytes());
=======
//        executor.getCaseList().add(new EishayDecodeBytes());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
         executor.getCaseList().add(new EishayDecode());
=======
//         executor.getCaseList().add(new EishayDecode());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
//         executor.getCaseList().add(new EishayEncode());
=======
         executor.getCaseList().add(new EishayEncode());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_22e12be_162ae20/rev_22e12be-162ae20/src/test/java/com/alibaba/json/bvt/serializer/StringSerializerTest.java;<<<<<<< MINE
		out.writeFieldName("123\na\nb\nc\nd\"'e");
=======
		out.writeFieldName("123\na\nb\nc\nd\"'e", true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE

            buf[count - 1] = '\"';
=======

            if (seperator != 0) {
                buf[count - 2] = '\"';
                buf[count - 1] = seperator;
            } else {
                buf[count - 1] = '\"';
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            
            if (ch < CharTypes.specicalFlags_doubleQuotes.length && CharTypes.specicalFlags_doubleQuotes[ch] //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
=======

            if (ch < CharTypes.specicalFlags_doubleQuotes.length
                && CharTypes.specicalFlags_doubleQuotes[ch] //
                || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch < CharTypes.specicalFlags_doubleQuotes.length && CharTypes.specicalFlags_doubleQuotes[ch] //
                        || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                        || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
=======
                if (ch < CharTypes.specicalFlags_doubleQuotes.length
                    && CharTypes.specicalFlags_doubleQuotes[ch] //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
=======
        writeKeyWithDoubleQuote(text, true);
    }

    public void writeKeyWithDoubleQuote(String text, boolean checkSpecial) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        for (int i = start; i < end; ++i) {
            char ch = buf[i];
            if (ch < specicalFlags_doubleQuotes.length && specicalFlags_doubleQuotes[ch] //
                || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                newcount++;
                if (newcount > buf.length) {
                    expandCapacity(newcount);
=======
        if (checkSpecial) {
            for (int i = start; i < end; ++i) {
                char ch = buf[i];
                if (ch < specicalFlags_doubleQuotes.length
                    && specicalFlags_doubleQuotes[ch] //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                    newcount++;
                    if (newcount > buf.length) {
                        expandCapacity(newcount);
                    }
                    count = newcount;

                    System.arraycopy(buf, i + 1, buf, i + 2, end - i - 1);
                    buf[i] = '\\';
                    buf[++i] = replaceChars[(int) ch];
                    end++;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                count = newcount;

                System.arraycopy(buf, i + 1, buf, i + 2, end - i - 1);
                buf[i] = '\\';
                buf[++i] = replaceChars[(int) ch];
                end++;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                    writeFieldValueStringWithDoubleQuote(seperator, name, value);                    
=======
                    writeFieldValueStringWithDoubleQuote(seperator, name, value);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '"' //
=======
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                    || ch == '"' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '"' //
=======
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                || ch == '"' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '"' //
=======
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                    || ch == '"' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '\'' //
=======
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                || ch == '\'' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\' || ch == '\'' //
=======
                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                    || ch == '\'' //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
=======
    
    public void writeFieldName(String key) {
        writeFieldName(key, false);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
    public void writeFieldName(String key) {
=======
    public void writeFieldName(String key, boolean checkSpecial) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
                writeKeyWithDoubleQuote(key);
=======
                writeKeyWithDoubleQuote(key, checkSpecial);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            if (ch < specicalFlags_singleQuotes.length && specicalFlags_singleQuotes[ch] //
=======
            if (ch < specicalFlags_singleQuotes.length
                && specicalFlags_singleQuotes[ch] //
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/main/java/com/alibaba/fastjson/serializer/MapSerializer.java;<<<<<<< MINE
                    out.writeFieldName(key);
=======
                    out.writeFieldName(key, true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/codec/FastjsonCodec.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.serializer.SerializerFeature;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/codec/FastjsonCodec.java;<<<<<<< MINE
=======
        out.config(SerializerFeature.DisableCircularReferenceDetect, true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
import com.alibaba.json.test.benchmark.decode.EishayDecode;
import com.alibaba.json.test.benchmark.decode.EishayDecodeBytes;
=======
import com.alibaba.json.test.benchmark.encode.EishayEncode;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
        executor.setExecuteCount(5);
=======
        executor.setExecuteCount(4);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
        executor.getCodecList().add(new JacksonCodec());
=======
//        executor.getCodecList().add(new JacksonCodec());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
        executor.getCaseList().add(new EishayDecodeBytes());
=======
//        executor.getCaseList().add(new EishayDecodeBytes());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
         executor.getCaseList().add(new EishayDecode());
=======
//         executor.getCaseList().add(new EishayDecode());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
//         executor.getCaseList().add(new EishayEncode());
=======
         executor.getCaseList().add(new EishayEncode());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_162ae20_22e12be/rev_162ae20-22e12be/src/test/java/com/alibaba/json/bvt/serializer/StringSerializerTest.java;<<<<<<< MINE
		out.writeFieldName("123\na\nb\nc\nd\"'e");
=======
		out.writeFieldName("123\na\nb\nc\nd\"'e", true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_cc0428f_dee22f7/rev_cc0428f-dee22f7/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
                    if (clazz == null) {
                        continue;
                    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_cc0428f_dee22f7/rev_cc0428f-dee22f7/src/test/java/com/alibaba/json/bvt/TestExternal3.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;

import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;


public class TestExternal3 extends TestCase {
    public void test_0 () throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("external.VO");
        Method method = clazz.getMethod("setName", new Class[] {String.class});
        Object obj = clazz.newInstance();
        method.invoke(obj, "jobs");
        
        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSON.parseObject(text);
    }
    
    public static class ExtClassLoader extends ClassLoader {
        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());
            
            byte[] bytes;
            InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/VO.clazz");
            bytes = IOUtils.toByteArray(is);
            is.close();
            
            super.defineClass("external.VO", bytes, 0, bytes.length);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_cc0428f_dee22f7/rev_cc0428f-dee22f7/src/test/java/com/alibaba/json/bvt/writeClassName/WriteClassNameTest_Set2.java;<<<<<<< MINE
        Assert.assertTrue(new ArrayList<B>(a1.getList()).get(0) instanceof B);
        Assert.assertTrue(new ArrayList<B>(a1.getList()).get(1) instanceof B1);
=======
        Assert.assertTrue("B", new ArrayList<B>(a1.getList()).get(0) instanceof B);
        Assert.assertTrue("B1", new ArrayList<B>(a1.getList()).get(1) instanceof B1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
                boolean isObjectKey = false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
                } else if (ch == '{' || ch == '[') {
                    lexer.nextToken();
                    key = parse();
                    isObjectKey = true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                lexer.incrementBufferPosition();
                lexer.skipWhitespace();
=======
                if (!isObjectKey) {
                    lexer.incrementBufferPosition();
                    lexer.skipWhitespace();
                }
                
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_4.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        JSON.parseObject(jsonString);
        
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/bug/Bug_for_NonStringKeyMap.java;<<<<<<< MINE
=======
    
    public void test_1() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/writeClassName/WriteClassNameTest_Set2.java;<<<<<<< MINE
        Assert.assertTrue("B", new ArrayList<B>(a1.getList()).get(0) instanceof B);
        Assert.assertTrue("B1", new ArrayList<B>(a1.getList()).get(1) instanceof B1);
=======
        Assert.assertTrue("B", new ArrayList<B>(a1.getList()).get(0) instanceof B || new ArrayList<B>(a1.getList()).get(0) instanceof B1);
        Assert.assertTrue("B1", new ArrayList<B>(a1.getList()).get(1) instanceof B || new ArrayList<B>(a1.getList()).get(1) instanceof B1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
                boolean isObjectKey = false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
                } else if (ch == '{' || ch == '[') {
                    lexer.nextToken();
                    key = parse();
                    isObjectKey = true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                lexer.incrementBufferPosition();
                lexer.skipWhitespace();
=======
                if (!isObjectKey) {
                    lexer.incrementBufferPosition();
                    lexer.skipWhitespace();
                }
                
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_4.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        JSON.parseObject(jsonString);
        
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_4 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }

    public void test_for_arrayKey() throws Exception {
        Map<List<String>, String> map = new HashMap<List<String>, String>();
        List<String> key = new ArrayList<String>();
        
        key.add("subkey");
        map.put(key, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/bug/Bug_for_NonStringKeyMap.java;<<<<<<< MINE
=======
    
    public void test_1() throws Exception {
        Map<Map<String, String>, String> map = new HashMap<Map<String, String>, String>();
        Map<String, String> submap = new HashMap<String, String>();
        submap.put("subkey", "subvalue");
        map.put(submap, "value");
        String jsonString = JSON.toJSONString(map, SerializerFeature.WriteClassName);
        System.out.println(jsonString);
        Object object = JSON.parse(jsonString);
        System.out.println(object.toString());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c528ef_eb32b05/rev_3c528ef-eb32b05/src/test/java/com/alibaba/json/bvt/writeClassName/WriteClassNameTest_Set2.java;<<<<<<< MINE
        Assert.assertTrue("B", new ArrayList<B>(a1.getList()).get(0) instanceof B);
        Assert.assertTrue("B1", new ArrayList<B>(a1.getList()).get(1) instanceof B1);
=======
        Assert.assertTrue("B", new ArrayList<B>(a1.getList()).get(0) instanceof B || new ArrayList<B>(a1.getList()).get(0) instanceof B1);
        Assert.assertTrue("B1", new ArrayList<B>(a1.getList()).get(1) instanceof B || new ArrayList<B>(a1.getList()).get(1) instanceof B1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                            refValue = this.getContext().getObject();
=======
                            if (this.getContext() != null) {
                                refValue = this.getContext().getObject();
                            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/parser/ProductViewTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser;

import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;


public class ProductViewTest extends TestCase {
    public void test_parse() throws Exception {
        String text = "{\"code\":0,\"message\":\"Register Successfully!\",\"status\":\"OK\"}";
        Map map = JSON.parseObject(text, Map.class);
        System.out.println(map.get("code").getClass());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/TestExternal4.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal4 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("external.VO2");
        Method method = clazz.getMethod("setName", new Class[] { String.class });
        Method methodSetValue = clazz.getMethod("setValue", new Class[] { Serializable.class });

        Object obj = clazz.newInstance();
        method.invoke(obj, "jobs");
        methodSetValue.invoke(obj, obj);

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "external.VO2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/VO2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("external.VO2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/TestExternal5.java;<<<<<<< MINE
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName, SerializerFeature.WriteMapNullValue);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvt/TestSerializable.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.Serializable;
import java.util.ArrayList;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class TestSerializable extends TestCase {
    public void test_codec() throws Exception {
        VO vo = new VO();
        vo.setValue(new ArrayList());
        
        JSON.toJSONString(vo);
    }

    public static class VO {

        private long         id;
        private Serializable value;

        public long getId() {
            return id;
        }

        public void setId(long id) {
            this.id = id;
        }

        public Serializable getValue() {
            return value;
        }

        public void setValue(Serializable value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c9ee9c5_b9da86b/rev_c9ee9c5-b9da86b/src/test/java/com/alibaba/json/bvtVO/ProductView.java;<<<<<<< MINE
=======
package com.alibaba.json.bvtVO;

public class ProductView {

    private Integer id;
    private String  keyword;
    private boolean hasProduct;
    private boolean hasCompany;
    private boolean hasBuyLead;
    private String  country;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getKeyword() {
        return keyword;
    }

    public void setKeyword(String keyword) {
        this.keyword = keyword;
    }

    public boolean isHasProduct() {
        return hasProduct;
    }

    public void setHasProduct(boolean hasProduct) {
        this.hasProduct = hasProduct;
    }

    public boolean isHasCompany() {
        return hasCompany;
    }

    public void setHasCompany(boolean hasCompany) {
        this.hasCompany = hasCompany;
    }

    public boolean isHasBuyLead() {
        return hasBuyLead;
    }

    public void setHasBuyLead(boolean hasBuyLead) {
        this.hasBuyLead = hasBuyLead;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                            refValue = this.getContext().getObject();
=======
                            if (this.getContext() != null) {
                                refValue = this.getContext().getObject();
                            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/parser/ProductViewTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser;

import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;


public class ProductViewTest extends TestCase {
    public void test_parse() throws Exception {
        String text = "{\"code\":0,\"message\":\"Register Successfully!\",\"status\":\"OK\"}";
        Map map = JSON.parseObject(text, Map.class);
        System.out.println(map.get("code").getClass());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/TestExternal4.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal4 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("external.VO2");
        Method method = clazz.getMethod("setName", new Class[] { String.class });
        Method methodSetValue = clazz.getMethod("setValue", new Class[] { Serializable.class });

        Object obj = clazz.newInstance();
        method.invoke(obj, "jobs");
        methodSetValue.invoke(obj, obj);

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "external.VO2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/VO2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("external.VO2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/TestExternal5.java;<<<<<<< MINE
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}=======
package com.alibaba.json.bvt;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class TestExternal5 extends TestCase {

    public void test_0() throws Exception {
        ExtClassLoader classLoader = new ExtClassLoader();
        Class<?> clazz = classLoader.loadClass("com.alibaba.dubbo.demo.MyEsbResultModel2");

        Object obj = clazz.newInstance();

        {
            String text = JSON.toJSONString(obj);
            System.out.println(text);
        }

        String text = JSON.toJSONString(obj, SerializerFeature.WriteClassName, SerializerFeature.WriteMapNullValue);
        System.out.println(text);
        JSON.parseObject(text, clazz);
        JSONObject jsonObj = JSON.parseObject(text);
        Assert.assertEquals(jsonObj.getString("@type"), "com.alibaba.dubbo.demo.MyEsbResultModel2");
    }

    public static class ExtClassLoader extends ClassLoader {

        public ExtClassLoader() throws IOException{
            super(Thread.currentThread().getContextClassLoader());

            {
                byte[] bytes;
                InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("external/MyEsbResultModel2.clazz");
                bytes = IOUtils.toByteArray(is);
                is.close();
                
                super.defineClass("com.alibaba.dubbo.demo.MyEsbResultModel2", bytes, 0, bytes.length);
            }
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvt/TestSerializable.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.io.Serializable;
import java.util.ArrayList;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class TestSerializable extends TestCase {
    public void test_codec() throws Exception {
        VO vo = new VO();
        vo.setValue(new ArrayList());
        
        JSON.toJSONString(vo);
    }

    public static class VO {

        private long         id;
        private Serializable value;

        public long getId() {
            return id;
        }

        public void setId(long id) {
            this.id = id;
        }

        public Serializable getValue() {
            return value;
        }

        public void setValue(Serializable value) {
            this.value = value;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_b9da86b_c9ee9c5/rev_b9da86b-c9ee9c5/src/test/java/com/alibaba/json/bvtVO/ProductView.java;<<<<<<< MINE
=======
package com.alibaba.json.bvtVO;

public class ProductView {

    private Integer id;
    private String  keyword;
    private boolean hasProduct;
    private boolean hasCompany;
    private boolean hasBuyLead;
    private String  country;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getKeyword() {
        return keyword;
    }

    public void setKeyword(String keyword) {
        this.keyword = keyword;
    }

    public boolean isHasProduct() {
        return hasProduct;
    }

    public void setHasProduct(boolean hasProduct) {
        this.hasProduct = hasProduct;
    }

    public boolean isHasCompany() {
        return hasCompany;
    }

    public void setHasCompany(boolean hasCompany) {
        this.hasCompany = hasCompany;
    }

    public boolean isHasBuyLead() {
        return hasBuyLead;
    }

    public void setHasBuyLead(boolean hasBuyLead) {
        this.hasBuyLead = hasBuyLead;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_24d779e_3a5c953/rev_24d779e-3a5c953/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultObjectDeserializer.java;<<<<<<< MINE
=======
                        if (lexer.token() == JSONToken.RBRACE) {
                            lexer.nextToken(JSONToken.COMMA);
                            return map;
                        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_24d779e_3a5c953/rev_24d779e-3a5c953/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_1.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.HashMap;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.TypeReference;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_1 extends TestCase {

    public void test_0() throws Exception {
        Map<String, User> matcherMap = new HashMap<String, User>();
        String matcherMapString = JSON.toJSONString(matcherMap, SerializerFeature.WriteClassName,
                                                    SerializerFeature.WriteMapNullValue);
        
        System.out.println(matcherMapString);
        
        matcherMap = JSONObject.parseObject(matcherMapString, new TypeReference<Map<String, User>>() {
        });
    }

    public static class User {

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                                getResolveTaskList().add(new ResolveTask(parentContext, ref));
=======
                                addResolveTask(new ResolveTask(parentContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                                getResolveTaskList().add(new ResolveTask(rootContext, ref));
=======
                                addResolveTask(new ResolveTask(rootContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                            getResolveTaskList().add(new ResolveTask(context, ref));
=======
                            addResolveTask(new ResolveTask(context, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
    
    public void addResolveTask(ResolveTask task) {
        resolveTaskList.add(task);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultObjectDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(parentContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(parentContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultObjectDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(rootContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(rootContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultObjectDeserializer.java;<<<<<<< MINE
                            parser.getResolveTaskList().add(new ResolveTask(context, ref));
=======
                            parser.addResolveTask(new ResolveTask(context, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(parentContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(parentContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(rootContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(rootContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                            parser.getResolveTaskList().add(new ResolveTask(context, ref));
=======
                            parser.addResolveTask(new ResolveTask(context, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/main/java/com/alibaba/fastjson/serializer/ListSerializer.java;<<<<<<< MINE
                            itemSerializer.write(serializer, item, end, elementType);
=======
                            itemSerializer.write(serializer, item, i, elementType);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/test/java/com/alibaba/json/bvt/bug/Bug_for_42283905.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.List;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class Bug_for_42283905 extends TestCase {

    public void test_0() throws Exception {

        String text;
        {
            List<Group> groups = new ArrayList<Group>();

            Command c0 = new Command(1);
            Command c1 = new Command(2);
            Command c2 = new Command(3);

            c1.setPre(c0);
            c2.setPre(c1);

            {
                Group group = new Group("g0");
                group.getBattleCommandList().add(c0);
                groups.add(group);
            }

            {
                Group group = new Group("g1");
                group.getBattleCommandList().add(c1);
                groups.add(group);
            }
            
            {
                Group group = new Group("g2");
                group.getBattleCommandList().add(c2);
                groups.add(group);
            }
            text = JSON.toJSONString(groups);
        }

        System.out.println(text);

        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {
        });
        Group g0 = groups.get(0);
        Group g1 = groups.get(1);

        System.out.println(JSON.toJSONString(groups));
    }

    public static class Group {

        private String        name;

        private List<Command> battleCommandList = new ArrayList<Command>();

        public Group(){

        }

        public Group(String name){
            this.name = name;
        }

        public List<Command> getBattleCommandList() {
            return battleCommandList;
        }

        public void setBattleCommandList(List<Command> battleCommandList) {
            this.battleCommandList = battleCommandList;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

    }

    public static class Command {

        private int id;

        public Command(){

        }

        public Command(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        private Command pre;

        public Command getPre() {
            return pre;
        }

        public void setPre(Command pre) {
            this.pre = pre;
        }

        public String toString() {
            return "{id:" + id + "}";
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/test/java/com/alibaba/json/bvt/bug/Bug_for_wuzhengmao.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}=======
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(1, result.get(0).getId());
        Assert.assertEquals(2, result.get(1).getId());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_05b31f7_708e701/rev_05b31f7-708e701/src/test/java/com/alibaba/json/bvt/ArrayRefTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.util.ArrayList;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class ArrayRefTest extends TestCase {

    public void test_0() throws Exception {
        String text;
        {
            List<Group> groups = new ArrayList<Group>();
            
            Group g0 = new Group(0);
            Group g1 = new Group(1);
            Group g2 = new Group(2);
            
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            
            text = JSON.toJSONString(groups);
        }
        
        System.out.println(text);
        
        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {});
        Assert.assertEquals(6, groups.size());
    }

    public static class Group {

        private int id;

        public Group(){

        }

        public Group(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }
        
        public String toString() {
            return "{id:" + id + "}";
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                                getResolveTaskList().add(new ResolveTask(parentContext, ref));
=======
                                addResolveTask(new ResolveTask(parentContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                                getResolveTaskList().add(new ResolveTask(rootContext, ref));
=======
                                addResolveTask(new ResolveTask(rootContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                            getResolveTaskList().add(new ResolveTask(context, ref));
=======
                            addResolveTask(new ResolveTask(context, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
    
    public void addResolveTask(ResolveTask task) {
        resolveTaskList.add(task);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultObjectDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(parentContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(parentContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultObjectDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(rootContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(rootContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultObjectDeserializer.java;<<<<<<< MINE
                            parser.getResolveTaskList().add(new ResolveTask(context, ref));
=======
                            parser.addResolveTask(new ResolveTask(context, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(parentContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(parentContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                                parser.getResolveTaskList().add(new ResolveTask(rootContext, ref));
=======
                                parser.addResolveTask(new ResolveTask(rootContext, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                            parser.getResolveTaskList().add(new ResolveTask(context, ref));
=======
                            parser.addResolveTask(new ResolveTask(context, ref));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/main/java/com/alibaba/fastjson/serializer/ListSerializer.java;<<<<<<< MINE
                            itemSerializer.write(serializer, item, end, elementType);
=======
                            itemSerializer.write(serializer, item, i, elementType);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/test/java/com/alibaba/json/bvt/bug/Bug_for_42283905.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.ArrayList;
import java.util.List;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class Bug_for_42283905 extends TestCase {

    public void test_0() throws Exception {

        String text;
        {
            List<Group> groups = new ArrayList<Group>();

            Command c0 = new Command(1);
            Command c1 = new Command(2);
            Command c2 = new Command(3);

            c1.setPre(c0);
            c2.setPre(c1);

            {
                Group group = new Group("g0");
                group.getBattleCommandList().add(c0);
                groups.add(group);
            }

            {
                Group group = new Group("g1");
                group.getBattleCommandList().add(c1);
                groups.add(group);
            }
            
            {
                Group group = new Group("g2");
                group.getBattleCommandList().add(c2);
                groups.add(group);
            }
            text = JSON.toJSONString(groups);
        }

        System.out.println(text);

        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {
        });
        Group g0 = groups.get(0);
        Group g1 = groups.get(1);

        System.out.println(JSON.toJSONString(groups));
    }

    public static class Group {

        private String        name;

        private List<Command> battleCommandList = new ArrayList<Command>();

        public Group(){

        }

        public Group(String name){
            this.name = name;
        }

        public List<Command> getBattleCommandList() {
            return battleCommandList;
        }

        public void setBattleCommandList(List<Command> battleCommandList) {
            this.battleCommandList = battleCommandList;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

    }

    public static class Command {

        private int id;

        public Command(){

        }

        public Command(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        private Command pre;

        public Command getPre() {
            return pre;
        }

        public void setPre(Command pre) {
            this.pre = pre;
        }

        public String toString() {
            return "{id:" + id + "}";
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/test/java/com/alibaba/json/bvt/bug/Bug_for_wuzhengmao.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(1, result.get(0).getId());
        Assert.assertEquals(2, result.get(1).getId());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}=======
package com.alibaba.json.bvt.bug;

import java.util.Arrays;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_wuzhengmao extends TestCase {

    public void test_0() throws Exception {
        Node node1 = new Node();
        node1.setId(1);
        Node node2 = new Node();
        node2.setId(2);
        node1.setParent(node2);
        List<Node> list = Arrays.asList(new Node[] { node1, node2 });
        String json = JSON.toJSONString(list, true);
        System.out.println(json);
        List<Node> result = JSON.parseArray(json, Node.class);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(result.get(0).getParent(), result.get(1));
    }

    static class Node {

        int  id;
        Node parent;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public Node getParent() {
            return parent;
        }

        public void setParent(Node parent) {
            this.parent = parent;
        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_708e701_05b31f7/rev_708e701-05b31f7/src/test/java/com/alibaba/json/bvt/ArrayRefTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt;

import java.util.ArrayList;
import java.util.List;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

public class ArrayRefTest extends TestCase {

    public void test_0() throws Exception {
        String text;
        {
            List<Group> groups = new ArrayList<Group>();
            
            Group g0 = new Group(0);
            Group g1 = new Group(1);
            Group g2 = new Group(2);
            
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            groups.add(g0);
            groups.add(g1);
            groups.add(g2);
            
            text = JSON.toJSONString(groups);
        }
        
        System.out.println(text);
        
        List<Group> groups = JSON.parseObject(text, new TypeReference<List<Group>>() {});
        Assert.assertEquals(6, groups.size());
    }

    public static class Group {

        private int id;

        public Group(){

        }

        public Group(int id){
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }
        
        public String toString() {
            return "{id:" + id + "}";
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
import static com.alibaba.fastjson.parser.JSONToken.EOF;
import static com.alibaba.fastjson.parser.JSONToken.FALSE;
import static com.alibaba.fastjson.parser.JSONToken.LBRACE;
import static com.alibaba.fastjson.parser.JSONToken.LBRACKET;
import static com.alibaba.fastjson.parser.JSONToken.LITERAL_FLOAT;
import static com.alibaba.fastjson.parser.JSONToken.LITERAL_INT;
import static com.alibaba.fastjson.parser.JSONToken.LITERAL_STRING;
import static com.alibaba.fastjson.parser.JSONToken.NEW;
import static com.alibaba.fastjson.parser.JSONToken.NULL;
import static com.alibaba.fastjson.parser.JSONToken.RBRACKET;
import static com.alibaba.fastjson.parser.JSONToken.SET;
import static com.alibaba.fastjson.parser.JSONToken.TREE_SET;
import static com.alibaba.fastjson.parser.JSONToken.TRUE;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
import java.util.Date;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
import java.util.TreeSet;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    protected final JSONLexer          lexer;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    public final static int            NONE              = 0;
    public final static int            NeedToResolve     = 1;
    public final static int            TypeNameRedirect  = 2;
=======
    private DefaultObjectDeserializer  derializer        = new DefaultObjectDeserializer();

    private final static Set<Class<?>> primitiveClasses  = new HashSet<Class<?>>();

    private String                     dateFormatPattern = JSON.DEFFAULT_DATE_FORMAT;
    private DateFormat                 dateFormat;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    private int                        resolveStatus     = NONE;
=======
    protected final JSONLexer          lexer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    private DefaultObjectDeserializer  derializer        = new DefaultObjectDeserializer();
    private ParseContext               context;
=======
    protected ParseContext             context;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    private final static Set<Class<?>> primitiveClasses  = new HashSet<Class<?>>();
=======
    public final static int            NONE              = 0;
    public final static int            NeedToResolve     = 1;
    public final static int            TypeNameRedirect  = 2;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    private String                     dateFormatPattern = JSON.DEFFAULT_DATE_FORMAT;
    private DateFormat                 dateFormat;

    public Object getObject(String path) {
        for (int i = 0; i < contextArrayIndex; ++i) {
            if (path.equals(contextArray[i].getPath())) {
                return contextArray[i].getObject();
            }
        }

        return null;
    }
=======
    private int                        resolveStatus     = NONE;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
        this.lexer = lexer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
        this.lexer = lexer;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    public int getResolveStatus() {
        return resolveStatus;
    }

    public void setResolveStatus(int resolveStatus) {
        this.resolveStatus = resolveStatus;
    }

    @SuppressWarnings("rawtypes")
    public void checkListResolve(Collection array) {
        if (resolveStatus == NeedToResolve) {
            final int index = array.size() - 1;
            final List list = (List) array;
            ResolveTask task = getLastResolveTask();
            task.setFieldDeserializer(new ListResolveFieldDeserializer(list, index));
            task.setOwnerContext(context);
            setResolveStatus(DefaultJSONParser.NONE);
        }
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    public JSONLexer getLexer() {
        return lexer;
    }

    public boolean isEnabled(Feature feature) {
        return lexer.isEnabled(feature);
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
                    
                    this.resolveStatus = TypeNameRedirect;
=======

                    this.setResolveStatus(TypeNameRedirect);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======

                    this.setContext(object, fieldName);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
    public ParseContext getContext() {
        return context;
    }

    public List<ResolveTask> getResolveTaskList() {
        return resolveTaskList;
    }
    
    public void addResolveTask(ResolveTask task) {
        resolveTaskList.add(task);
    }

    public ResolveTask getLastResolveTask() {
        return resolveTaskList.get(resolveTaskList.size() - 1);
    }

    public void setContext(ParseContext context) {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return;
        }
        this.context = context;
    }

    public void popContext() {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return;
        }

        this.context = this.context.getParentContext();
    }

    public ParseContext setContext(Object object, Object fieldName) {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return null;
        }

        return setContext(this.context, object, fieldName);
    }

    public ParseContext setContext(ParseContext parent, Object object, Object fieldName) {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return null;
        }

        if (lexer.isResetFlag()) {
            for (int i = 0; i < contextArrayIndex; ++i) {
                ParseContext item = contextArray[i];
                if (item.getParentContext() == parent && item.getFieldName() == fieldName) {
                    this.context = item;
                    this.context.setObject(object);
                    clearChildContext(this.context, i + 1);
                    break;
                }
            }
            lexer.setResetFlag(false);
        } else {
            this.context = new ParseContext(parent, object, fieldName);
            addContext(this.context);
        }
        return this.context;
    }

    private void clearChildContext(ParseContext parent, int start) {
        for (int i = start; i < contextArrayIndex; ++i) {
            ParseContext item = contextArray[i];
            if (item.getParentContext() == parent) {
                int end = contextArrayIndex - 1;
                if (i != end) {
                    System.arraycopy(contextArray, i + 1, contextArray, i, end - i);
                }
                contextArray[end] = null;
                contextArrayIndex--;

                clearChildContext(item, i + 1);
            }
        }
    }

    private void addContext(ParseContext context) {
        int i = contextArrayIndex++;
        if (i >= contextArray.length) {
            int newLen = (contextArray.length * 3) / 2;
            ParseContext[] newArray = new ParseContext[newLen];
            System.arraycopy(contextArray, 0, newArray, 0, contextArray.length);
            contextArray = newArray;
        }
        contextArray[i] = context;
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
    public int getResolveStatus() {
        return resolveStatus;
    }

    public void setResolveStatus(int resolveStatus) {
        this.resolveStatus = resolveStatus;
    }

    public Object getObject(String path) {
        for (int i = 0; i < contextArrayIndex; ++i) {
            if (path.equals(contextArray[i].getPath())) {
                return contextArray[i].getObject();
            }
        }

        return null;
    }

    @SuppressWarnings("rawtypes")
    public void checkListResolve(Collection array) {
        if (resolveStatus == NeedToResolve) {
            final int index = array.size() - 1;
            final List list = (List) array;
            ResolveTask task = getLastResolveTask();
            task.setFieldDeserializer(new ListResolveFieldDeserializer(this, list, index));
            task.setOwnerContext(context);
            setResolveStatus(DefaultJSONParser.NONE);
        }
    }

    @SuppressWarnings("rawtypes")
    public Object parseObject(final Map object) {
        return parseObject(object, null);
    }

    public JSONObject parseObject() {
        JSONObject object = new JSONObject();
        parseObject(object);
        return object;
    }

    @SuppressWarnings("rawtypes")
    public final void parseArray(final Collection array) {
        parseArray(array, null);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public final void parseArray(final Collection array, Object fieldName) {
        final JSONLexer lexer = getLexer();

        if (lexer.token() == JSONToken.SET || lexer.token() == JSONToken.TREE_SET) {
            lexer.nextToken();
        }

        if (lexer.token() != JSONToken.LBRACKET) {
            throw new JSONException("syntax error, expect [, actual " + JSONToken.name(lexer.token()));
        }

        lexer.nextToken(JSONToken.LITERAL_STRING);

        this.setContext(array, fieldName);
        try {
            for (int i = 0;; ++i) {
                if (isEnabled(Feature.AllowArbitraryCommas)) {
                    while (lexer.token() == JSONToken.COMMA) {
                        lexer.nextToken();
                        continue;
                    }
                }

                Object value;
                switch (lexer.token()) {
                    case LITERAL_INT:
                        value = lexer.integerValue();
                        lexer.nextToken(JSONToken.COMMA);
                        break;
                    case LITERAL_FLOAT:
                        if (lexer.isEnabled(Feature.UseBigDecimal)) {
                            value = lexer.decimalValue(true);
                        } else {
                            value = lexer.decimalValue(false);
                        }
                        lexer.nextToken(JSONToken.COMMA);
                        break;
                    case LITERAL_STRING:
                        String stringLiteral = lexer.stringVal();
                        lexer.nextToken(JSONToken.COMMA);

                        if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {
                            JSONScanner iso8601Lexer = new JSONScanner(stringLiteral);
                            if (iso8601Lexer.scanISO8601DateIfMatch()) {
                                value = iso8601Lexer.getCalendar().getTime();
                            } else {
                                value = stringLiteral;
                            }
                        } else {
                            value = stringLiteral;
                        }

                        break;
                    case TRUE:
                        value = Boolean.TRUE;
                        lexer.nextToken(JSONToken.COMMA);
                        break;
                    case FALSE:
                        value = Boolean.FALSE;
                        lexer.nextToken(JSONToken.COMMA);
                        break;
                    case LBRACE:
                        JSONObject object = new JSONObject();
                        value = parseObject(object, i);
                        break;
                    case LBRACKET:
                        Collection items = new JSONArray();
                        parseArray(items, i);
                        value = items;
                        break;
                    case NULL:
                        value = null;
                        lexer.nextToken(JSONToken.LITERAL_STRING);
                        break;
                    case RBRACKET:
                        lexer.nextToken(JSONToken.COMMA);
                        return;
                    default:
                        value = parse();
                        break;
                }

                array.add(value);
                checkListResolve(array);

                if (lexer.token() == JSONToken.COMMA) {
                    lexer.nextToken(JSONToken.LITERAL_STRING);
                    continue;
                }
            }
        } finally {
            this.popContext();
        }
    }

    public ParseContext getContext() {
        return context;
    }

    public List<ResolveTask> getResolveTaskList() {
        return resolveTaskList;
    }

    public void addResolveTask(ResolveTask task) {
        resolveTaskList.add(task);
    }

    public ResolveTask getLastResolveTask() {
        return resolveTaskList.get(resolveTaskList.size() - 1);
    }

    public void setContext(ParseContext context) {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return;
        }
        this.context = context;
    }

    public void popContext() {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return;
        }

        this.context = this.context.getParentContext();
    }

    public ParseContext setContext(Object object, Object fieldName) {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return null;
        }

        return setContext(this.context, object, fieldName);
    }

    public ParseContext setContext(ParseContext parent, Object object, Object fieldName) {
        if (isEnabled(Feature.DisableCircularReferenceDetect)) {
            return null;
        }

        if (lexer.isResetFlag()) {
            for (int i = 0; i < contextArrayIndex; ++i) {
                ParseContext item = contextArray[i];
                if (item.getParentContext() == parent && item.getFieldName() == fieldName) {
                    this.context = item;
                    this.context.setObject(object);
                    clearChildContext(this.context, i + 1);
                    break;
                }
            }
            lexer.setResetFlag(false);
        } else {
            this.context = new ParseContext(parent, object, fieldName);
            addContext(this.context);
        }
        return this.context;
    }

    private void clearChildContext(ParseContext parent, int start) {
        for (int i = start; i < contextArrayIndex; ++i) {
            ParseContext item = contextArray[i];
            if (item.getParentContext() == parent) {
                int end = contextArrayIndex - 1;
                if (i != end) {
                    System.arraycopy(contextArray, i + 1, contextArray, i, end - i);
                }
                contextArray[end] = null;
                contextArrayIndex--;

                clearChildContext(item, i + 1);
            }
        }
    }

    private void addContext(ParseContext context) {
        int i = contextArrayIndex++;
        if (i >= contextArray.length) {
            int newLen = (contextArray.length * 3) / 2;
            ParseContext[] newArray = new ParseContext[newLen];
            System.arraycopy(contextArray, 0, newArray, 0, contextArray.length);
            contextArray = newArray;
        }
        contextArray[i] = context;
    }

    public Object parse() {
        return parse(null);
    }

    public Object parse(Object fieldName) {
        final JSONLexer lexer = getLexer();
        switch (lexer.token()) {
            case SET:
                lexer.nextToken();
                HashSet<Object> set = new HashSet<Object>();
                parseArray(set, fieldName);
                return set;
            case TREE_SET:
                lexer.nextToken();
                TreeSet<Object> treeSet = new TreeSet<Object>();
                parseArray(treeSet, fieldName);
                return treeSet;
            case LBRACKET:
                JSONArray array = new JSONArray();
                parseArray(array, fieldName);
                return array;
            case LBRACE:
                JSONObject object = new JSONObject();
                return parseObject(object, fieldName);
            case LITERAL_INT:
                Number intValue = lexer.integerValue();
                lexer.nextToken();
                return intValue;
            case LITERAL_FLOAT:
                Object value = lexer.decimalValue(isEnabled(Feature.UseBigDecimal));
                lexer.nextToken();
                return value;
            case LITERAL_STRING:
                String stringLiteral = lexer.stringVal();
                lexer.nextToken(JSONToken.COMMA);

                if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {
                    JSONScanner iso8601Lexer = new JSONScanner(stringLiteral);
                    if (iso8601Lexer.scanISO8601DateIfMatch()) {
                        return iso8601Lexer.getCalendar().getTime();
                    }
                }

                return stringLiteral;
            case NULL:
                lexer.nextToken();
                return null;
            case TRUE:
                lexer.nextToken();
                return Boolean.TRUE;
            case FALSE:
                lexer.nextToken();
                return Boolean.FALSE;
            case NEW:
                lexer.nextToken(JSONToken.IDENTIFIER);

                if (lexer.token() != JSONToken.IDENTIFIER) {
                    throw new JSONException("syntax error");
                }
                lexer.nextToken(JSONToken.LPAREN);

                accept(JSONToken.LPAREN);
                long time = ((Number) lexer.integerValue()).longValue();
                accept(JSONToken.LITERAL_INT);

                accept(JSONToken.RPAREN);

                return new Date(time);
            case EOF:
                if (lexer.isBlankInput()) {
                    return null;
                }
            default:
                throw new JSONException("TODO " + lexer.tokenName() + " " + lexer.stringVal());
        }
    }

    public void config(Feature feature, boolean state) {
        getLexer().config(feature, state);
    }

    public boolean isEnabled(Feature feature) {
        return getLexer().isEnabled(feature);
    }

    public JSONLexer getLexer() {
        return lexer;
    }

    public final void accept(final int token) {
        final JSONLexer lexer = getLexer();
        if (lexer.token() == token) {
            lexer.nextToken();
        } else {
            throw new JSONException("syntax error, expect " + JSONToken.name(token) + ", actual "
                                    + JSONToken.name(lexer.token()));
        }
    }

    public void close() {
        final JSONLexer lexer = getLexer();

        if (isEnabled(Feature.AutoCloseSource)) {
            if (!lexer.isEOF()) {
                throw new JSONException("not close json text, token : " + JSONToken.name(lexer.token()));
            }
        }
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/AbstractJSONParser.java;<<<<<<< MINE
import static com.alibaba.fastjson.parser.JSONToken.EOF;
import static com.alibaba.fastjson.parser.JSONToken.FALSE;
import static com.alibaba.fastjson.parser.JSONToken.LBRACE;
import static com.alibaba.fastjson.parser.JSONToken.LBRACKET;
import static com.alibaba.fastjson.parser.JSONToken.LITERAL_FLOAT;
import static com.alibaba.fastjson.parser.JSONToken.LITERAL_INT;
import static com.alibaba.fastjson.parser.JSONToken.LITERAL_STRING;
import static com.alibaba.fastjson.parser.JSONToken.NEW;
import static com.alibaba.fastjson.parser.JSONToken.NULL;
import static com.alibaba.fastjson.parser.JSONToken.RBRACKET;
import static com.alibaba.fastjson.parser.JSONToken.SET;
import static com.alibaba.fastjson.parser.JSONToken.TREE_SET;
import static com.alibaba.fastjson.parser.JSONToken.TRUE;

import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.TreeSet;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONException;
import com.alibaba.fastjson.JSONObject;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/AbstractJSONParser.java;<<<<<<< MINE
    @SuppressWarnings("rawtypes")
    public Object parseObject(final Map object) {
        return parseObject(object, null);
    }

    @SuppressWarnings("rawtypes")
    public abstract Object parseObject(final Map object, Object fieldName);
    
    @SuppressWarnings("rawtypes")
    public abstract void checkListResolve(Collection array);

    public JSONObject parseObject() {
        JSONObject object = new JSONObject();
        parseObject(object);
        return object;
    }
    
    @SuppressWarnings("rawtypes")
    public final void parseArray(final Collection array) {
        parseArray(array, null);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public final void parseArray(final Collection array, Object fieldName) {
        final JSONLexer lexer = getLexer();
        
        if (lexer.token() == JSONToken.SET || lexer.token() == JSONToken.TREE_SET) {
            lexer.nextToken();
        }

        if (lexer.token() != JSONToken.LBRACKET) {
            throw new JSONException("syntax error, expect [, actual " + JSONToken.name(lexer.token()));
        }

        lexer.nextToken(JSONToken.LITERAL_STRING);

        for (;;) {
            if (isEnabled(Feature.AllowArbitraryCommas)) {
                while (lexer.token() == JSONToken.COMMA) {
                    lexer.nextToken();
                    continue;
                }
            }

            Object value;
            switch (lexer.token()) {
                case LITERAL_INT:
                    value = lexer.integerValue();
                    lexer.nextToken(JSONToken.COMMA);
                    break;
                case LITERAL_FLOAT:
                    if (lexer.isEnabled(Feature.UseBigDecimal)) {
                        value = lexer.decimalValue(true);
                    } else {
                        value = lexer.decimalValue(false);
                    }
                    lexer.nextToken(JSONToken.COMMA);
                    break;
                case LITERAL_STRING:
                    String stringLiteral = lexer.stringVal();
                    lexer.nextToken(JSONToken.COMMA);

                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {
                        JSONScanner iso8601Lexer = new JSONScanner(stringLiteral);
                        if (iso8601Lexer.scanISO8601DateIfMatch()) {
                            value = iso8601Lexer.getCalendar().getTime();
                        } else {
                            value = stringLiteral;
                        }
                    } else {
                        value = stringLiteral;
                    }

                    break;
                case TRUE:
                    value = Boolean.TRUE;
                    lexer.nextToken(JSONToken.COMMA);
                    break;
                case FALSE:
                    value = Boolean.FALSE;
                    lexer.nextToken(JSONToken.COMMA);
                    break;
                case LBRACE:
                    JSONObject object = new JSONObject();
                    value = parseObject(object);
                    break;
                case LBRACKET:
                    Collection items = new JSONArray();
                    parseArray(items);
                    value = items;
                    break;
                case NULL:
                    value = null;
                    lexer.nextToken(JSONToken.LITERAL_STRING);
                    break;
                case RBRACKET:
                    lexer.nextToken(JSONToken.COMMA);
                    return;
                default:
                    value = parse();
                    break;
            }

            array.add(value);
            checkListResolve(array);

            if (lexer.token() == JSONToken.COMMA) {
                lexer.nextToken(JSONToken.LITERAL_STRING);
                continue;
            }
        }
    }

    public Object parse() {
        return parse(null);
    }

    public Object parse(Object fieldName) {
        final JSONLexer lexer = getLexer();
        switch (lexer.token()) {
            case SET:
                lexer.nextToken();
                HashSet<Object> set = new HashSet<Object>();
                parseArray(set, fieldName);
                return set;
            case TREE_SET:
                lexer.nextToken();
                TreeSet<Object> treeSet = new TreeSet<Object>();
                parseArray(treeSet, fieldName);
                return treeSet;
            case LBRACKET:
                JSONArray array = new JSONArray();
                parseArray(array, fieldName);
                return array;
            case LBRACE:
                JSONObject object = new JSONObject();
                return parseObject(object, fieldName);
            case LITERAL_INT:
                Number intValue = lexer.integerValue();
                lexer.nextToken();
                return intValue;
            case LITERAL_FLOAT:
                Object value = lexer.decimalValue(isEnabled(Feature.UseBigDecimal));
                lexer.nextToken();
                return value;
            case LITERAL_STRING:
                String stringLiteral = lexer.stringVal();
                lexer.nextToken(JSONToken.COMMA);

                if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {
                    JSONScanner iso8601Lexer = new JSONScanner(stringLiteral);
                    if (iso8601Lexer.scanISO8601DateIfMatch()) {
                        return iso8601Lexer.getCalendar().getTime();
                    }
                }

                return stringLiteral;
            case NULL:
                lexer.nextToken();
                return null;
            case TRUE:
                lexer.nextToken();
                return Boolean.TRUE;
            case FALSE:
                lexer.nextToken();
                return Boolean.FALSE;
            case NEW:
                lexer.nextToken(JSONToken.IDENTIFIER);

                if (lexer.token() != JSONToken.IDENTIFIER) {
                    throw new JSONException("syntax error");
                }
                lexer.nextToken(JSONToken.LPAREN);

                accept(JSONToken.LPAREN);
                long time = ((Number) lexer.integerValue()).longValue();
                accept(JSONToken.LITERAL_INT);

                accept(JSONToken.RPAREN);

                return new Date(time);
            case EOF:
                if (lexer.isBlankInput()) {
                    return null;
                }
            default:
                throw new JSONException("TODO " + lexer.tokenName() + " " + lexer.stringVal());
        }
    }

    public void config(Feature feature, boolean state) {
        getLexer().config(feature, state);
    }

    public boolean isEnabled(Feature feature) {
        return getLexer().isEnabled(feature);
    }

    public abstract JSONLexer getLexer();

    public final void accept(final int token) {
        final JSONLexer lexer = getLexer();
        if (lexer.token() == token) {
            lexer.nextToken();
        } else {
            throw new JSONException("syntax error, expect " + JSONToken.name(token) + ", actual "
                                    + JSONToken.name(lexer.token()));
        }
    }

    public void close() {
        final JSONLexer lexer = getLexer();

        if (isEnabled(Feature.AutoCloseSource)) {
            if (!lexer.isEOF()) {
                throw new JSONException("not close json text, token : " + JSONToken.name(lexer.token()));
            }
        }
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/deserializer/ListResolveFieldDeserializer.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.JSONArray;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/deserializer/ListResolveFieldDeserializer.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.util.TypeUtils;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/deserializer/ListResolveFieldDeserializer.java;<<<<<<< MINE
    private final int  index;
    private final List list;
=======
    private final int               index;
    private final List              list;
    private final DefaultJSONParser parser;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/deserializer/ListResolveFieldDeserializer.java;<<<<<<< MINE
    public ListResolveFieldDeserializer(List list, int index){
=======
    public ListResolveFieldDeserializer(DefaultJSONParser parser, List list, int index){
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/deserializer/ListResolveFieldDeserializer.java;<<<<<<< MINE
=======
        this.parser = parser;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/parser/deserializer/ListResolveFieldDeserializer.java;<<<<<<< MINE

        if (list instanceof JSONArray) {
            JSONArray jsonArray = (JSONArray) list;
            Object array = jsonArray.getRelatedArray();
            int arrayLength = Array.getLength(array);
            
            if (array != null && arrayLength > index) {
                Object item;
                if (jsonArray.getComponentType() != null) {
                    item = TypeUtils.cast(value, jsonArray.getComponentType(), parser.getConfig());
                } else {
                    item = value;
                }
                Array.set(array, index, item);
            }
        }
    }

    public DefaultJSONParser getParser() {
        return parser;
=======

        if (list instanceof JSONArray) {
            JSONArray jsonArray = (JSONArray) list;
            Object[] array = jsonArray.getRelatedArray();
            if (array != null && array.length > index) {
                if (jsonArray.getComponentType() != null) {
                    array[index] = TypeUtils.cast(value, jsonArray.getComponentType(), parser.getConfig());
                } else {
                    array[index] = value;
                }
            }
        }
    }

    public DefaultJSONParser getParser() {
        return parser;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSON.java;<<<<<<< MINE
    public static <T> void handleResovleTask(DefaultJSONParser parser, T value) {
=======
    public static <T> int handleResovleTask(DefaultJSONParser parser, T value) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSON.java;<<<<<<< MINE
            return;
=======
            return 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSON.java;<<<<<<< MINE
=======
        
        return size;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSONArray.java;<<<<<<< MINE
=======
import java.lang.reflect.Type;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSONArray.java;<<<<<<< MINE
    private static final long    serialVersionUID = 1L;
    private final List<Object>   list;
    protected transient Object relatedArray;
    protected transient Type     componentType;
=======
    private static final long    serialVersionUID = 1L;
    private final List<Object>   list;
    protected transient Object[] relatedArray;
    protected transient Type     componentType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSONArray.java;<<<<<<< MINE
    /**
     * @since 1.1.16
     * @return
     */
    public Object getRelatedArray() {
        return relatedArray;
    }

    public void setRelatedArray(Object relatedArray) {
        this.relatedArray = relatedArray;
    }

    public Type getComponentType() {
        return componentType;
    }

    public void setComponentType(Type componentType) {
        this.componentType = componentType;
    }

=======
    /**
     * @since 1.1.16
     * @return
     */
    public Object[] getRelatedArray() {
        return relatedArray;
    }

    public void setRelatedArray(Object[] relatedArray) {
        this.relatedArray = relatedArray;
    }

    public Type getComponentType() {
        return componentType;
    }

    public void setComponentType(Type componentType) {
        this.componentType = componentType;
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSONArray.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/main/java/com/alibaba/fastjson/JSONArray.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_5df25cb_ebe948a/rev_5df25cb-ebe948a/src/test/java/com/alibaba/json/bvt/ArrayRefTest.java;<<<<<<< MINE
=======
        
        Assert.assertEquals(0, groups.get(0).getId());
        Assert.assertEquals(1, groups.get(1).getId());
        Assert.assertEquals(2, groups.get(2).getId());
        Assert.assertEquals(0, groups.get(3).getId());
        Assert.assertEquals(1, groups.get(4).getId());
        Assert.assertEquals(2, groups.get(5).getId());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/TimestampDeserializer.java;<<<<<<< MINE
public class TimestampDeserializer implements ObjectDeserializer {
=======
public class TimestampDeserializer extends AbstractDateDeserializer implements ObjectDeserializer {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/TimestampDeserializer.java;<<<<<<< MINE
    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {
        Object val = parser.parse();
        
=======
    protected <T> T cast(DefaultJSONParser parser, Type clazz, Object fieldName, Object val) {

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/TimestampDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/AbstractDateDeserializer.java;<<<<<<< MINE
package com.alibaba.fastjson.parser.deserializer;

import java.lang.reflect.Type;

import com.alibaba.fastjson.JSONException;
import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.JSONScanner;
import com.alibaba.fastjson.parser.JSONToken;

public abstract class AbstractDateDeserializer implements ObjectDeserializer {

    @SuppressWarnings("unchecked")
    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {
        Object val;
        if (parser.getResolveStatus() == DefaultJSONParser.TypeNameRedirect) {
            parser.accept(JSONToken.COMMA);

            JSONScanner lexer = (JSONScanner) parser.getLexer();
            if (lexer.token() == JSONToken.LITERAL_STRING) {
                if (!"val".equals(lexer.stringVal())) {
                    throw new JSONException("syntax error");
                }
                lexer.nextToken();
            } else {
                throw new JSONException("syntax error");
            }

            parser.accept(JSONToken.COLON);

            val = parser.parse();

            parser.accept(JSONToken.RBRACE);

            parser.setResolveStatus(DefaultJSONParser.NONE);
        } else {
            val = parser.parse();
        }
        
        return (T) cast(parser, clazz, fieldName, val);
    }

    protected abstract <T> T cast(DefaultJSONParser parser, Type clazz, Object fieldName, Object value);
}=======
package com.alibaba.fastjson.parser.deserializer;

import java.lang.reflect.Type;

import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.JSONScanner;
import com.alibaba.fastjson.parser.JSONToken;
import com.google.gson.JsonParseException;

public abstract class AbstractDateDeserializer implements ObjectDeserializer {

    @SuppressWarnings("unchecked")
    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {
        Object val;
        if (parser.getResolveStatus() == DefaultJSONParser.TypeNameRedirect) {
            parser.accept(JSONToken.COMMA);

            JSONScanner lexer = (JSONScanner) parser.getLexer();
            if (lexer.token() == JSONToken.LITERAL_STRING) {
                if (!"val".equals(lexer.stringVal())) {
                    throw new JsonParseException("syntax error");
                }
                lexer.nextToken();
            } else {
                throw new JsonParseException("syntax error");
            }

            parser.accept(JSONToken.COLON);

            val = parser.parse();

            parser.accept(JSONToken.RBRACE);

            parser.setResolveStatus(DefaultJSONParser.NONE);
        } else {
            val = parser.parse();
        }
        
        return (T) cast(parser, clazz, fieldName, val);
    }

    protected abstract <T> T cast(DefaultJSONParser parser, Type clazz, Object fieldName, Object value);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
public class SqlDateDeserializer implements ObjectDeserializer {
=======
public class SqlDateDeserializer extends AbstractDateDeserializer implements ObjectDeserializer {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/SqlDateDeserializer.java;<<<<<<< MINE
    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {
        final JSONScanner lexer = (JSONScanner) parser.getLexer();

        if (lexer.token() == JSONToken.NULL) {
            lexer.nextToken(JSONToken.COMMA);
            return null;
        }

        if (lexer.token() == JSONToken.COMMA) {
            String key = lexer.scanSymbol(parser.getSymbolTable());

            if ("val" != key) {
                throw new JSONException("syntax error");
            }

            lexer.nextTokenWithColon(JSONToken.LITERAL_INT);

            if (lexer.token() != JSONToken.LITERAL_INT) {
                throw new JSONException("syntax error");
            }

            long val = lexer.longValue();

            lexer.nextToken(JSONToken.RBRACE);

            if (lexer.token() != JSONToken.RBRACE) {
                throw new JSONException("syntax error");
            }
            lexer.nextToken(JSONToken.COMMA);

            return (T) new java.sql.Date(val);
        }

        Object val = parser.parse();
=======
    protected <T> T cast(DefaultJSONParser parser, Type clazz, Object fieldName, Object val) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/DateDeserializer.java;<<<<<<< MINE
public class DateDeserializer implements ObjectDeserializer {
=======
public class DateDeserializer extends AbstractDateDeserializer implements ObjectDeserializer {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/DateDeserializer.java;<<<<<<< MINE
    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {
        Object val = parser.parse();
=======
    protected <T> T cast(DefaultJSONParser parser, Type clazz, Object fieldName, Object val) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/DateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/DateDeserializer.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/main/java/com/alibaba/fastjson/parser/deserializer/DateDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_62c589a_2c88690/rev_62c589a-2c88690/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_6.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_6 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("id", 1);
        map.put("name", "leno.lix");
        map.put("birthday", new Date());
        map.put("gmtCreate", new java.sql.Date(new Date().getTime()));
        map.put("gmtModified", new java.sql.Timestamp(new Date().getTime()));

        String userJSON = JSON.toJSONString(map, SerializerFeature.WriteClassName,
                SerializerFeature.WriteMapNullValue);
        
        System.out.println(userJSON);

        Object object = JSON.parse(userJSON);
        
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_12d54d2_7f38646/rev_12d54d2-7f38646/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.parser.deserializer.MapResolveFieldDeserializer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_12d54d2_7f38646/rev_12d54d2-7f38646/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java;<<<<<<< MINE
=======
            this(context, referenceValue, null, null);
        }

        public ResolveTask(ParseContext context, String referenceValue, ParseContext ownerContext,
                           FieldDeserializer fieldDeserializer){
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_12d54d2_7f38646/rev_12d54d2-7f38646/src/main/java/com/alibaba/fastjson/parser/deserializer/MapResolveFieldDeserializer.java;<<<<<<< MINE
=======
package com.alibaba.fastjson.parser.deserializer;

import java.lang.reflect.Type;
import java.util.Map;

import com.alibaba.fastjson.parser.DefaultJSONParser;

@SuppressWarnings("rawtypes")
public final class MapResolveFieldDeserializer extends FieldDeserializer {

    private final String              key;
    private final Map map;

    public MapResolveFieldDeserializer(Map map, String index){
        super(null, null);
        this.key = index;
        this.map = map;
    }

    @SuppressWarnings("unchecked")
    public void setValue(Object object, Object value) {
        map.put(key, value);
    }


    @Override
    public void parseField(DefaultJSONParser parser, Object object, Type objectType, Map<String, Object> fieldValues) {

    }

    @Override
    public int getFastMatchToken() {
        return 0;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_12d54d2_7f38646/rev_12d54d2-7f38646/src/test/java/com/alibaba/json/bvt/bug/Bug_for_lenolix_9.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import java.util.HashMap;
import java.util.Map;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_9 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<String, Object> submap4 = new HashMap<String, Object>();
        Address address = new Address();
        address.setCity("hangzhou");
        address.setStreet("wangshang.RD");
        address.setPostCode(310002);
        submap4.put("address1", address);
        submap4.put("address2", address);

        String mapString4 = JSON.toJSONString(submap4, SerializerFeature.WriteClassName,
                                              SerializerFeature.WriteMapNullValue);
        
        System.out.println(mapString4);
        Object object4 = JSON.parse(mapString4);
        Assert.assertNotNull(object4);
        
        Map<String, Object> map = (Map<String, Object>) object4;
        
        Assert.assertNotNull(map.get("address1"));
        Assert.assertNotNull(map.get("address2"));

    }

    public static class Address {

        private String city;
        private String street;
        private int postCode;

        public String getCity() {
            return city;
        }

        public void setCity(String city) {
            this.city = city;
        }

        public String getStreet() {
            return street;
        }

        public void setStreet(String street) {
            this.street = street;
        }

        public int getPostCode() {
            return postCode;
        }

        public void setPostCode(int postCode) {
            this.postCode = postCode;
        }

    }
}=======
package com.alibaba.json.bvt.bug;

import java.util.HashMap;
import java.util.Map;

import junit.framework.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class Bug_for_lenolix_9 extends TestCase {

    public void test_for_objectKey() throws Exception {
        Map<String, Object> submap4 = new HashMap<String, Object>();
        Address address = new Address();
        address.setCity("hangzhou");
        address.setStreet("wangshang.RD");
        address.setPostCode(310002);
        submap4.put("address1", address);
        submap4.put("address2", address);

        String mapString4 = JSON.toJSONString(submap4, SerializerFeature.WriteClassName,
                                              SerializerFeature.WriteMapNullValue);
        
        System.out.println(mapString4);
        Object object4 = JSON.parse(mapString4);
        Assert.assertNotNull(object4);

    }

    public static class Address {

        private String city;
        private String street;
        private int postCode;

        public String getCity() {
            return city;
        }

        public void setCity(String city) {
            this.city = city;
        }

        public String getStreet() {
            return street;
        }

        public void setStreet(String street) {
            this.street = street;
        }

        public int getPostCode() {
            return postCode;
        }

        public void setPostCode(int postCode) {
            this.postCode = postCode;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_f0023bb_e4033fb/rev_f0023bb-e4033fb/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java;<<<<<<< MINE
     * Get the {@link HystrixCommandMetrics} instance for a given {@link HystrixCommandKey}.
=======
     * Get or create the {@link HystrixCommandMetrics} instance for a given {@link HystrixCommandKey}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_f0023bb_e4033fb/rev_f0023bb-e4033fb/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java;<<<<<<< MINE
=======
    /**
     * Get the {@link HystrixCommandMetrics} instance for a given {@link HystrixCommandKey} or null if one does not exist.
     * 
     * @param key
     *            {@link HystrixCommandKey} of {@link HystrixCommand} instance requesting the {@link HystrixCommandMetrics}
     * @return {@link HystrixCommandMetrics}
     */
    public static HystrixCommandMetrics getInstance(HystrixCommandKey key) {
        return metrics.get(key.name());
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_f0023bb_e4033fb/rev_f0023bb-e4033fb/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java;<<<<<<< MINE
=======
import java.util.concurrent.ThreadFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_f0023bb_e4033fb/rev_f0023bb-e4033fb/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java;<<<<<<< MINE
=======
import java.util.concurrent.atomic.AtomicInteger;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_f0023bb_e4033fb/rev_f0023bb-e4033fb/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java;<<<<<<< MINE
    public ThreadPoolExecutor getThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixProperty<Integer> corePoolSize, HystrixProperty<Integer> maximumPoolSize, HystrixProperty<Integer> keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        return new ThreadPoolExecutor(corePoolSize.get(), maximumPoolSize.get(), keepAliveTime.get(), unit, workQueue);
=======
    public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixProperty<Integer> corePoolSize, HystrixProperty<Integer> maximumPoolSize, HystrixProperty<Integer> keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        return new ThreadPoolExecutor(corePoolSize.get(), maximumPoolSize.get(), keepAliveTime.get(), unit, workQueue, new ThreadFactory() {

            protected final AtomicInteger threadNumber = new AtomicInteger(0);

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "hystrix-" + threadPoolKey.name() + "-" + threadNumber.incrementAndGet());
            }
        });
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/annotation/JSONType.java;<<<<<<< MINE
=======
    boolean asm() default true;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        } else if (propertyClass == List.class) {
=======
        } else if (propertyClass == List.class || propertyClass == ArrayList.class) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        } else if (propertyClass == List.class) {
=======
        } else if (propertyClass == List.class || propertyClass == ArrayList.class) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        } else if (propertyClass == List.class) {
=======
        } else if (propertyClass == List.class || propertyClass == ArrayList.class) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/SerializeConfig.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.annotation.JSONType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/SerializeConfig.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/SerializeConfig.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/SerializeConfig.java;<<<<<<< MINE
=======
        
        {
            JSONType annotation = clazz.getAnnotation(JSONType.class);
            if (annotation != null && annotation.asm() == false) {
                asm = false;
            }
        }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/SerializeConfig.java;<<<<<<< MINE
                throw new JSONException("create asm serilizer error, class " + clazz, e);
=======
                throw new JSONException("create asm serializer error, class " + clazz, e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/main/java/com/alibaba/fastjson/serializer/SerializeConfig.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/test/java/com/alibaba/json/bvt/bug/Bug_for_hmy8.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.json.bvtVO.IEvent;
import com.alibaba.json.bvtVO.IEventDto;

public class Bug_for_hmy8 extends TestCase {

    public void test_ser() throws Exception {
        IEventDto dto = new IEventDto();
        dto.getEventList().add(new IEvent());
        
        JSON.toJSONString(dto);
    }
}=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.json.bvtVO.IEventDto;

public class Bug_for_hmy8 extends TestCase {

    public void test_ser() throws Exception {
        IEventDto dto = new IEventDto();
        
        JSON.toJSONString(dto);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/test/java/com/alibaba/json/bvtVO/IEventDto.java;<<<<<<< MINE
/**
 * Project: eve.services
 * 
 * File Created at 2011-12-21
 * $Id$
 * 
 * Copyright 2008 Alibaba.com Corporation Limited.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Alibaba Company. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Alibaba.com.
 */
package com.alibaba.json.bvtVO;

import java.io.Serializable;
import java.util.ArrayList;

/**
 * @author wb_jianhui.shijh
 */
public class IEventDto implements Serializable {

    private static final long serialVersionUID = -3903138261314727539L;

    private String            source;

    private ArrayList<IEvent> eventList = new ArrayList<IEvent>();

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }
    
    public ArrayList<IEvent> getEventList() {
        return eventList;
    }

    public void setEventList(ArrayList<IEvent> eventList) {
        this.eventList = eventList;
    }

    @Override
    public String toString() {
        return "IEventDto [source=" + source + ", eventList=" + eventList + "]";
    }

}=======
/**
 * Project: eve.services
 * 
 * File Created at 2011-12-21
 * $Id$
 * 
 * Copyright 2008 Alibaba.com Corporation Limited.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Alibaba Company. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Alibaba.com.
 */
package com.alibaba.json.bvtVO;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * @author wb_jianhui.shijh
 */
public class IEventDto implements Serializable {

    private static final long serialVersionUID = -3903138261314727539L;

    private String            source;

    private ArrayList<IEvent> eventList;

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }
    
    public ArrayList<IEvent> getEventList() {
        return eventList;
    }

    public void setEventList(ArrayList<IEvent> eventList) {
        this.eventList = eventList;
    }

    @Override
    public String toString() {
        return "IEventDto [source=" + source + ", eventList=" + eventList + "]";
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ad6d97a_055aab7/rev_ad6d97a-055aab7/src/test/java/com/alibaba/json/bvtVO/IEvent.java;<<<<<<< MINE
=======
/**
 * Project: eve.services
 * 
 * File Created at 2011-12-21
 * $Id$
 * 
 * Copyright 2008 Alibaba.com Corporation Limited.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Alibaba Company. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Alibaba.com.
 */
package com.alibaba.json.bvtVO;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.Map;

/**
 * 
 * 
 * @author wb_jianhui.shijh
 */
public class IEvent implements Serializable {

    private static final long   serialVersionUID = -791431935700654454L;

    /**
     * 
     */
    private String              name;

    /**
     * 
     */
    private String              source;

    /**
     * 
     */
    private Map<String, Object> detailData;

    /**
     * 
     */
    private Timestamp           generateTime;

    /**
     * ID.
     */
    private String              externalId;

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public Map<String, Object> getDetailData() {
        return detailData;
    }

    public void setDetailData(Map<String, Object> detailData) {
        this.detailData = detailData;
    }

    public Timestamp getGenerateTime() {
        return generateTime;
    }

    public void setGenerateTime(Timestamp generateTime) {
        this.generateTime = generateTime;
    }

    @Override
    public String toString() {
        return "IEvent [name=" + name + ", source=" + source + ", externalId=" + externalId
                + ", generateTime=" + generateTime + ", detailData=" + detailData + "]";
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2e86b72_08eba4b/rev_2e86b72-08eba4b/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        mw.visitTypeInsn(CHECKCAST, getType(property.getFieldClass())); // cast
=======
        mw.visitTypeInsn(CHECKCAST, getType(List.class)); // cast
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2e86b72_08eba4b/rev_2e86b72-08eba4b/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        mw.visitMethodInsn(INVOKEINTERFACE, getType(property.getFieldClass()), "size", "()I");
=======
        mw.visitMethodInsn(INVOKEINTERFACE, getType(List.class), "size", "()I");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2e86b72_08eba4b/rev_2e86b72-08eba4b/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                mw.visitMethodInsn(INVOKEINTERFACE, getType(property.getFieldClass()), "get", "(I)Ljava/lang/Object;");
=======
                mw.visitMethodInsn(INVOKEINTERFACE, getType(List.class), "get", "(I)Ljava/lang/Object;");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2e86b72_08eba4b/rev_2e86b72-08eba4b/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                mw.visitMethodInsn(INVOKEINTERFACE, getType(property.getFieldClass()), "get", "(I)Ljava/lang/Object;");
=======
                mw.visitMethodInsn(INVOKEINTERFACE, getType(List.class), "get", "(I)Ljava/lang/Object;");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2e86b72_08eba4b/rev_2e86b72-08eba4b/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                mw.visitMethodInsn(INVOKEINTERFACE, getType(property.getFieldClass()), "get", "(I)Ljava/lang/Object;");
=======
                mw.visitMethodInsn(INVOKEINTERFACE, getType(List.class), "get", "(I)Ljava/lang/Object;");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2e86b72_08eba4b/rev_2e86b72-08eba4b/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                mw.visitMethodInsn(INVOKEINTERFACE, getType(property.getFieldClass()), "get", "(I)Ljava/lang/Object;");
=======
                mw.visitMethodInsn(INVOKEINTERFACE, getType(List.class), "get", "(I)Ljava/lang/Object;");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2e86b72_08eba4b/rev_2e86b72-08eba4b/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        } else if (propertyClass == List.class || propertyClass == ArrayList.class) {
=======
        } else if (List.class.isAssignableFrom(propertyClass)) {
        	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
=======
            {
                FieldVisitor fw = cw.visitField(ACC_PUBLIC, fieldInfo.getName() + "_asm_fieldPrefix",
                                                "Ljava/lang/reflect/Type;");
                fw.visitEnd();
            }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            mw.visitVarInsn(ALOAD, context.serializer());
            mw.visitVarInsn(ALOAD, context.paramFieldType());
            mw.visitVarInsn(ALOAD, context.obj());
            mw.visitMethodInsn(INVOKEVIRTUAL, getType(JSONSerializer.class), "isWriteClassName",
                               "(Ljava/lang/reflect/Type;Ljava/lang/Object;)Z");
=======
            mw.visitVarInsn(ALOAD, context.var("out"));
            mw.visitFieldInsn(GETSTATIC, getType(SerializerFeature.class), "WriteClassName",
                              "L" + getType(SerializerFeature.class) + ";");
            mw.visitMethodInsn(INVOKEVIRTUAL, getType(SerializeWriter.class), "isEnabled",
                               "(" + "L" + getType(SerializerFeature.class) + ";" + ")Z");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            // mw.visitVarInsn(ALOAD, context.var("out"));
            // mw.visitFieldInsn(GETSTATIC, getType(SerializerFeature.class), "WriteClassName",
            // "L" + getType(SerializerFeature.class) + ";");
            // mw.visitMethodInsn(INVOKEVIRTUAL, getType(SerializeWriter.class), "isEnabled",
            // "(" + "L" + getType(SerializerFeature.class) + ";" + ")Z");
            // mw.visitJumpInsn(IFEQ, else_);

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                mw.visitFieldInsn(GETFIELD, context.getClassName(), fieldInfo.getName() + "_asm_fieldType", "Ljava/lang/reflect/Type;");
=======
                mw.visitFieldInsn(GETFIELD, context.getClassName(), fieldInfo.getName() + "_asm_fieldType",
                                  "Ljava/lang/reflect/Type;");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
=======
        writeStringWithDoubleQuote(text, seperator, true);
    }

    private void writeStringWithDoubleQuote(String text, final char seperator, boolean checkSpecial) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        for (int i = start; i < end; ++i) {
            char ch = buf[i];
=======
        if (checkSpecial) {
            for (int i = start; i < end; ++i) {
                char ch = buf[i];
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            if (ch < CharTypes.specicalFlags_doubleQuotes.length
                && CharTypes.specicalFlags_doubleQuotes[ch] //
                || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                specialCount++;
                lastSpecialIndex = i;
                lastSpecial = ch;
=======
                if (ch < CharTypes.specicalFlags_doubleQuotes.length
                    && CharTypes.specicalFlags_doubleQuotes[ch] //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                    specialCount++;
                    lastSpecialIndex = i;
                    lastSpecial = ch;
                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        int specialCount = 0;
        int lastSpecialIndex = -1;
        char lastSpecial = '\0';
        for (int i = nameStart; i < nameEnd; ++i) {
            char ch = buf[i];
            if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                || ch == '"' //
                || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                specialCount++;
                lastSpecialIndex = i;
                lastSpecial = ch;
            }
        }

        if (specialCount > 0) {
            newcount += specialCount;
            if (newcount > buf.length) {
                expandCapacity(newcount);
            }
            count = newcount;
        }

        if (specialCount == 1) {
            System.arraycopy(buf, lastSpecialIndex + 1, buf, lastSpecialIndex + 2, nameEnd - lastSpecialIndex - 1);
            buf[lastSpecialIndex] = '\\';
            buf[++lastSpecialIndex] = replaceChars[(int) lastSpecial];
            nameEnd++;
        } else if (specialCount > 1) {
            System.arraycopy(buf, lastSpecialIndex + 1, buf, lastSpecialIndex + 2, nameEnd - lastSpecialIndex - 1);
            buf[lastSpecialIndex] = '\\';
            buf[++lastSpecialIndex] = replaceChars[(int) lastSpecial];
            nameEnd++;
            for (int i = lastSpecialIndex - 2; i >= nameStart; --i) {
                char ch = buf[i];

                if (ch == '\b' || ch == '\n' || ch == '\r' || ch == '\f' || ch == '\\'
                    || ch == '"' //
                    || (ch == '\t' && isEnabled(SerializerFeature.WriteTabAsSpecial))
                    || (ch == '/' && isEnabled(SerializerFeature.WriteSlashAsSpecial))) {
                    System.arraycopy(buf, i + 1, buf, i + 2, nameEnd - i - 1);
                    buf[i] = '\\';
                    buf[i + 1] = replaceChars[(int) ch];
                    nameEnd++;
                }
            }
        }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        specialCount = 0;
        lastSpecialIndex = -1;
        lastSpecial = '\0';
=======
        int specialCount = 0;
        int lastSpecialIndex = -1;
        char lastSpecial = '\0';
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
=======
            if (ch >= 'a') {
                continue;
            }
            
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java;<<<<<<< MINE
            writeFieldValue(seperator, name, value.name());
=======
            if (isEnabled(SerializerFeature.UseSingleQuotes)) {
                writeFieldValue(seperator, name, value.name());    
            } else {
                write(seperator);
                writeFieldName(name);
                writeStringWithDoubleQuote(value.name(), (char) 0, false);
                return;    
            }
            
            //writeStringWithDoubleQuote
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/test/java/com/alibaba/json/test/benchmark/encode/EishayEncode.java;<<<<<<< MINE
        String text = codec.encode(mediaContent);
=======
        String text = codec.encode(mediaContent.media);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_55afa54_bd49960/rev_55afa54-bd49960/src/test/java/com/alibaba/json/test/benchmark/BenchmarkTest.java;<<<<<<< MINE
//        executor.getCodecList().add(new JacksonCodec());
=======
        executor.getCodecList().add(new JacksonCodec());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            if (propertyClass.isPrimitive()) {
                continue;
            } else if (propertyClass == String.class) {
                continue;
            } else if (propertyClass == BigDecimal.class) {
                continue;
            } else if (List.class.isAssignableFrom(propertyClass)) {
                continue;
            } else if (propertyClass.isEnum()) {
                continue;
            }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            Class<?> propertyClass = fieldInfo.getFieldClass();

            if (propertyClass.isPrimitive()) {
                continue;
            } else if (propertyClass == String.class) {
                continue;
            } else if (propertyClass == BigDecimal.class) {
                continue;
            } else if (List.class.isAssignableFrom(propertyClass)) {
                continue;
            } else if (propertyClass.isEnum()) {
                continue;
            }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            mw.visitVarInsn(ALOAD, context.var("out"));
            mw.visitFieldInsn(GETSTATIC, getType(SerializerFeature.class), "WriteClassName",
                              "L" + getType(SerializerFeature.class) + ";");
            mw.visitMethodInsn(INVOKEVIRTUAL, getType(SerializeWriter.class), "isEnabled",
                               "(" + "L" + getType(SerializerFeature.class) + ";" + ")Z");
=======
//            mw.visitVarInsn(ALOAD, context.var("out"));
//            mw.visitFieldInsn(GETSTATIC, getType(SerializerFeature.class), "WriteClassName",
//                              "L" + getType(SerializerFeature.class) + ";");
//            mw.visitMethodInsn(INVOKEVIRTUAL, getType(SerializeWriter.class), "isEnabled",
//                               "(" + "L" + getType(SerializerFeature.class) + ";" + ")Z");
//            mw.visitJumpInsn(IFEQ, else_);
            
            mw.visitVarInsn(ALOAD, context.serializer());
            mw.visitVarInsn(ALOAD, context.paramFieldType());
            mw.visitVarInsn(ALOAD, context.obj());
            mw.visitMethodInsn(INVOKEVIRTUAL, getType(JSONSerializer.class), "isWriteClassName",
                               "(Ljava/lang/reflect/Type;Ljava/lang/Object;)Z");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/JavaBeanSerializer.java;<<<<<<< MINE
            getters = this.getters;
=======
            getters = this.sortedGetters;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/JavaBeanSerializer.java;<<<<<<< MINE
            getters = this.sortedGetters;    
=======
            getters = this.getters;    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/test/java/com/alibaba/json/bvt/serializer/SerializeWriterTest_3.java;<<<<<<< MINE
    public void test_2() throws Exception {
        SerializeWriter out = new SerializeWriter(1);
        out.config(SerializerFeature.QuoteFieldNames, true);
        out.config(SerializerFeature.WriteTabAsSpecial, true);
        out.writeFieldValue(',', "\t\n \b\n\r\f\\ \"", "jobs");
        Assert.assertEquals(",\"\\t\\n \\b\\n\\r\\f\\\\ \\\"\":\"jobs\"", out.toString());
    }
    
    public void test_3() throws Exception {
        SerializeWriter out = new SerializeWriter(1);
        out.config(SerializerFeature.QuoteFieldNames, true);
        out.config(SerializerFeature.WriteTabAsSpecial, false);
        out.writeFieldValue(',', "\t\n \b\n\r\f\\ \"", "jobs");
        Assert.assertEquals(",\"\t\\n \\b\\n\\r\\f\\\\ \\\"\":\"jobs\"", out.toString());
    }
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/test/java/com/alibaba/json/bvt/serializer/SerializeWriterTest_4.java;<<<<<<< MINE
        out.writeFieldValue(',', "\tname", "\t");
        Assert.assertEquals(",\"\\tname\":\"\\t\"", out.toString());
=======
        out.writeFieldValue(',', "name", "\t");
        Assert.assertEquals(",\"name\":\"\\t\"", out.toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            if (propertyClass.isPrimitive()) {
                continue;
            } else if (propertyClass == String.class) {
                continue;
            } else if (propertyClass == BigDecimal.class) {
                continue;
            } else if (List.class.isAssignableFrom(propertyClass)) {
                continue;
            } else if (propertyClass.isEnum()) {
                continue;
            }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            Class<?> propertyClass = fieldInfo.getFieldClass();

            if (propertyClass.isPrimitive()) {
                continue;
            } else if (propertyClass == String.class) {
                continue;
            } else if (propertyClass == BigDecimal.class) {
                continue;
            } else if (List.class.isAssignableFrom(propertyClass)) {
                continue;
            } else if (propertyClass.isEnum()) {
                continue;
            }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            mw.visitVarInsn(ALOAD, context.var("out"));
            mw.visitFieldInsn(GETSTATIC, getType(SerializerFeature.class), "WriteClassName",
                              "L" + getType(SerializerFeature.class) + ";");
            mw.visitMethodInsn(INVOKEVIRTUAL, getType(SerializeWriter.class), "isEnabled",
                               "(" + "L" + getType(SerializerFeature.class) + ";" + ")Z");
=======
//            mw.visitVarInsn(ALOAD, context.var("out"));
//            mw.visitFieldInsn(GETSTATIC, getType(SerializerFeature.class), "WriteClassName",
//                              "L" + getType(SerializerFeature.class) + ";");
//            mw.visitMethodInsn(INVOKEVIRTUAL, getType(SerializeWriter.class), "isEnabled",
//                               "(" + "L" + getType(SerializerFeature.class) + ";" + ")Z");
//            mw.visitJumpInsn(IFEQ, else_);
            
            mw.visitVarInsn(ALOAD, context.serializer());
            mw.visitVarInsn(ALOAD, context.paramFieldType());
            mw.visitVarInsn(ALOAD, context.obj());
            mw.visitMethodInsn(INVOKEVIRTUAL, getType(JSONSerializer.class), "isWriteClassName",
                               "(Ljava/lang/reflect/Type;Ljava/lang/Object;)Z");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/JavaBeanSerializer.java;<<<<<<< MINE
            getters = this.getters;
=======
            getters = this.sortedGetters;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/main/java/com/alibaba/fastjson/serializer/JavaBeanSerializer.java;<<<<<<< MINE
            getters = this.sortedGetters;    
=======
            getters = this.getters;    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/test/java/com/alibaba/json/bvt/serializer/SerializeWriterTest_3.java;<<<<<<< MINE
    public void test_2() throws Exception {
        SerializeWriter out = new SerializeWriter(1);
        out.config(SerializerFeature.QuoteFieldNames, true);
        out.config(SerializerFeature.WriteTabAsSpecial, true);
        out.writeFieldValue(',', "\t\n \b\n\r\f\\ \"", "jobs");
        Assert.assertEquals(",\"\\t\\n \\b\\n\\r\\f\\\\ \\\"\":\"jobs\"", out.toString());
    }
    
    public void test_3() throws Exception {
        SerializeWriter out = new SerializeWriter(1);
        out.config(SerializerFeature.QuoteFieldNames, true);
        out.config(SerializerFeature.WriteTabAsSpecial, false);
        out.writeFieldValue(',', "\t\n \b\n\r\f\\ \"", "jobs");
        Assert.assertEquals(",\"\t\\n \\b\\n\\r\\f\\\\ \\\"\":\"jobs\"", out.toString());
    }
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_ec0a424_5a2f7c9/rev_ec0a424-5a2f7c9/src/test/java/com/alibaba/json/bvt/serializer/SerializeWriterTest_4.java;<<<<<<< MINE
        out.writeFieldValue(',', "\tname", "\t");
        Assert.assertEquals(",\"\\tname\":\"\\t\"", out.toString());
=======
        out.writeFieldValue(',', "name", "\t");
        Assert.assertEquals(",\"name\":\"\\t\"", out.toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3d572a0_90ae5a9/rev_3d572a0-90ae5a9/src/main/java/com/alibaba/fastjson/util/TypeUtils.java;<<<<<<< MINE
=======
                } else if (methodName.length()>=5 && Character.isUpperCase(methodName.charAt(4))){
                    propertyName = Introspector.decapitalize(methodName.substring(3));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.util.ASMUtils;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java;<<<<<<< MINE
        return text.substring(offset, offset + count);
=======
        if (ASMUtils.isAndroid()) {
            char[] chars = new char[count];
            for (int i = offset; i < offset + count; ++i) {
                chars[i - offset] = text.charAt(i);
            }
            return new String(chars);
        } else {
            return text.substring(offset, offset + count);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java;<<<<<<< MINE
        return text.substring(np, np + sp);
        // return new String(buf, np, sp);
=======
        // return text.substring(np, np + sp);
        return this.subString(np, sp);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/SymbolTable.java;<<<<<<< MINE
                return buffer.substring(offset, offset + len);
                // return new String(buffer, offset, len);
=======
                // return buffer.substring(offset, offset + len);
                return subString(buffer, offset, len);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/SymbolTable.java;<<<<<<< MINE
            // return new String(buffer, offset, len);
            return buffer.substring(offset, offset + len);
=======
            // return buffer.substring(offset, offset + len);
            return subString(buffer, offset, len);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/SymbolTable.java;<<<<<<< MINE
=======
    
    private static String subString(String src, int offset, int len) {
        char[] chars = new char[len];
        for (int i = offset; i < offset + len; ++i) {
            chars[i - offset] = src.charAt(i);
        }
        return new String(chars);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/SymbolTable.java;<<<<<<< MINE
            symbol = text.substring(offset, offset + length).intern();
=======
            // symbol = text.substring(offset, offset + length).intern();
            symbol = subString(text, offset, length).intern();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/deserializer/FieldDeserializer.java;<<<<<<< MINE
=======
                    if (value == null && fieldInfo.getFieldClass().isPrimitive()) {
                        return;
                    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
=======
        if (type == JSON.class || type == JSONObject.class) {
            return (T) parser.parse();
        }
        
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/JSON.java;<<<<<<< MINE
    // =======
    public final static String VERSION = "1.1.46";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/util/TypeUtils.java;<<<<<<< MINE
            if ("true".equals(str)) {
=======
            if ("true".equalsIgnoreCase(strVal)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/util/TypeUtils.java;<<<<<<< MINE
            if ("false".equals(str)) {
=======
            if ("false".equalsIgnoreCase(strVal)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/util/TypeUtils.java;<<<<<<< MINE
            if ("1".equals(str)) {
=======
            if ("1".equals(strVal)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/main/java/com/alibaba/fastjson/util/TypeUtils.java;<<<<<<< MINE
            if ("0".equals(str)) {
=======
            if ("0".equals(strVal)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_int.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_int extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private int value;

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_short.java;<<<<<<< MINE
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_short extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private short value;

        public short getValue() {
            return value;
        }

        public void setValue(short value) {
            throw new UnsupportedOperationException();
        }

    }
}=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_short extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }

    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }

    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private short value;

        public short getValue() {
            return value;
        }

        public void setValue(short value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_float.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_float extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private float value;

        public float getValue() {
            return value;
        }

        public void setValue(float value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_long.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_long extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private long value;

        public long getValue() {
            return value;
        }

        public void setValue(long value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_byte.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_byte extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private byte value;

        public byte getValue() {
            return value;
        }

        public void setValue(byte value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_json_array.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_json_array extends TestCase {

    public void test_bug() throws Exception {
        String jsonStr = "{\"state\":0,\"data\":[{\"items\":[{\"tip\":\"\u5218\u82e5\u82f1\",\"url\":\"xiami:\\/\\/artist\\/1930\"},{\"tip\":\"\u5218\u5fb7\u534e\",\"url\":\"xiami:\\/\\/artist\\/648\"}],\"type\":\"artist\"},{\"items\":[{\"tip\":\"\u6f02\u6d0b\u8fc7\u6d77\u6765\u770b\u4f60 (Live) - \u5218\u660e\u6e58\",\"url\":\"xiami:\\/\\/song\\/1773431302\"},{\"tip\":\"\\u6211\\u4eec\\u6ca1\\u6709\\u5728\\u4e00\\u8d77 - \\u5218\\u82e5\\u82f1\",\"url\":\"xiami:\\/\\/song\\/1769471863\"},{\"tip\":\"\\u54ed\u7802 (Live)(\\u5218\\u660e\\u6e58\\u80dc\\u51fa) - \\u5218\u660e\u6e58\",\"url\":\"xiami:\\/\\/ song\\/1773484887\"}],\"type\":\"song\"},{\"items\":[{\"tip\":\"\\u4eb2\\u7231\\u7684\\u8def\\u4eba - \\u5218\\u82e5\\u82f1\",\"url\":\"xiami:\\/\\/album\\/55230\"},{\"tip\":\"\\u5728\\u4e00\\u8d77 - \\u5218\\u82e5\\u82f1\",\"url\":\"xiami:\\/\\/album\\/377241\"}],\"type\":\"album\"}],\"status\":\"ok\",\"err\":null} ";

        Parser parser = JSON.parseObject(jsonStr, Parser.class);

        System.out.println(JSON.toJSONString(parser));
    }

    public static class Parser {

        public int    state;
        public JSON   data;
        public String status;
        public String err;

        public int getState() {
            return state;
        }

        public void setState(int state) {
            this.state = state;
        }

        public JSON getData() {
            return data;
        }

        public void setData(JSON data) {
            this.data = data;
        }

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }

        public String getErr() {
            return err;
        }

        public void setErr(String err) {
            this.err = err;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_boolean.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_boolean extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private boolean value;

        public boolean getValue() {
            return value;
        }

        public void setValue(boolean value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_69f677f_8af0afb/rev_69f677f-8af0afb/src/test/java/com/alibaba/json/bvt/bug/Bug_for_primitive_double.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Bug_for_primitive_double extends TestCase {

    public void test_emptyStr() throws Exception {
        JSON.parseObject("{\"value\":\"\"}", VO.class);
    }
    
    public void test_null() throws Exception {
        JSON.parseObject("{\"value\":null}", VO.class);
    }
    
    public void test_strNull() throws Exception {
        JSON.parseObject("{\"value\":\"null\"}", VO.class);
    }

    public static class VO {

        private double value;

        public double getValue() {
            return value;
        }

        public void setValue(double value) {
            throw new UnsupportedOperationException();
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_a3e83d9_441164d/rev_a3e83d9-441164d/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java;<<<<<<< MINE

    public final char doNext() {
=======
    public final char doNext() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_a3e83d9_441164d/rev_a3e83d9-441164d/src/main/java/com/alibaba/fastjson/parser/JSONReaderScanner.java;<<<<<<< MINE


    public final char doNext() {
=======
    public final char next() {
        ch = doNext();
        if (ch == '/' && isEnabled(Feature.AllowComment)) {
            skipComment();
        }
        return ch;
    }

    public final char doNext() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_a3e83d9_441164d/rev_a3e83d9-441164d/src/test/java/com/alibaba/json/bvt/parser/JSONLexerAllowCommentTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.parser;

import java.io.IOException;
import java.io.InputStream;

import junit.framework.TestCase;

import org.apache.commons.io.IOUtils;
import org.junit.Assert;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.JSONReaderScanner;

public class JSONLexerAllowCommentTest extends TestCase {
    public void test_0() throws Exception {
        
        String jsonWithComment = "{ /*tes****\n\r\n*t*/\"a\":1 /*****test88888*****/ /*test*/ , /*test*/ //test\n //est\n \"b\":2}";
        JSONObject object = JSON.parseObject(jsonWithComment, Feature.AllowComment);
        System.out.println(object.toJSONString());
        Assert.assertEquals("{\"b\":2,\"a\":1}",object.toJSONString());

        DefaultJSONParser parser = new DefaultJSONParser(new JSONReaderScanner(jsonWithComment,
            Feature.AllowComment.getMask()));
        JSONObject object1 = parser.parseObject();
        Assert.assertEquals("{\"b\":2,\"a\":1}",object1.toJSONString());
        System.out.println(object1.toJSONString());

    }

    public void test_1() throws IOException {
        String resource = "json/json_with_comment.json";
        InputStream is = Thread.currentThread().getContextClassLoader()
            .getResourceAsStream(resource);
        String text = IOUtils.toString(is);
        is.close();

        JSONObject object = JSON.parseObject(text, Feature.AllowComment);
        System.out.println(object.toJSONString());

        Assert
            .assertEquals(
                "{\"hello\":\"asafsadf\",\"test\":1,\"object\":{\"teset\":1000},\"array\":[\"10000sfsaf\",100,{\"nihao\":{\"test\":\"sdfasdf\"}}]}",
                object.toJSONString());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
=======
import java.io.BufferedReader;
import java.io.BufferedWriter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
=======
import java.io.InputStreamReader;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
=======
import java.io.OutputStreamWriter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
=======
import com.alibaba.fastjson.JSONException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
import com.alibaba.fastjson.util.IOUtils;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
    private Class<?>[] clazzes = null;
=======
   
	// default charset
	private String DEFAULT_CHARSET = "UTF-8";

	private String charset = DEFAULT_CHARSET;
	 
	private Class<?>[] clazzes = null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
=======
    /**
     * Set charset. the default charset is UTF-8
     */
    public FastJsonProvider(String charset) {
    	this.charset = charset;
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
=======
        
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
            entityStream.write(jsonStr.getBytes());
=======
        	
        	this.outputStreamWriteString(entityStream, jsonStr);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
            input = IOUtils.toString(entityStream);
=======
            input = this.inputStreamReadString(entityStream);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/jaxrs/FastJsonProvider.java;<<<<<<< MINE
=======
    /**
     * Method that inputStream read String with charset.
     */
    private String inputStreamReadString(InputStream in) {
		
		StringBuffer buffer = new StringBuffer();

		BufferedReader br;
		
		try {
			br = new BufferedReader(new InputStreamReader(in, charset));
			
			String line;
			
			while ((line = br.readLine()) != null) {
			
				buffer.append(line);
			}
			
		} catch (Exception ex) {
			 throw new JSONException("read string from reader error", ex);
		}
		
		return buffer.toString();
	}
    
    /**
     * Method that outputStream write String with charset.
     */
    private void outputStreamWriteString(OutputStream out, String str) {
    	
    	BufferedWriter bw;
    	
		try {
			bw = new BufferedWriter(new OutputStreamWriter(out, charset));
			
			bw.write(str);
			
			bw.flush();
			
		} catch (Exception ex) {
			 throw new JSONException("write string to writer error", ex);
		}
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
=======
import java.lang.reflect.Type;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
=======
import org.springframework.http.converter.GenericHttpMessageConverter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
public class FastJsonHttpMessageConverter extends AbstractHttpMessageConverter<Object> {
=======
public class FastJsonHttpMessageConverter extends AbstractHttpMessageConverter<Object> implements GenericHttpMessageConverter<Object> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_3c07047_40cd238/rev_3c07047-40cd238/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
=======
	@Override
	public boolean canRead(Type type, Class<?> contextClass, MediaType mediaType) {

		return super.canRead(type.getClass(), mediaType);
	}

	@Override
	public Object read(Type type, Class<?> contextClass,
            HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        InputStream in = inputMessage.getBody();

        byte[] buf = new byte[1024];
        for (;;) {
            int len = in.read(buf);
            if (len == -1) {
                break;
            }

            if (len > 0) {
                baos.write(buf, 0, len);
            }
        }

        byte[] bytes = baos.toByteArray();
        
        return JSON.parseObject(bytes, 0, bytes.length, charset.newDecoder(), type);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java;<<<<<<< MINE
    public static class UnitTests {

        static AtomicInteger counter = new AtomicInteger();

        @Before
        public void init() {
            counter.set(0);
            // since we're going to modify properties of the same class between tests, wipe the cache each time
            reset();
            /* we must call this to simulate a new request lifecycle running and clearing caches */
            HystrixRequestContext.initializeContext();
        }

        @After
        public void cleanup() {
            // instead of storing the reference from initialize we'll just get the current state and shutdown
            if (HystrixRequestContext.getContextForCurrentThread() != null) {
                // it may be null if a test shuts the context down manually
                HystrixRequestContext.getContextForCurrentThread().shutdown();
            }
        }

        @Test
        public void testTwoRequests() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testMultipleBatches() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());

            assertEquals(1, counter.get());

            // now request more
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("3", response3.get());

            // we should have had it execute twice now
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testMaxRequestsInBatch() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1, 2, 10).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2, 2, 10).queue();
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3, 2, 10).queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());

            // we should have had it execute twice because the batch size was 2
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestsOverTime() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            timer.incrementTime(5);
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(6);
            Future<String> response4 = new TestRequestCollapser(timer, counter, 4).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response5 = new TestRequestCollapser(timer, counter, 5).queue();
            timer.incrementTime(10);
            // should execute here

            // wait for all tasks to complete
            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());
            assertEquals("5", response5.get());

            System.out.println("number of executions: " + counter.get());
            assertEquals(3, counter.get());
            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testUnsubscribeOnOneDoesntKillBatch() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();

            // kill the first
            response1.cancel(true);

            timer.incrementTime(10); // let time pass that equals the default delay/period

            // the first is cancelled so should return null
            assertEquals(null, response1.get());
            // we should still get a response on the second
            assertEquals("2", response2.get());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testShardedRequests() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestShardedRequestCollapser(timer, counter, "1a").queue();
            Future<String> response2 = new TestShardedRequestCollapser(timer, counter, "2b").queue();
            Future<String> response3 = new TestShardedRequestCollapser(timer, counter, "3b").queue();
            Future<String> response4 = new TestShardedRequestCollapser(timer, counter, "4a").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1a", response1.get());
            assertEquals("2b", response2.get());
            assertEquals("3b", response3.get());
            assertEquals("4a", response4.get());

            /* we should get 2 batches since it gets sharded */
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestScope() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapser(timer, counter, "2").queue();

            // simulate a new request
            RequestCollapserFactory.resetRequest();

            Future<String> response3 = new TestRequestCollapser(timer, counter, "3").queue();
            Future<String> response4 = new TestRequestCollapser(timer, counter, "4").queue();

            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());

            // 2 different batches should execute, 1 per request
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testGlobalScope() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestGloballyScopedRequestCollapser(timer, counter, "1").queue();
            Future<String> response2 = new TestGloballyScopedRequestCollapser(timer, counter, "2").queue();

            // simulate a new request
            RequestCollapserFactory.resetRequest();

            Future<String> response3 = new TestGloballyScopedRequestCollapser(timer, counter, "3").queue();
            Future<String> response4 = new TestGloballyScopedRequestCollapser(timer, counter, "4").queue();

            timer.incrementTime(10); // let time pass that equals the default delay/period

            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());

            // despite having cleared the cache in between we should have a single execution because this is on the global not request cache
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testErrorHandlingViaFutureException() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapserWithFaultyCreateCommand(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapserWithFaultyCreateCommand(timer, counter, "2").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            try {
                response1.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }
            try {
                response2.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }

            assertEquals(0, counter.get());
            assertEquals(0, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testErrorHandlingWhenMapToResponseFails() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapserWithFaultyMapToResponse(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapserWithFaultyMapToResponse(timer, counter, "2").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            try {
                response1.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }
            try {
                response2.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                // what we expect
            }

            // the batch failed so no executions
            assertEquals(0, counter.get());
            // but it still executed the command once
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestVariableLifecycle1() throws Exception {
            // simulate request lifecycle
            HystrixRequestContext requestContext = HystrixRequestContext.initializeContext();

            // do actual work
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapser(timer, counter, 1).queue();
            timer.incrementTime(5);
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(6);
            Future<String> response4 = new TestRequestCollapser(timer, counter, 4).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response5 = new TestRequestCollapser(timer, counter, 5).queue();
            timer.incrementTime(10);
            // should execute here

            // wait for all tasks to complete
            assertEquals("1", response1.get());
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());
            assertEquals("5", response5.get());

            // each task should have been executed 3 times
            for (TestCollapserTimer.ATask t : timer.tasks) {
                assertEquals(3, t.task.count.get());
            }

            System.out.println("timer.tasks.size() A: " + timer.tasks.size());
            System.out.println("tasks in test: " + timer.tasks);

            // simulate request lifecycle
            requestContext.shutdown();

            System.out.println("timer.tasks.size() B: " + timer.tasks.size());

            HystrixRequestVariableHolder<RequestCollapser<?, ?, ?>> rv = RequestCollapserFactory.getRequestVariable(new TestRequestCollapser(timer, counter, 1).getCollapserKey().name());

            assertNotNull(rv);
            // they should have all been removed as part of ThreadContext.remove()
            assertEquals(0, timer.tasks.size());
        }

        @Test
        public void testRequestVariableLifecycle2() throws Exception {
            // simulate request lifecycle
            HystrixRequestContext requestContext = HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            final ConcurrentLinkedQueue<Future<String>> responses = new ConcurrentLinkedQueue<Future<String>>();
            ConcurrentLinkedQueue<Thread> threads = new ConcurrentLinkedQueue<Thread>();

            // kick off work (simulating a single request with multiple threads)
            for (int t = 0; t < 5; t++) {
                Thread th = new Thread(new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {

                    @Override
                    public void run() {
                        for (int i = 0; i < 100; i++) {
                            responses.add(new TestRequestCollapser(timer, counter, 1).queue());
                        }
                    }
                }));

                threads.add(th);
                th.start();
            }

            for (Thread th : threads) {
                // wait for each thread to finish
                th.join();
            }

            // we expect 5 threads * 100 responses each
            assertEquals(500, responses.size());

            for (Future<String> f : responses) {
                // they should not be done yet because the counter hasn't incremented
                assertFalse(f.isDone());
            }

            timer.incrementTime(5);
            Future<String> response2 = new TestRequestCollapser(timer, counter, 2).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response3 = new TestRequestCollapser(timer, counter, 3).queue();
            timer.incrementTime(6);
            Future<String> response4 = new TestRequestCollapser(timer, counter, 4).queue();
            timer.incrementTime(8);
            // should execute here
            Future<String> response5 = new TestRequestCollapser(timer, counter, 5).queue();
            timer.incrementTime(10);
            // should execute here

            // wait for all tasks to complete
            for (Future<String> f : responses) {
                assertEquals("1", f.get());
            }
            assertEquals("2", response2.get());
            assertEquals("3", response3.get());
            assertEquals("4", response4.get());
            assertEquals("5", response5.get());

            // each task should have been executed 3 times
            for (TestCollapserTimer.ATask t : timer.tasks) {
                assertEquals(3, t.task.count.get());
            }

            // simulate request lifecycle
            requestContext.shutdown();

            HystrixRequestVariableHolder<RequestCollapser<?, ?, ?>> rv = RequestCollapserFactory.getRequestVariable(new TestRequestCollapser(timer, counter, 1).getCollapserKey().name());

            assertNotNull(rv);
            // they should have all been removed as part of ThreadContext.remove()
            assertEquals(0, timer.tasks.size());
        }

        /**
         * Test Request scoped caching of commands so that a 2nd duplicate call doesn't execute but returns the previous Future
         */
        @Test
        public void testRequestCache1() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("A", f2.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f3 = command1.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should still have executed only one command
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test Request scoped caching doesn't prevent different ones from executing
         */
        @Test
        public void testRequestCache2() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", true);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f3 = command1.queue();
            Future<String> f4 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
                assertEquals("B", f4.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should still have executed only one command
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testRequestCache3() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", true);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", true);
            SuccessfulCacheableCollapsedCommand command3 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", true);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("B", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f4 = command1.queue();
            Future<String> f5 = command2.queue();
            Future<String> f6 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f4.get());
                assertEquals("B", f5.get());
                assertEquals("B", f6.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should still have executed only one command
            assertEquals(1, counter.get());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testNoRequestCache3() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            final TestCollapserTimer timer = new TestCollapserTimer();
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "A", false);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", false);
            SuccessfulCacheableCollapsedCommand command3 = new SuccessfulCacheableCollapsedCommand(timer, counter, "B", false);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("B", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // we should have executed a command once
            assertEquals(1, counter.get());

            Future<String> f4 = command1.queue();
            Future<String> f5 = command2.queue();
            Future<String> f6 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f4.get());
                assertEquals("B", f5.get());
                assertEquals("B", f6.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // request caching is turned off on this so we expect 2 command executions
            assertEquals(2, counter.get());
            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            // we expect to see it with SUCCESS and COLLAPSED and both
            HystrixCommand<?> commandA = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[2])[0];
            assertEquals(2, commandA.getExecutionEvents().size());
            assertTrue(commandA.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(commandA.getExecutionEvents().contains(HystrixEventType.COLLAPSED));

            // we expect to see it with SUCCESS and COLLAPSED and both
            HystrixCommand<?> commandB = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[2])[1];
            assertEquals(2, commandB.getExecutionEvents().size());
            assertTrue(commandB.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(commandB.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test that a command that throws an Exception when cached will re-throw the exception.
         */
        @Test
        public void testRequestCacheWithException() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            ConcurrentLinkedQueue<HystrixCommand<List<String>>> commands = new ConcurrentLinkedQueue<HystrixCommand<List<String>>>();

            final TestCollapserTimer timer = new TestCollapserTimer();
            // pass in 'null' which will cause an NPE to be thrown
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, null, true, commands);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, null, true, commands);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("A", f2.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should have executed 1 command
            assertEquals(1, commands.size());
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.FAILURE));
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.COLLAPSED));

            SuccessfulCacheableCollapsedCommand command3 = new SuccessfulCacheableCollapsedCommand(timer, counter, null, true, commands);
            Future<String> f3 = command3.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should still be 1 ... no new executions
            assertEquals(1, commands.size());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?> command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[1])[0];
            assertEquals(2, command.getExecutionEvents().size());
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.FAILURE));
            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
        }

        /**
         * Test that a command that times out will still be cached and when retrieved will re-throw the exception.
         */
        @Test
        public void testRequestCacheWithTimeout() {
            // simulate request lifecycle
            HystrixRequestContext.initializeContext();

            ConcurrentLinkedQueue<HystrixCommand<List<String>>> commands = new ConcurrentLinkedQueue<HystrixCommand<List<String>>>();

            final TestCollapserTimer timer = new TestCollapserTimer();
            // pass in 'null' which will cause an NPE to be thrown
            SuccessfulCacheableCollapsedCommand command1 = new SuccessfulCacheableCollapsedCommand(timer, counter, "TIMEOUT", true, commands);
            SuccessfulCacheableCollapsedCommand command2 = new SuccessfulCacheableCollapsedCommand(timer, counter, "TIMEOUT", true, commands);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f1.get());
                assertEquals("A", f2.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should have executed 1 command
            assertEquals(1, commands.size());
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.TIMEOUT));
            assertTrue(commands.peek().getExecutionEvents().contains(HystrixEventType.COLLAPSED));

            Future<String> f3 = command1.queue();

            // increment past batch time so it executes
            timer.incrementTime(15);

            try {
                assertEquals("A", f3.get());
                fail("exception should have been thrown");
            } catch (Exception e) {
                // expected
            }

            // this should be 0 because we never complete execution
            assertEquals(0, counter.get());

            // it should still be 1 ... no new executions
            assertEquals(1, commands.size());
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test how the collapser behaves when the circuit is short-circuited
         */
        @Test
        public void testRequestWithCommandShortCircuited() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<String> response1 = new TestRequestCollapserWithShortCircuitedCommand(timer, counter, "1").queue();
            Future<String> response2 = new TestRequestCollapserWithShortCircuitedCommand(timer, counter, "2").queue();
            timer.incrementTime(10); // let time pass that equals the default delay/period

            try {
                response1.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                //                e.printStackTrace();
                // what we expect
            }
            try {
                response2.get();
                fail("we should have received an exception");
            } catch (ExecutionException e) {
                //                e.printStackTrace();
                // what we expect
            }

            assertEquals(0, counter.get());
            // it will execute once (short-circuited)
            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a Void response type - null being set as response.
         * 
         * @throws Exception
         */
        @Test
        public void testVoidResponseTypeFireAndForgetCollapsing1() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<Void> response1 = new TestCollapserWithVoidResponseType(timer, counter, 1).queue();
            Future<Void> response2 = new TestCollapserWithVoidResponseType(timer, counter, 2).queue();
            timer.incrementTime(100); // let time pass that equals the default delay/period

            // normally someone wouldn't wait on these, but we need to make sure they do in fact return
            // and not block indefinitely in case someone does call get()
            assertEquals(null, response1.get());
            assertEquals(null, response2.get());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a Void response type - response never being set in mapResponseToRequest
         * 
         * @throws Exception
         */
        @Test
        public void testVoidResponseTypeFireAndForgetCollapsing2() throws Exception {
            TestCollapserTimer timer = new TestCollapserTimer();
            Future<Void> response1 = new TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests(timer, counter, 1).queue();
            Future<Void> response2 = new TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests(timer, counter, 2).queue();
            timer.incrementTime(100); // let time pass that equals the default delay/period

            // we will fetch one of these just so we wait for completion ... but expect an error
            try {
                assertEquals(null, response1.get());
                fail("expected an error as mapResponseToRequests did not set responses");
            } catch (ExecutionException e) {
                assertTrue(e.getCause() instanceof IllegalStateException);
                assertTrue(e.getCause().getMessage().startsWith("No response set by"));
            }

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }
        
        /**
         * Test a Void response type with execute - response being set in mapResponseToRequest to null
         * 
         * @throws Exception
         */
        @Test
        public void testVoidResponseTypeFireAndForgetCollapsing3() throws Exception {
            CollapserTimer timer = new RealCollapserTimer();
            assertNull(new TestCollapserWithVoidResponseType(timer, counter, 1).execute());

            assertEquals(1, counter.get());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        private static class TestRequestCollapser extends HystrixCollapser<List<String>, String, String> {

            private final AtomicInteger count;
            private final String value;
            private ConcurrentLinkedQueue<HystrixCommand<List<String>>> commandsExecuted;

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, int value) {
                this(timer, counter, String.valueOf(value));
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value) {
                this(timer, counter, value, 10000, 10);
            }

            public TestRequestCollapser(Scope scope, TestCollapserTimer timer, AtomicInteger counter, String value) {
                this(scope, timer, counter, value, 10000, 10);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                this(timer, counter, value, 10000, 10, executionLog);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, int value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds) {
                this(timer, counter, String.valueOf(value), defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds) {
                this(timer, counter, value, defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds, null);
            }

            public TestRequestCollapser(Scope scope, TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds) {
                this(scope, timer, counter, value, defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds, null);
            }

            public TestRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                this(Scope.REQUEST, timer, counter, value, defaultMaxRequestsInBatch, defaultTimerDelayInMilliseconds, executionLog);
            }

            public TestRequestCollapser(Scope scope, TestCollapserTimer timer, AtomicInteger counter, String value, int defaultMaxRequestsInBatch, int defaultTimerDelayInMilliseconds, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                // use a CollapserKey based on the CollapserTimer object reference so it's unique for each timer as we don't want caching
                // of properties to occur and we're using the default HystrixProperty which typically does caching
                super(collapserKeyFromString(timer), scope, timer, HystrixCollapserProperties.Setter().withMaxRequestsInBatch(defaultMaxRequestsInBatch).withTimerDelayInMilliseconds(defaultTimerDelayInMilliseconds));
                this.count = counter;
                this.value = value;
                this.commandsExecuted = executionLog;
            }

            @Override
            public String getRequestArgument() {
                return value;
            }

            @Override
            public HystrixCommand<List<String>> createCommand(final Collection<CollapsedRequest<String, String>> requests) {
                /* return a mocked command */
                HystrixCommand<List<String>> command = new TestCollapserCommand(requests);
                if (commandsExecuted != null) {
                    commandsExecuted.add(command);
                }
                return command;
            }

            @Override
            public void mapResponseToRequests(List<String> batchResponse, Collection<CollapsedRequest<String, String>> requests) {
                // count how many times a batch is executed (this method is executed once per batch)
                System.out.println("increment count: " + count.incrementAndGet());

                // for simplicity I'll assume it's a 1:1 mapping between lists ... in real implementations they often need to index to maps
                // to allow random access as the response size does not match the request size
                if (batchResponse.size() != requests.size()) {
                    throw new RuntimeException("lists don't match in size => " + batchResponse.size() + " : " + requests.size());
                }
                int i = 0;
                for (CollapsedRequest<String, String> request : requests) {
                    request.setResponse(batchResponse.get(i++));
                }

            }

        }

        /**
         * Shard on the artificially provided 'type' variable.
         */
        private static class TestShardedRequestCollapser extends TestRequestCollapser {

            public TestShardedRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            protected Collection<Collection<CollapsedRequest<String, String>>> shardRequests(Collection<CollapsedRequest<String, String>> requests) {
                Collection<CollapsedRequest<String, String>> typeA = new ArrayList<CollapsedRequest<String, String>>();
                Collection<CollapsedRequest<String, String>> typeB = new ArrayList<CollapsedRequest<String, String>>();

                for (CollapsedRequest<String, String> request : requests) {
                    if (request.getArgument().endsWith("a")) {
                        typeA.add(request);
                    } else if (request.getArgument().endsWith("b")) {
                        typeB.add(request);
                    }
                }

                ArrayList<Collection<CollapsedRequest<String, String>>> shards = new ArrayList<Collection<CollapsedRequest<String, String>>>();
                shards.add(typeA);
                shards.add(typeB);
                return shards;
            }

        }

        /**
         * Test the global scope
         */
        private static class TestGloballyScopedRequestCollapser extends TestRequestCollapser {

            public TestGloballyScopedRequestCollapser(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(Scope.GLOBAL, timer, counter, value);
            }

        }

        /**
         * Throw an exception when creating a command.
         */
        private static class TestRequestCollapserWithFaultyCreateCommand extends TestRequestCollapser {

            public TestRequestCollapserWithFaultyCreateCommand(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            public HystrixCommand<List<String>> createCommand(Collection<CollapsedRequest<String, String>> requests) {
                throw new RuntimeException("some failure");
            }

        }

        /**
         * Throw an exception when creating a command.
         */
        private static class TestRequestCollapserWithShortCircuitedCommand extends TestRequestCollapser {

            public TestRequestCollapserWithShortCircuitedCommand(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            public HystrixCommand<List<String>> createCommand(Collection<CollapsedRequest<String, String>> requests) {
                // args don't matter as it's short-circuited
                return new ShortCircuitedCommand();
            }

        }

        /**
         * Throw an exception when mapToResponse is invoked
         */
        private static class TestRequestCollapserWithFaultyMapToResponse extends TestRequestCollapser {

            public TestRequestCollapserWithFaultyMapToResponse(TestCollapserTimer timer, AtomicInteger counter, String value) {
                super(timer, counter, value);
            }

            @Override
            public void mapResponseToRequests(List<String> batchResponse, Collection<CollapsedRequest<String, String>> requests) {
                // pretend we blow up with an NPE
                throw new NullPointerException("batchResponse was null and we blew up");
            }

        }

        private static class TestCollapserCommand extends TestHystrixCommand<List<String>> {

            private final Collection<CollapsedRequest<String, String>> requests;

            TestCollapserCommand(Collection<CollapsedRequest<String, String>> requests) {
                super(testPropsBuilder().setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(50)));
                this.requests = requests;
            }

            @Override
            protected List<String> run() {
                System.out.println(">>> TestCollapserCommand run() ... batch size: " + requests.size());
                // simulate a batch request
                ArrayList<String> response = new ArrayList<String>();
                for (CollapsedRequest<String, String> request : requests) {
                    if (request.getArgument() == null) {
                        throw new NullPointerException("Simulated Error");
                    }
                    if (request.getArgument() == "TIMEOUT") {
                        try {
                            Thread.sleep(200);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    response.add(request.getArgument());
                }
                return response;
            }

        }

        /**
         * A Command implementation that supports caching.
         */
        private static class SuccessfulCacheableCollapsedCommand extends TestRequestCollapser {

            private final boolean cacheEnabled;

            public SuccessfulCacheableCollapsedCommand(TestCollapserTimer timer, AtomicInteger counter, String value, boolean cacheEnabled) {
                super(timer, counter, value);
                this.cacheEnabled = cacheEnabled;
            }

            public SuccessfulCacheableCollapsedCommand(TestCollapserTimer timer, AtomicInteger counter, String value, boolean cacheEnabled, ConcurrentLinkedQueue<HystrixCommand<List<String>>> executionLog) {
                super(timer, counter, value, executionLog);
                this.cacheEnabled = cacheEnabled;
            }

            @Override
            public String getCacheKey() {
                if (cacheEnabled)
                    return "aCacheKey_" + super.value;
                else
                    return null;
            }
        }

        private static class ShortCircuitedCommand extends HystrixCommand<List<String>> {

            protected ShortCircuitedCommand() {
                super(HystrixCommand.Setter.withGroupKey(
                        HystrixCommandGroupKey.Factory.asKey("shortCircuitedCommand"))
                        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter
                                .getUnitTestPropertiesSetter()
                                .withCircuitBreakerForceOpen(true)));
            }

            @Override
            protected List<String> run() throws Exception {
                System.out.println("*** execution (this shouldn't happen)");
                // this won't ever get called as we're forcing short-circuiting
                ArrayList<String> values = new ArrayList<String>();
                values.add("hello");
                return values;
            }

        }

        private static class FireAndForgetCommand extends HystrixCommand<Void> {

            protected FireAndForgetCommand(List<Integer> values) {
                super(HystrixCommand.Setter.withGroupKey(
                        HystrixCommandGroupKey.Factory.asKey("fireAndForgetCommand"))
                        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter()));
            }

            @Override
            protected Void run() throws Exception {
                System.out.println("*** FireAndForgetCommand execution: " + Thread.currentThread());
                return null;
            }

        }

        private static class TestCollapserTimer implements CollapserTimer {

            private final ConcurrentLinkedQueue<ATask> tasks = new ConcurrentLinkedQueue<ATask>();

            @Override
            public Reference<TimerListener> addListener(final TimerListener collapseTask) {
                System.out.println("add listener: " + collapseTask);
                tasks.add(new ATask(new TestTimerListener(collapseTask)));

                /**
                 * This is a hack that overrides 'clear' of a WeakReference to match the required API
                 * but then removes the strong-reference we have inside 'tasks'.
                 * <p>
                 * We do this so our unit tests know if the WeakReference is cleared correctly, and if so then the ATack is removed from 'tasks'
                 */
                return new SoftReference<TimerListener>(collapseTask) {
                    @Override
                    public void clear() {
                        System.out.println("tasks: " + tasks);
                        System.out.println("**** clear TimerListener: tasks.size => " + tasks.size());
                        // super.clear();
                        for (ATask t : tasks) {
                            if (t.task.actualListener.equals(collapseTask)) {
                                tasks.remove(t);
                            }
                        }
                    }

                };
            }

            /**
             * Increment time by X. Note that incrementing by multiples of delay or period time will NOT execute multiple times.
             * <p>
             * You must call incrementTime multiple times each increment being larger than 'period' on subsequent calls to cause multiple executions.
             * <p>
             * This is because executing multiple times in a tight-loop would not achieve the correct behavior, such as batching, since it will all execute "now" not after intervals of time.
             * 
             * @param timeInMilliseconds
             */
            public synchronized void incrementTime(int timeInMilliseconds) {
                for (ATask t : tasks) {
                    t.incrementTime(timeInMilliseconds);
                }
            }

            private static class ATask {
                final TestTimerListener task;
                final int delay = 10;

                // our relative time that we'll use
                volatile int time = 0;
                volatile int executionCount = 0;

                private ATask(TestTimerListener task) {
                    this.task = task;
                }

                public synchronized void incrementTime(int timeInMilliseconds) {
                    time += timeInMilliseconds;
                    if (task != null) {
                        if (executionCount == 0) {
                            System.out.println("ExecutionCount 0 => Time: " + time + " Delay: " + delay);
                            if (time >= delay) {
                                // first execution, we're past the delay time
                                executeTask();
                            }
                        } else {
                            System.out.println("ExecutionCount 1+ => Time: " + time + " Delay: " + delay);
                            if (time >= delay) {
                                // subsequent executions, we're past the interval time
                                executeTask();
                            }
                        }
                    }
                }

                private synchronized void executeTask() {
                    System.out.println("Executing task ...");
                    task.tick();
                    this.time = 0; // we reset time after each execution
                    this.executionCount++;
                    System.out.println("executionCount: " + executionCount);
                }
            }

        }

        private static class TestTimerListener implements TimerListener {

            private final TimerListener actualListener;
            private final AtomicInteger count = new AtomicInteger();

            public TestTimerListener(TimerListener actual) {
                this.actualListener = actual;
            }

            @Override
            public void tick() {
                count.incrementAndGet();
                actualListener.tick();
            }

            @Override
            public int getIntervalTimeInMilliseconds() {
                return 10;
            }

        }

        private static HystrixCollapserKey collapserKeyFromString(final Object o) {
            return new HystrixCollapserKey() {

                @Override
                public String name() {
                    return String.valueOf(o);
                }

            };
        }

        private static class TestCollapserWithVoidResponseType extends HystrixCollapser<Void, Void, Integer> {

            private final AtomicInteger count;
            private final Integer value;

            public TestCollapserWithVoidResponseType(CollapserTimer timer, AtomicInteger counter, int value) {
                super(collapserKeyFromString(timer), Scope.REQUEST, timer, HystrixCollapserProperties.Setter().withMaxRequestsInBatch(1000).withTimerDelayInMilliseconds(50));
                this.count = counter;
                this.value = value;
            }

            @Override
            public Integer getRequestArgument() {
                return value;
            }

            @Override
            protected HystrixCommand<Void> createCommand(Collection<CollapsedRequest<Void, Integer>> requests) {

                ArrayList<Integer> args = new ArrayList<Integer>();
                for (CollapsedRequest<Void, Integer> request : requests) {
                    args.add(request.getArgument());
                }
                return new FireAndForgetCommand(args);
            }

            @Override
            protected void mapResponseToRequests(Void batchResponse, Collection<CollapsedRequest<Void, Integer>> requests) {
                count.incrementAndGet();
                for (CollapsedRequest<Void, Integer> r : requests) {
                    r.setResponse(null);
                }
            }

        }

        private static class TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests extends HystrixCollapser<Void, Void, Integer> {

            private final AtomicInteger count;
            private final Integer value;

            public TestCollapserWithVoidResponseTypeAndMissingMapResponseToRequests(CollapserTimer timer, AtomicInteger counter, int value) {
                super(collapserKeyFromString(timer), Scope.REQUEST, timer, HystrixCollapserProperties.Setter().withMaxRequestsInBatch(1000).withTimerDelayInMilliseconds(50));
                this.count = counter;
                this.value = value;
            }

            @Override
            public Integer getRequestArgument() {
                return value;
            }

            @Override
            protected HystrixCommand<Void> createCommand(Collection<CollapsedRequest<Void, Integer>> requests) {

                ArrayList<Integer> args = new ArrayList<Integer>();
                for (CollapsedRequest<Void, Integer> request : requests) {
                    args.add(request.getArgument());
                }
                return new FireAndForgetCommand(args);
            }

            @Override
            protected void mapResponseToRequests(Void batchResponse, Collection<CollapsedRequest<Void, Integer>> requests) {
                count.incrementAndGet();
            }

        }
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java;<<<<<<< MINE
            callableWithContextOfParent = concurrencyStrategy.wrapCallable(new HystrixContextCallable<Void>(new Callable<Void>() {
=======
            callableWithContextOfParent = new HystrixContextCallable<Void>(concurrencyStrategy, new Callable<Void>() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java;<<<<<<< MINE
            }));
=======
            });
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextRunnable.java;<<<<<<< MINE
import java.util.concurrent.Callable;

import com.netflix.hystrix.strategy.HystrixPlugins;

=======
import java.util.concurrent.Callable;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextRunnable.java;<<<<<<< MINE
    private final Runnable actual;
=======
    private final Callable<Void> actual;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextRunnable.java;<<<<<<< MINE
    public HystrixContextRunnable(Runnable actual) {
        this(HystrixPlugins.getInstance().getConcurrencyStrategy(), actual);
    }
    
    public HystrixContextRunnable(HystrixConcurrencyStrategy concurrencyStrategy, final Runnable actual) {
        this.actual = concurrencyStrategy.wrapCallable(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                actual.run();
                return null;
            }

        });
=======
    public HystrixContextRunnable(HystrixConcurrencyStrategy concurrencyStrategy, final Runnable actual) {
        this.actual = concurrencyStrategy.wrapCallable(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                actual.run();
                return null;
            }

        });
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextRunnable.java;<<<<<<< MINE
            actual.run();
=======
            try {
                actual.call();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextCallable.java;<<<<<<< MINE
    public HystrixContextCallable(Callable<K> actual) {
        this(HystrixPlugins.getInstance().getConcurrencyStrategy(), actual);
    }
    
    public HystrixContextCallable(HystrixConcurrencyStrategy concurrencyStrategy, Callable<K> actual) {
        this.actual = concurrencyStrategy.wrapCallable(actual);
=======
    public HystrixContextCallable(HystrixConcurrencyStrategy concurrencyStrategy, Callable<K> actual) {
        this.actual = concurrencyStrategy.wrapCallable(actual);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java;<<<<<<< MINE
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import rx.util.functions.Action1;
import rx.util.functions.Func1;

import com.netflix.config.ConfigurationManager;
import com.netflix.hystrix.Hystrix;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java;<<<<<<< MINE
    
    public static class UnitTest {
        
        @Before
        public void prepareForTest() {
            /* we must call this to simulate a new request lifecycle running and clearing caches */
            HystrixRequestContext.initializeContext();
        }

        @After
        public void cleanup() {
            // instead of storing the reference from initialize we'll just get the current state and shutdown
            if (HystrixRequestContext.getContextForCurrentThread() != null) {
                // it could have been set NULL by the test
                HystrixRequestContext.getContextForCurrentThread().shutdown();
            }

            // force properties to be clean as well
            ConfigurationManager.getConfigInstance().clear();
        }
        
        /**
         * If the RequestContext does not get transferred across threads correctly this blows up. 
         * No specific assertions are necessary.
         */
        @Test
        public void testRequestContextPropagatesAcrossObserveOnPool() {
            new SimpleCommand().execute();
            new SimpleCommand().observe().map(new Func1<String, String>() {

                @Override
                public String call(String s) {
                    System.out.println("Map => Commands: " + HystrixRequestLog.getCurrentRequest().getExecutedCommands());
                    return s;
                }
            }).toBlockingObservable().forEach(new Action1<String>() {

                @Override
                public void call(String s) {
                    System.out.println("Result [" + s + "] => Commands: " + HystrixRequestLog.getCurrentRequest().getExecutedCommands());
                }
            });
        }
        
        private static class SimpleCommand extends HystrixCommand<String> {

            public SimpleCommand() {
                super(HystrixCommandGroupKey.Factory.asKey("SimpleCommand"));
            }
            
            @Override
            protected String run() throws Exception {
                System.out.println("Executing => Commands: " + HystrixRequestLog.getCurrentRequest().getExecutedCommands());
                return "Hello";
            }
            
        }
        
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java;<<<<<<< MINE
=======
import java.util.concurrent.RejectedExecutionException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java;<<<<<<< MINE
import rx.util.functions.Func2;
=======
import rx.functions.Action1;
import rx.schedulers.Schedulers;
import rx.subscriptions.BooleanSubscription;

import com.netflix.hystrix.HystrixThreadPool;
import com.netflix.hystrix.strategy.HystrixPlugins;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextFunc2.java;<<<<<<< MINE
/**
 * Copyright 2012 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.hystrix.strategy.concurrency;

import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicReference;

import rx.Scheduler;
import rx.Subscription;
import rx.util.functions.Func2;

import com.netflix.hystrix.strategy.HystrixPlugins;

/**
 * Wrapper around {@link Func2} that manages the {@link HystrixRequestContext} initialization and cleanup for the execution of the {@link Func2}
 * 
 * @param <T>
 *            Return type of {@link Func2}
 * 
 * @ExcludeFromJavadoc
 */
public class HystrixContextFunc2<T> implements Func2<Scheduler, T, Subscription> {

    private final Func2<? super Scheduler, ? super T, ? extends Subscription> actual;
    private final HystrixRequestContext parentThreadState;
    private final Callable<Subscription> c;

    /*
     * This is a workaround to needing to use Callable<Subscription> but
     * needing to pass `Scheduler t1, T t2` into it after construction.
     * 
     * Think of it like sticking t1 and t2 on the stack and then calling the function
     * that uses them.
     * 
     * This should all be thread-safe without issues despite multi-step execution
     * because this Func2 is only ever executed once by Hystrix and construction will always
     * precede `call` being invoked once. 
     * 
     */
    private final AtomicReference<Scheduler> t1Holder = new AtomicReference<Scheduler>();
    private final AtomicReference<T> t2Holder = new AtomicReference<T>();

    public HystrixContextFunc2(Func2<? super Scheduler, ? super T, ? extends Subscription> action) {
        this(HystrixPlugins.getInstance().getConcurrencyStrategy(), action);
    }
    
    public HystrixContextFunc2(final HystrixConcurrencyStrategy concurrencyStrategy, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {
        this.actual = action;
        this.parentThreadState = HystrixRequestContext.getContextForCurrentThread();

        this.c = concurrencyStrategy.wrapCallable(new Callable<Subscription>() {

            @Override
            public Subscription call() throws Exception {
                HystrixRequestContext existingState = HystrixRequestContext.getContextForCurrentThread();
                try {
                    // set the state of this thread to that of its parent
                    HystrixRequestContext.setContextOnCurrentThread(parentThreadState);
                    // execute actual Func2 with the state of the parent
                    return actual.call(new HystrixContextScheduler(concurrencyStrategy, t1Holder.get()), t2Holder.get());
                } finally {
                    // restore this thread back to its original state
                    HystrixRequestContext.setContextOnCurrentThread(existingState);
                }
            }
        });
    }

    @Override
    public Subscription call(Scheduler t1, T t2) {
        try {
            this.t1Holder.set(t1);
            this.t2Holder.set(t2);
            return c.call();
        } catch (Exception e) {
            throw new RuntimeException("Failed executing wrapped Func2", e);
        }
    }

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java;<<<<<<< MINE
import static org.junit.Assert.*;

import java.util.concurrent.Callable;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java;<<<<<<< MINE
import org.junit.After;
import org.junit.Test;

import rx.util.functions.Action1;

import com.netflix.hystrix.Hystrix;
import com.netflix.hystrix.HystrixCommand;
import com.netflix.hystrix.HystrixCommandGroupKey;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java;<<<<<<< MINE
    public static class UnitTest {

        @After
        public void reset() {
            // use private access to reset so we can test different initializations via the public static flow
            HystrixPlugins.getInstance().concurrencyStrategy.set(null);
            HystrixPlugins.getInstance().metricsPublisher.set(null);
            HystrixPlugins.getInstance().notifier.set(null);
            HystrixPlugins.getInstance().propertiesFactory.set(null);
        }

        @Test
        public void testEventNotifierDefaultImpl() {
            HystrixEventNotifier impl = HystrixPlugins.getInstance().getEventNotifier();
            assertTrue(impl instanceof HystrixEventNotifierDefault);
        }

        @Test
        public void testEventNotifierViaRegisterMethod() {
            HystrixPlugins.getInstance().registerEventNotifier(new HystrixEventNotifierTestImpl());
            HystrixEventNotifier impl = HystrixPlugins.getInstance().getEventNotifier();
            assertTrue(impl instanceof HystrixEventNotifierTestImpl);
        }

        @Test
        public void testEventNotifierViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixEventNotifierTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixEventNotifier.implementation", fullClass);
                HystrixEventNotifier impl = HystrixPlugins.getInstance().getEventNotifier();
                assertTrue(impl instanceof HystrixEventNotifierTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixEventNotifier.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixEventNotifierTestImpl extends HystrixEventNotifier {
            // just use defaults
        }

        @Test
        public void testConcurrencyStrategyDefaultImpl() {
            HystrixConcurrencyStrategy impl = HystrixPlugins.getInstance().getConcurrencyStrategy();
            assertTrue(impl instanceof HystrixConcurrencyStrategyDefault);
        }

        @Test
        public void testConcurrencyStrategyViaRegisterMethod() {
            HystrixPlugins.getInstance().registerConcurrencyStrategy(new HystrixConcurrencyStrategyTestImpl());
            HystrixConcurrencyStrategy impl = HystrixPlugins.getInstance().getConcurrencyStrategy();
            assertTrue(impl instanceof HystrixConcurrencyStrategyTestImpl);
        }

        @Test
        public void testConcurrencyStrategyViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixConcurrencyStrategyTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixConcurrencyStrategy.implementation", fullClass);
                HystrixConcurrencyStrategy impl = HystrixPlugins.getInstance().getConcurrencyStrategy();
                assertTrue(impl instanceof HystrixConcurrencyStrategyTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixConcurrencyStrategy.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixConcurrencyStrategyTestImpl extends HystrixConcurrencyStrategy {
            // just use defaults
        }

        @Test
        public void testMetricsPublisherDefaultImpl() {
            HystrixMetricsPublisher impl = HystrixPlugins.getInstance().getMetricsPublisher();
            assertTrue(impl instanceof HystrixMetricsPublisherDefault);
        }

        @Test
        public void testMetricsPublisherViaRegisterMethod() {
            HystrixPlugins.getInstance().registerMetricsPublisher(new HystrixMetricsPublisherTestImpl());
            HystrixMetricsPublisher impl = HystrixPlugins.getInstance().getMetricsPublisher();
            assertTrue(impl instanceof HystrixMetricsPublisherTestImpl);
        }

        @Test
        public void testMetricsPublisherViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixMetricsPublisherTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixMetricsPublisher.implementation", fullClass);
                HystrixMetricsPublisher impl = HystrixPlugins.getInstance().getMetricsPublisher();
                assertTrue(impl instanceof HystrixMetricsPublisherTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixMetricsPublisher.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixMetricsPublisherTestImpl extends HystrixMetricsPublisher {
            // just use defaults
        }

        @Test
        public void testPropertiesStrategyDefaultImpl() {
            HystrixPropertiesStrategy impl = HystrixPlugins.getInstance().getPropertiesStrategy();
            assertTrue(impl instanceof HystrixPropertiesStrategyDefault);
        }

        @Test
        public void testPropertiesStrategyViaRegisterMethod() {
            HystrixPlugins.getInstance().registerPropertiesStrategy(new HystrixPropertiesStrategyTestImpl());
            HystrixPropertiesStrategy impl = HystrixPlugins.getInstance().getPropertiesStrategy();
            assertTrue(impl instanceof HystrixPropertiesStrategyTestImpl);
        }

        @Test
        public void testPropertiesStrategyViaProperty() {
            try {
                String fullClass = getFullClassNameForTestClass(HystrixPropertiesStrategyTestImpl.class);
                System.setProperty("hystrix.plugin.HystrixPropertiesStrategy.implementation", fullClass);
                HystrixPropertiesStrategy impl = HystrixPlugins.getInstance().getPropertiesStrategy();
                assertTrue(impl instanceof HystrixPropertiesStrategyTestImpl);
            } finally {
                System.clearProperty("hystrix.plugin.HystrixPropertiesStrategy.implementation");
            }
        }

        // inside UnitTest so it is stripped from Javadocs
        public static class HystrixPropertiesStrategyTestImpl extends HystrixPropertiesStrategy {
            // just use defaults
        }

        private static String getFullClassNameForTestClass(Class<?> cls) {
            return HystrixPlugins.class.getPackage().getName() + "." + HystrixPlugins.class.getSimpleName() + "$UnitTest$" + cls.getSimpleName();
        }
        
        
        private static final ThreadLocal<String> testRequestIdThreadLocal = new ThreadLocal<String>();

        public static class DummyCommand extends HystrixCommand<Void> {

            public DummyCommand() {
                super(HystrixCommandGroupKey.Factory.asKey("Dummy"));
            }

            @Override
            protected Void run() throws Exception {
                System.out.println("requestId (run) = " + testRequestIdThreadLocal.get());
                Thread.sleep(2000);
                return null;
            }
        }

        @Test
        public void testRequestContextViaPluginInTimeout() {
            HystrixPlugins.getInstance().registerConcurrencyStrategy(new HystrixConcurrencyStrategy() {
                @Override
                public <T> Callable<T> wrapCallable(final Callable<T> callable) {
                    return new RequestIdCallable<T>(callable);
                }
            });

            HystrixRequestContext context = HystrixRequestContext.initializeContext();

            testRequestIdThreadLocal.set("foobar");
            final AtomicReference<String> valueInTimeout = new AtomicReference<String>();

            new DummyCommand().toObservable()
                    .doOnError(new Action1<Throwable>() {
                        @Override
                        public void call(Throwable throwable) {
                            System.out.println("initialized = " + HystrixRequestContext.isCurrentThreadInitialized());
                            System.out.println("requestId (timeout) = " + testRequestIdThreadLocal.get());
                            valueInTimeout.set(testRequestIdThreadLocal.get());
                        }
                    })
                    .materialize()
                    .toBlockingObservable().single();

            context.shutdown();
            Hystrix.reset();
            
            assertEquals("foobar", valueInTimeout.get());
        }

        private static class RequestIdCallable<T> implements Callable<T> {
            private final Callable<T> callable;
            private final String requestId;

            public RequestIdCallable(Callable<T> callable) {
                this.callable = callable;
                this.requestId = testRequestIdThreadLocal.get();
            }

            @Override
            public T call() throws Exception {
                String original = testRequestIdThreadLocal.get();
                testRequestIdThreadLocal.set(requestId);
                try {
                    return callable.call();
                } finally {
                    testRequestIdThreadLocal.set(original);
                }
            }
        }
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java;<<<<<<< MINE
import rx.Subscription;
import rx.concurrency.Schedulers;
import rx.operators.SafeObservableSubscription;
import rx.subjects.ReplaySubject;
import rx.subscriptions.Subscriptions;
import rx.util.functions.Action0;
import rx.util.functions.Action1;
import rx.util.functions.Func1;
import rx.util.functions.Func2;

import com.netflix.config.ConfigurationManager;
import com.netflix.hystrix.HystrixCircuitBreaker.NoOpCircuitBreaker;
import com.netflix.hystrix.HystrixCircuitBreaker.TestCircuitBreaker;
=======
import rx.Subscriber;
import rx.schedulers.Schedulers;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java;<<<<<<< MINE
            }, commandOfDuplicateCall);
            this.originalObservable = originalObservable;
        }

        /*
         * This is a cached response so we want the command of the observable we're wrapping.
         */
        public HystrixCommand<R> getCommand() {
            return originalObservable.originalCommand;
        }
    }

    private static class TimeoutObservable<R> extends Observable<R> {

        public TimeoutObservable(final Observable<R> o, final HystrixCommand<R> originalCommand, final boolean isNonBlocking) {
            super(new OnSubscribeFunc<R>() {

                @Override
                public Subscription onSubscribe(final Observer<? super R> observer) {
                    // TODO this is using a private API of Rx so either move off of it or get Rx to make it public
                    // TODO better yet, get TimeoutObservable part of Rx
                    final SafeObservableSubscription s = new SafeObservableSubscription();

                    /*
                     * Define the action to perform on timeout outside of the TimerListener to it can capture the HystrixRequestContext
                     * of the calling thread which doesn't exist on the Timer thread.
                     */
                    final HystrixContextRunnable timeoutRunnable = new HystrixContextRunnable(originalCommand.concurrencyStrategy, new Runnable() {

                        @Override
                        public void run() {
                            try {
                                R v = originalCommand.getFallbackOrThrowException(HystrixEventType.TIMEOUT, FailureType.TIMEOUT, "timed-out", new TimeoutException());
                                observer.onNext(v);
                                observer.onCompleted();
                            } catch (HystrixRuntimeException re) {
                                observer.onError(re);
                            }
                        }
                    });
                    
                    TimerListener listener = new TimerListener() {

                        @Override
                        public void tick() {
                            // if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath
                            // otherwise it means we lost a race and the run() execution completed
                            if (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) {
                                // do fallback logic

                                // report timeout failure
                                originalCommand.metrics.markTimeout(System.currentTimeMillis() - originalCommand.invocationStartTime);

                                // we record execution time because we are returning before 
                                originalCommand.recordTotalExecutionTime(originalCommand.invocationStartTime);

                                timeoutRunnable.run();
                            }

                            s.unsubscribe();
                        }

                        @Override
                        public int getIntervalTimeInMilliseconds() {
                            return originalCommand.properties.executionIsolationThreadTimeoutInMilliseconds().get();
                        }
                    };

                    Reference<TimerListener> _tl = null;
                    if (isNonBlocking) {
                        /*
                         * Scheduling a separate timer to do timeouts is more expensive
                         * so we'll only do it if we're being used in a non-blocking manner.
                         */
                        _tl = HystrixTimer.getInstance().addTimerListener(listener);
                    } else {
                        /*
                         * Otherwise we just set the hook that queue().get() can trigger if a timeout occurs.
                         * 
                         * This allows the blocking and non-blocking approaches to be coded basically the same way
                         * though it is admittedly awkward if we were just blocking (the use of Reference annoys me for example)
                         */
                        _tl = new SoftReference<TimerListener>(listener);
                    }
                    final Reference<TimerListener> tl = _tl;

                    // set externally so execute/queue can see this
                    originalCommand.timeoutTimer.set(tl);

                    return s.wrap(o.subscribe(new Observer<R>() {
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java;<<<<<<< MINE
    private Subscription subscribeWithThreadIsolation(final Observer<? super R> observer) {
        // mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)
        isExecutedInThread.set(true);

        // final reference to the current calling thread so the child thread can access it if needed
        final Thread callingThread = Thread.currentThread();

        final HystrixCommand<R> _this = this;

        try {
            if (!threadPool.isQueueSpaceAvailable()) {
                // we are at the property defined max so want to throw a RejectedExecutionException to simulate reaching the real max 
                throw new RejectedExecutionException("Rejected command because thread-pool queueSize is at rejection threshold.");
            }

            // wrap the synchronous execute() method in a Callable and execute in the threadpool
            final Future<R> f = threadPool.getExecutor().submit(new HystrixContextCallable<R>(concurrencyStrategy, new Callable<R>() {

                @Override
                public R call() throws Exception {
                	boolean recordDuration = true;
                    try {
                        // assign 'callingThread' to our NFExceptionThreadingUtility ThreadLocal variable so that if we blow up
                        // anywhere along the way the exception knows who the calling thread is and can include it in the stacktrace
                        ExceptionThreadingUtility.assignCallingThread(callingThread);

                        // execution hook
                        executionHook.onThreadStart(_this);

                        // count the active thread
                        threadPool.markThreadExecution();

                        try {
                            // store the command that is being run
                            Hystrix.startCurrentThreadExecutingCommand(getCommandKey());
                            // execute the command
                            R r = executeCommand();
                            // if we can go from NOT_EXECUTED to COMPLETED then we did not timeout
                            if (isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED)) {
                                // give the hook an opportunity to modify it
                                r = executionHook.onComplete(_this, r);
                                // pass to the observer
                                observer.onNext(r);
                                // state changes before termination
                                preTerminationWork(recordDuration);
                                /* now complete which releases the consumer */
                                observer.onCompleted();
                                return r;
                            } else {
                                // this means we lost the race and the timeout logic has or is being executed
                                // state changes before termination
                            	// do not recordDuration as this is a timeout and the tick would have set the duration already.
                            	recordDuration = false;
                                preTerminationWork(recordDuration);
                                return null;
                            }
                        } finally {
                            // pop this off the thread now that it's done
                            Hystrix.endCurrentThreadExecutingCommand();
                        }
                    } catch (Exception e) {
                        // state changes before termination
                        preTerminationWork(recordDuration);
                        // if we can go from NOT_EXECUTED to COMPLETED then we did not timeout
                        if (isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED)) {
                            observer.onError(e);
                        }
                        throw e;
                    }
                }

                private void preTerminationWork(boolean recordDuration) {
                	if(recordDuration) {
                		/* execution time (must occur before terminal state otherwise a race condition can occur if requested by client) */
                		recordTotalExecutionTime(invocationStartTime);
                	}
                    threadPool.markThreadCompletion();

                    try {
                        executionHook.onThreadComplete(_this);
                    } catch (Exception e) {
                        logger.warn("ExecutionHook.onThreadComplete threw an exception that will be ignored.", e);
                    }
                }

            }));

            return new Subscription() {

                @Override
                public void unsubscribe() {
                    f.cancel(properties.executionIsolationThreadInterruptOnTimeout().get());
                }

            };

        } catch (RejectedExecutionException e) {
            // mark on counter
            metrics.markThreadPoolRejection();
            // use a fallback instead (or throw exception if not implemented)
            observer.onNext(getFallbackOrThrowException(HystrixEventType.THREAD_POOL_REJECTED, FailureType.REJECTED_THREAD_EXECUTION, "could not be queued for execution", e));
            observer.onCompleted();
            return Subscriptions.empty();
        } catch (Exception e) {
            // unknown exception
            logger.error(getLogMessagePrefix() + ": Unexpected exception while submitting to queue.", e);
            observer.onNext(getFallbackOrThrowException(HystrixEventType.THREAD_POOL_REJECTED, FailureType.REJECTED_THREAD_EXECUTION, "had unexpected exception while attempting to queue for execution.", e));
            observer.onCompleted();
            return Subscriptions.empty();
        }
=======
    @Override
    public HystrixCommandGroupKey getCommandGroup() {
        return observableCommand.getCommandGroup();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_678c0d3_fc99fce/rev_678c0d3-fc99fce/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java;<<<<<<< MINE
    /* ******************************************************************************** */
    /* ******************************************************************************** */
    /* Result Status */
    /* ******************************************************************************** */
    /* ******************************************************************************** */

    /**
     * Immutable holder class for the status of command execution.
     * <p>
     * Contained within a class to simplify the sharing of it across Futures/threads that result from request caching.
     * <p>
     * This object can be referenced and "modified" by parent and child threads as well as by different instances of HystrixCommand since
     * 1 instance could create an ExecutionResult, cache a Future that refers to it, a 2nd instance execution then retrieves a Future
     * from cache and wants to append RESPONSE_FROM_CACHE to whatever the ExecutionResult was from the first command execution.
     * <p>
     * This being immutable forces and ensure thread-safety instead of using AtomicInteger/ConcurrentLinkedQueue and determining
     * when it's safe to mutate the object directly versus needing to deep-copy clone to a new instance.
     */
    private static class ExecutionResult {
        private final List<HystrixEventType> events;
        private final int executionTime;
        private final Exception exception;

        private ExecutionResult(HystrixEventType... events) {
            this(Arrays.asList(events), -1, null);
        }

        public ExecutionResult setExecutionTime(int executionTime) {
            return new ExecutionResult(events, executionTime, exception);
        }

        public ExecutionResult setException(Exception e) {
            return new ExecutionResult(events, executionTime, e);
        }

        private ExecutionResult(List<HystrixEventType> events, int executionTime, Exception e) {
            // we are safe assigning the List reference instead of deep-copying
            // because we control the original list in 'newEvent'
            this.events = events;
            this.executionTime = executionTime;
            this.exception = e;
        }

        // we can return a static version since it's immutable
        private static ExecutionResult EMPTY = new ExecutionResult(new HystrixEventType[0]);

        /**
         * Creates a new ExecutionResult by adding the defined 'events' to the ones on the current instance.
         * 
         * @param events
         * @return
         */
        public ExecutionResult addEvents(HystrixEventType... events) {
            ArrayList<HystrixEventType> newEvents = new ArrayList<HystrixEventType>();
            newEvents.addAll(this.events);
            for (HystrixEventType e : events) {
                newEvents.add(e);
            }
            return new ExecutionResult(Collections.unmodifiableList(newEvents), executionTime, exception);
        }
    }

    /* ******************************************************************************** */
    /* ******************************************************************************** */
    /* RequestCache */
    /* ******************************************************************************** */
    /* ******************************************************************************** */

    /**
     * Key to be used for request caching.
     * <p>
     * By default this returns null which means "do not cache".
     * <p>
     * To enable caching override this method and return a string key uniquely representing the state of a command instance.
     * <p>
     * If multiple command instances in the same request scope match keys then only the first will be executed and all others returned from cache.
     * 
     * @return cacheKey
     */
    protected String getCacheKey() {
        return null;
    }

    private boolean isRequestCachingEnabled() {
        return properties.requestCacheEnabled().get();
    }

    /* ******************************************************************************** */
    /* ******************************************************************************** */
    /* TryableSemaphore */
    /* ******************************************************************************** */
    /* ******************************************************************************** */

    /**
     * Semaphore that only supports tryAcquire and never blocks and that supports a dynamic permit count.
     * <p>
     * Using AtomicInteger increment/decrement instead of java.util.concurrent.Semaphore since we don't need blocking and need a custom implementation to get the dynamic permit count and since
     * AtomicInteger achieves the same behavior and performance without the more complex implementation of the actual Semaphore class using AbstractQueueSynchronizer.
     */
    private static class TryableSemaphore {
        private final HystrixProperty<Integer> numberOfPermits;
        private final AtomicInteger count = new AtomicInteger(0);

        public TryableSemaphore(HystrixProperty<Integer> numberOfPermits) {
            this.numberOfPermits = numberOfPermits;
        }

        /**
         * Use like this:
         * <p>
         * 
         * <pre>
         * if (s.tryAcquire()) {
         * try {
         * // do work that is protected by 's'
         * } finally {
         * s.release();
         * }
         * }
         * </pre>
         * 
         * @return boolean
         */
        public boolean tryAcquire() {
            int currentCount = count.incrementAndGet();
            if (currentCount > numberOfPermits.get()) {
                count.decrementAndGet();
                return false;
            } else {
                return true;
            }
        }

        /**
         * ONLY call release if tryAcquire returned true.
         * <p>
         * 
         * <pre>
         * if (s.tryAcquire()) {
         * try {
         * // do work that is protected by 's'
         * } finally {
         * s.release();
         * }
         * }
         * </pre>
         */
        public void release() {
            count.decrementAndGet();
        }

        public int getNumberOfPermitsUsed() {
            return count.get();
        }

    }

    private String getLogMessagePrefix() {
        return getCommandKey().name();
    }

    /**
     * Fluent interface for arguments to the {@link HystrixCommand} constructor.
     * <p>
     * The required arguments are set via the 'with' factory method and optional arguments via the 'and' chained methods.
     * <p>
     * Example:
     * <pre> {@code
     *  Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("GroupName"))
                .andCommandKey(HystrixCommandKey.Factory.asKey("CommandName"))
                .andEventNotifier(notifier);
     * } </pre>
     */
    @NotThreadSafe
    public static class Setter {

        private final HystrixCommandGroupKey groupKey;
        private HystrixCommandKey commandKey;
        private HystrixThreadPoolKey threadPoolKey;
        private HystrixCommandProperties.Setter commandPropertiesDefaults;
        private HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults;

        /**
         * Setter factory method containing required values.
         * <p>
         * All optional arguments can be set via the chained methods.
         * 
         * @param groupKey
         *            {@link HystrixCommandGroupKey} used to group together multiple {@link HystrixCommand} objects.
         *            <p>
         *            The {@link HystrixCommandGroupKey} is used to represent a common relationship between commands. For example, a library or team name, the system all related commands interace
         *            with,
         *            common business purpose etc.
         */
        private Setter(HystrixCommandGroupKey groupKey) {
            this.groupKey = groupKey;
        }

        /**
         * Setter factory method with required values.
         * <p>
         * All optional arguments can be set via the chained methods.
         * 
         * @param groupKey
         *            {@link HystrixCommandGroupKey} used to group together multiple {@link HystrixCommand} objects.
         *            <p>
         *            The {@link HystrixCommandGroupKey} is used to represent a common relationship between commands. For example, a library or team name, the system all related commands interace
         *            with,
         *            common business purpose etc.
         */
        public static Setter withGroupKey(HystrixCommandGroupKey groupKey) {
            return new Setter(groupKey);
        }

        /**
         * @param commandKey
         *            {@link HystrixCommandKey} used to identify a {@link HystrixCommand} instance for statistics, circuit-breaker, properties, etc.
         *            <p>
         *            By default this will be derived from the instance class name.
         *            <p>
         *            NOTE: Every unique {@link HystrixCommandKey} will result in new instances of {@link HystrixCircuitBreaker}, {@link HystrixCommandMetrics} and {@link HystrixCommandProperties}.
         *            Thus,
         *            the number of variants should be kept to a finite and reasonable number to avoid high-memory usage or memory leacks.
         *            <p>
         *            Hundreds of keys is fine, tens of thousands is probably not.
         * @return Setter for fluent interface via method chaining
         */
        public Setter andCommandKey(HystrixCommandKey commandKey) {
            this.commandKey = commandKey;
            return this;
        }

        /**
         * @param threadPoolKey
         *            {@link HystrixThreadPoolKey} used to define which thread-pool this command should run in (when configured to run on separate threads via
         *            {@link HystrixCommandProperties#executionIsolationStrategy()}).
         *            <p>
         *            By default this is derived from the {@link HystrixCommandGroupKey} but if injected this allows multiple commands to have the same {@link HystrixCommandGroupKey} but different
         *            thread-pools.
         * @return Setter for fluent interface via method chaining
         */
        public Setter andThreadPoolKey(HystrixThreadPoolKey threadPoolKey) {
            this.threadPoolKey = threadPoolKey;
            return this;
        }

        /**
         * Optional
         * 
         * @param commandPropertiesDefaults
         *            {@link HystrixCommandProperties.Setter} with property overrides for this specific instance of {@link HystrixCommand}.
         *            <p>
         *            See the {@link HystrixPropertiesStrategy} JavaDocs for more information on properties and order of precedence.
         * @return Setter for fluent interface via method chaining
         */
        public Setter andCommandPropertiesDefaults(HystrixCommandProperties.Setter commandPropertiesDefaults) {
            this.commandPropertiesDefaults = commandPropertiesDefaults;
            return this;
        }

        /**
         * Optional
         * 
         * @param threadPoolPropertiesDefaults
         *            {@link HystrixThreadPoolProperties.Setter} with property overrides for the {@link HystrixThreadPool} used by this specific instance of {@link HystrixCommand}.
         *            <p>
         *            See the {@link HystrixPropertiesStrategy} JavaDocs for more information on properties and order of precedence.
         * @return Setter for fluent interface via method chaining
         */
        public Setter andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults) {
            this.threadPoolPropertiesDefaults = threadPoolPropertiesDefaults;
            return this;
        }

    }

    public static class UnitTest {

        @Before
        public void prepareForTest() {
            /* we must call this to simulate a new request lifecycle running and clearing caches */
            HystrixRequestContext.initializeContext();
        }

        @After
        public void cleanup() {
            // instead of storing the reference from initialize we'll just get the current state and shutdown
            if (HystrixRequestContext.getContextForCurrentThread() != null) {
                // it could have been set NULL by the test
                HystrixRequestContext.getContextForCurrentThread().shutdown();
            }

            // force properties to be clean as well
            ConfigurationManager.getConfigInstance().clear();
        }

        /**
         * Test a successful command execution.
         */
        @Test
        public void testExecutionSuccess() {
            try {
                TestHystrixCommand<Boolean> command = new SuccessfulTestCommand();
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(true, command.execute());
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));

                assertEquals(null, command.getFailedExecutionException());

                assertTrue(command.getExecutionTimeInMilliseconds() > -1);
                assertTrue(command.isSuccessfulExecution());

                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

                assertEquals(0, command.builder.metrics.getHealthCounts().getErrorPercentage());

                assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            } catch (Exception e) {
                e.printStackTrace();
                fail("We received an exception.");
            }
        }

        /**
         * Test that a command can not be executed multiple times.
         */
        @Test
        public void testExecutionMultipleTimes() {
            SuccessfulTestCommand command = new SuccessfulTestCommand();
            assertFalse(command.isExecutionComplete());
            // first should succeed
            assertEquals(true, command.execute());
            assertTrue(command.isExecutionComplete());
            assertTrue(command.isExecutedInThread());
            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isSuccessfulExecution());
            try {
                // second should fail
                command.execute();
                fail("we should not allow this ... it breaks the state of request logs");
            } catch (IllegalStateException e) {
                e.printStackTrace();
                // we want to get here
            }

            try {
                // queue should also fail
                command.queue();
                fail("we should not allow this ... it breaks the state of request logs");
            } catch (IllegalStateException e) {
                e.printStackTrace();
                // we want to get here
            }
        }

        /**
         * Test a command execution that throws an HystrixException and didn't implement getFallback.
         */
        @Test
        public void testExecutionKnownFailureWithNoFallback() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithoutFallback(circuitBreaker);
            try {
                command.execute();
                fail("we shouldn't get here");
            } catch (HystrixRuntimeException e) {
                e.printStackTrace();
                assertNotNull(e.getFallbackException());
                assertNotNull(e.getImplementingClass());
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should always get an HystrixRuntimeException when an error occurs.");
            }
            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution that throws an unknown exception (not HystrixException) and didn't implement getFallback.
         */
        @Test
        public void testExecutionUnknownFailureWithNoFallback() {
            TestHystrixCommand<Boolean> command = new UnknownFailureTestCommandWithoutFallback();
            try {
                command.execute();
                fail("we shouldn't get here");
            } catch (HystrixRuntimeException e) {
                e.printStackTrace();
                assertNotNull(e.getFallbackException());
                assertNotNull(e.getImplementingClass());

            } catch (Exception e) {
                e.printStackTrace();
                fail("We should always get an HystrixRuntimeException when an error occurs.");
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution that fails but has a fallback.
         */
        @Test
        public void testExecutionFailureWithFallback() {
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithFallback(new TestCircuitBreaker());
            try {
                assertEquals(false, command.execute());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertEquals("we failed with a simulated issue", command.getFailedExecutionException().getMessage());

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution that fails, has getFallback implemented but that fails as well.
         */
        @Test
        public void testExecutionFailureWithFallbackFailure() {
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithFallbackFailure();
            try {
                command.execute();
                fail("we shouldn't get here");
            } catch (HystrixRuntimeException e) {
                System.out.println("------------------------------------------------");
                e.printStackTrace();
                System.out.println("------------------------------------------------");
                assertNotNull(e.getFallbackException());
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a successful command execution (asynchronously).
         */
        @Test
        public void testQueueSuccess() {
            TestHystrixCommand<Boolean> command = new SuccessfulTestCommand();
            try {
                Future<Boolean> future = command.queue();
                assertEquals(true, future.get());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We received an exception.");
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isSuccessfulExecution());

            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution (asynchronously) that throws an HystrixException and didn't implement getFallback.
         */
        @Test
        public void testQueueKnownFailureWithNoFallback() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithoutFallback(circuitBreaker);
            try {
                command.queue().get();
                fail("we shouldn't get here");
            } catch (Exception e) {
                e.printStackTrace();
                if (e.getCause() instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e.getCause();

                    assertNotNull(de.getFallbackException());
                    assertNotNull(de.getImplementingClass());
                } else {
                    fail("the cause should be HystrixRuntimeException");
                }
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution (asynchronously) that throws an unknown exception (not HystrixException) and didn't implement getFallback.
         */
        @Test
        public void testQueueUnknownFailureWithNoFallback() {
            TestHystrixCommand<Boolean> command = new UnknownFailureTestCommandWithoutFallback();
            try {
                command.queue().get();
                fail("we shouldn't get here");
            } catch (Exception e) {
                e.printStackTrace();
                if (e.getCause() instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e.getCause();
                    assertNotNull(de.getFallbackException());
                    assertNotNull(de.getImplementingClass());
                } else {
                    fail("the cause should be HystrixRuntimeException");
                }
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution (asynchronously) that fails but has a fallback.
         */
        @Test
        public void testQueueFailureWithFallback() {
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithFallback(new TestCircuitBreaker());
            try {
                Future<Boolean> future = command.queue();
                assertEquals(false, future.get());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution (asynchronously) that fails, has getFallback implemented but that fails as well.
         */
        @Test
        public void testQueueFailureWithFallbackFailure() {
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithFallbackFailure();
            try {
                command.queue().get();
                fail("we shouldn't get here");
            } catch (Exception e) {
                if (e.getCause() instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e.getCause();
                    e.printStackTrace();
                    assertNotNull(de.getFallbackException());
                } else {
                    fail("the cause should be HystrixRuntimeException");
                }
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a successful command execution.
         */
        @Test
        public void testObserveSuccess() {
            try {
                TestHystrixCommand<Boolean> command = new SuccessfulTestCommand();
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(true, command.observe().toBlockingObservable().single());
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));

                assertEquals(null, command.getFailedExecutionException());

                assertTrue(command.getExecutionTimeInMilliseconds() > -1);
                assertTrue(command.isSuccessfulExecution());

                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

                assertEquals(0, command.builder.metrics.getHealthCounts().getErrorPercentage());

                assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            } catch (Exception e) {
                e.printStackTrace();
                fail("We received an exception.");
            }
        }

        /**
         * Test a successful command execution.
         */
        @Test
        public void testObserveOnScheduler() throws Exception {

            final AtomicReference<Thread> commandThread = new AtomicReference<Thread>();
            final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>();

            TestHystrixCommand<Boolean> command = new TestHystrixCommand<Boolean>(TestHystrixCommand.testPropsBuilder()) {

                @Override
                protected Boolean run() {
                    commandThread.set(Thread.currentThread());
                    return true;
                }
            };

            final CountDownLatch latch = new CountDownLatch(1);

            Scheduler customScheduler = new Scheduler() {

                private final Scheduler self = this;

                @Override
                public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {
                    return schedule(state, action, 0, TimeUnit.MILLISECONDS);
                }

                @Override
                public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action, long delayTime, TimeUnit unit) {
                    new Thread("RxScheduledThread") {
                        @Override
                        public void run() {
                            action.call(self, state);
                        }
                    }.start();

                    // not testing unsubscribe behavior
                    return Subscriptions.empty();
                }

            };

            command.toObservable(customScheduler).subscribe(new Observer<Boolean>() {

                @Override
                public void onCompleted() {
                    latch.countDown();

                }

                @Override
                public void onError(Throwable e) {
                    latch.countDown();
                    e.printStackTrace();

                }

                @Override
                public void onNext(Boolean args) {
                    subscribeThread.set(Thread.currentThread());
                }
            });

            if (!latch.await(2000, TimeUnit.MILLISECONDS)) {
                fail("timed out");
            }

            assertNotNull(commandThread.get());
            assertNotNull(subscribeThread.get());

            System.out.println("Command Thread: " + commandThread.get());
            System.out.println("Subscribe Thread: " + subscribeThread.get());

            assertTrue(commandThread.get().getName().startsWith("hystrix-"));
            assertTrue(subscribeThread.get().getName().equals("RxScheduledThread"));
        }

        /**
         * Test a successful command execution.
         */
        @Test
        public void testObserveOnComputationSchedulerByDefaultForThreadIsolation() throws Exception {

            final AtomicReference<Thread> commandThread = new AtomicReference<Thread>();
            final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>();

            TestHystrixCommand<Boolean> command = new TestHystrixCommand<Boolean>(TestHystrixCommand.testPropsBuilder()) {

                @Override
                protected Boolean run() {
                    commandThread.set(Thread.currentThread());
                    return true;
                }
            };

            final CountDownLatch latch = new CountDownLatch(1);

            command.toObservable().subscribe(new Observer<Boolean>() {

                @Override
                public void onCompleted() {
                    latch.countDown();

                }

                @Override
                public void onError(Throwable e) {
                    latch.countDown();
                    e.printStackTrace();

                }

                @Override
                public void onNext(Boolean args) {
                    subscribeThread.set(Thread.currentThread());
                }
            });

            if (!latch.await(2000, TimeUnit.MILLISECONDS)) {
                fail("timed out");
            }

            assertNotNull(commandThread.get());
            assertNotNull(subscribeThread.get());

            System.out.println("Command Thread: " + commandThread.get());
            System.out.println("Subscribe Thread: " + subscribeThread.get());

            assertTrue(commandThread.get().getName().startsWith("hystrix-"));
            assertTrue(subscribeThread.get().getName().startsWith("RxComputationThreadPool"));
        }

        /**
         * Test a successful command execution.
         */
        @Test
        public void testObserveOnImmediateSchedulerByDefaultForSemaphoreIsolation() throws Exception {

            final AtomicReference<Thread> commandThread = new AtomicReference<Thread>();
            final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>();

            TestHystrixCommand<Boolean> command = new TestHystrixCommand<Boolean>(TestHystrixCommand.testPropsBuilder()
                    .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE))) {

                @Override
                protected Boolean run() {
                    commandThread.set(Thread.currentThread());
                    return true;
                }
            };

            final CountDownLatch latch = new CountDownLatch(1);

            command.toObservable().subscribe(new Observer<Boolean>() {

                @Override
                public void onCompleted() {
                    latch.countDown();

                }

                @Override
                public void onError(Throwable e) {
                    latch.countDown();
                    e.printStackTrace();

                }

                @Override
                public void onNext(Boolean args) {
                    subscribeThread.set(Thread.currentThread());
                }
            });

            if (!latch.await(2000, TimeUnit.MILLISECONDS)) {
                fail("timed out");
            }

            assertNotNull(commandThread.get());
            assertNotNull(subscribeThread.get());

            System.out.println("Command Thread: " + commandThread.get());
            System.out.println("Subscribe Thread: " + subscribeThread.get());

            String mainThreadName = Thread.currentThread().getName();

            // semaphore should be on the calling thread
            assertTrue(commandThread.get().getName().equals(mainThreadName));
            assertTrue(subscribeThread.get().getName().equals(mainThreadName));
        }

        /**
         * Test that the circuit-breaker will 'trip' and prevent command execution on subsequent calls.
         */
        @Test
        public void testCircuitBreakerTripsAfterFailures() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            /* fail 3 times and then it should trip the circuit and stop executing */
            // failure 1
            KnownFailureTestCommandWithFallback attempt1 = new KnownFailureTestCommandWithFallback(circuitBreaker);
            attempt1.execute();
            assertTrue(attempt1.isResponseFromFallback());
            assertFalse(attempt1.isCircuitBreakerOpen());
            assertFalse(attempt1.isResponseShortCircuited());

            // failure 2
            KnownFailureTestCommandWithFallback attempt2 = new KnownFailureTestCommandWithFallback(circuitBreaker);
            attempt2.execute();
            assertTrue(attempt2.isResponseFromFallback());
            assertFalse(attempt2.isCircuitBreakerOpen());
            assertFalse(attempt2.isResponseShortCircuited());

            // failure 3
            KnownFailureTestCommandWithFallback attempt3 = new KnownFailureTestCommandWithFallback(circuitBreaker);
            attempt3.execute();
            assertTrue(attempt3.isResponseFromFallback());
            assertFalse(attempt3.isResponseShortCircuited());
            // it should now be 'open' and prevent further executions
            assertTrue(attempt3.isCircuitBreakerOpen());

            // attempt 4
            KnownFailureTestCommandWithFallback attempt4 = new KnownFailureTestCommandWithFallback(circuitBreaker);
            attempt4.execute();
            assertTrue(attempt4.isResponseFromFallback());
            // this should now be true as the response will be short-circuited
            assertTrue(attempt4.isResponseShortCircuited());
            // this should remain open
            assertTrue(attempt4.isCircuitBreakerOpen());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(4, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that the circuit-breaker will 'trip' and prevent command execution on subsequent calls.
         */
        @Test
        public void testCircuitBreakerTripsAfterFailuresViaQueue() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            try {
                /* fail 3 times and then it should trip the circuit and stop executing */
                // failure 1
                KnownFailureTestCommandWithFallback attempt1 = new KnownFailureTestCommandWithFallback(circuitBreaker);
                attempt1.queue().get();
                assertTrue(attempt1.isResponseFromFallback());
                assertFalse(attempt1.isCircuitBreakerOpen());
                assertFalse(attempt1.isResponseShortCircuited());

                // failure 2
                KnownFailureTestCommandWithFallback attempt2 = new KnownFailureTestCommandWithFallback(circuitBreaker);
                attempt2.queue().get();
                assertTrue(attempt2.isResponseFromFallback());
                assertFalse(attempt2.isCircuitBreakerOpen());
                assertFalse(attempt2.isResponseShortCircuited());

                // failure 3
                KnownFailureTestCommandWithFallback attempt3 = new KnownFailureTestCommandWithFallback(circuitBreaker);
                attempt3.queue().get();
                assertTrue(attempt3.isResponseFromFallback());
                assertFalse(attempt3.isResponseShortCircuited());
                // it should now be 'open' and prevent further executions
                assertTrue(attempt3.isCircuitBreakerOpen());

                // attempt 4
                KnownFailureTestCommandWithFallback attempt4 = new KnownFailureTestCommandWithFallback(circuitBreaker);
                attempt4.queue().get();
                assertTrue(attempt4.isResponseFromFallback());
                // this should now be true as the response will be short-circuited
                assertTrue(attempt4.isResponseShortCircuited());
                // this should remain open
                assertTrue(attempt4.isCircuitBreakerOpen());

                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
                assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
                assertEquals(4, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
                assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

                assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

                assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received fallbacks.");
            }
        }

        /**
         * Test that the circuit-breaker is shared across HystrixCommand objects with the same CommandKey.
         * <p>
         * This will test HystrixCommand objects with a single circuit-breaker (as if each injected with same CommandKey)
         * <p>
         * Multiple HystrixCommand objects with the same dependency use the same circuit-breaker.
         */
        @Test
        public void testCircuitBreakerAcrossMultipleCommandsButSameCircuitBreaker() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            /* fail 3 times and then it should trip the circuit and stop executing */
            // failure 1
            KnownFailureTestCommandWithFallback attempt1 = new KnownFailureTestCommandWithFallback(circuitBreaker);
            attempt1.execute();
            assertTrue(attempt1.isResponseFromFallback());
            assertFalse(attempt1.isCircuitBreakerOpen());
            assertFalse(attempt1.isResponseShortCircuited());

            // failure 2 with a different command, same circuit breaker
            KnownFailureTestCommandWithoutFallback attempt2 = new KnownFailureTestCommandWithoutFallback(circuitBreaker);
            try {
                attempt2.execute();
            } catch (Exception e) {
                // ignore ... this doesn't have a fallback so will throw an exception
            }
            assertTrue(attempt2.isFailedExecution());
            assertFalse(attempt2.isResponseFromFallback()); // false because no fallback
            assertFalse(attempt2.isCircuitBreakerOpen());
            assertFalse(attempt2.isResponseShortCircuited());

            // failure 3 of the Hystrix, 2nd for this particular HystrixCommand
            KnownFailureTestCommandWithFallback attempt3 = new KnownFailureTestCommandWithFallback(circuitBreaker);
            attempt3.execute();
            assertTrue(attempt2.isFailedExecution());
            assertTrue(attempt3.isResponseFromFallback());
            assertFalse(attempt3.isResponseShortCircuited());

            // it should now be 'open' and prevent further executions
            // after having 3 failures on the Hystrix that these 2 different HystrixCommand objects are for
            assertTrue(attempt3.isCircuitBreakerOpen());

            // attempt 4
            KnownFailureTestCommandWithFallback attempt4 = new KnownFailureTestCommandWithFallback(circuitBreaker);
            attempt4.execute();
            assertTrue(attempt4.isResponseFromFallback());
            // this should now be true as the response will be short-circuited
            assertTrue(attempt4.isResponseShortCircuited());
            // this should remain open
            assertTrue(attempt4.isCircuitBreakerOpen());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that the circuit-breaker is different between HystrixCommand objects with a different Hystrix.
         */
        @Test
        public void testCircuitBreakerAcrossMultipleCommandsAndDifferentDependency() {
            TestCircuitBreaker circuitBreaker_one = new TestCircuitBreaker();
            TestCircuitBreaker circuitBreaker_two = new TestCircuitBreaker();
            /* fail 3 times, twice on one Hystrix, once on a different Hystrix ... circuit-breaker should NOT open */

            // failure 1
            KnownFailureTestCommandWithFallback attempt1 = new KnownFailureTestCommandWithFallback(circuitBreaker_one);
            attempt1.execute();
            assertTrue(attempt1.isResponseFromFallback());
            assertFalse(attempt1.isCircuitBreakerOpen());
            assertFalse(attempt1.isResponseShortCircuited());

            // failure 2 with a different HystrixCommand implementation and different Hystrix
            KnownFailureTestCommandWithFallback attempt2 = new KnownFailureTestCommandWithFallback(circuitBreaker_two);
            attempt2.execute();
            assertTrue(attempt2.isResponseFromFallback());
            assertFalse(attempt2.isCircuitBreakerOpen());
            assertFalse(attempt2.isResponseShortCircuited());

            // failure 3 but only 2nd of the Hystrix.ONE
            KnownFailureTestCommandWithFallback attempt3 = new KnownFailureTestCommandWithFallback(circuitBreaker_one);
            attempt3.execute();
            assertTrue(attempt3.isResponseFromFallback());
            assertFalse(attempt3.isResponseShortCircuited());

            // it should remain 'closed' since we have only had 2 failures on Hystrix.ONE
            assertFalse(attempt3.isCircuitBreakerOpen());

            // this one should also remain closed as it only had 1 failure for Hystrix.TWO
            assertFalse(attempt2.isCircuitBreakerOpen());

            // attempt 4 (3rd attempt for Hystrix.ONE)
            KnownFailureTestCommandWithFallback attempt4 = new KnownFailureTestCommandWithFallback(circuitBreaker_one);
            attempt4.execute();
            // this should NOW flip to true as this is the 3rd failure for Hystrix.ONE
            assertTrue(attempt3.isCircuitBreakerOpen());
            assertTrue(attempt3.isResponseFromFallback());
            assertFalse(attempt3.isResponseShortCircuited());

            // Hystrix.TWO should still remain closed
            assertFalse(attempt2.isCircuitBreakerOpen());

            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(3, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(3, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker_one.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker_one.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker_two.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker_two.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that the circuit-breaker being disabled doesn't wreak havoc.
         */
        @Test
        public void testExecutionSuccessWithCircuitBreakerDisabled() {
            TestHystrixCommand<Boolean> command = new TestCommandWithoutCircuitBreaker();
            try {
                assertEquals(true, command.execute());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We received an exception.");
            }

            // we'll still get metrics ... just not the circuit breaker opening/closing
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution timeout where the command didn't implement getFallback.
         */
        @Test
        public void testExecutionTimeoutWithNoFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_NOT_IMPLEMENTED);
            try {
                command.execute();
                fail("we shouldn't get here");
            } catch (Exception e) {
                //                e.printStackTrace();
                if (e instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertTrue(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof TimeoutException);
                } else {
                    fail("the exception should be HystrixRuntimeException");
                }
            }
            // the time should be 50+ since we timeout at 50ms
            assertTrue("Execution Time is: " + command.getExecutionTimeInMilliseconds(), command.getExecutionTimeInMilliseconds() >= 50);

            assertTrue(command.isResponseTimedOut());
            assertFalse(command.isResponseFromFallback());
            assertFalse(command.isResponseRejected());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution timeout where the command implemented getFallback.
         */
        @Test
        public void testExecutionTimeoutWithFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_SUCCESS);
            try {
                assertEquals(false, command.execute());
                // the time should be 50+ since we timeout at 50ms
                assertTrue("Execution Time is: " + command.getExecutionTimeInMilliseconds(), command.getExecutionTimeInMilliseconds() >= 50);
                assertTrue(command.isResponseTimedOut());
                assertTrue(command.isResponseFromFallback());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a command execution timeout where the command implemented getFallback but it fails.
         */
        @Test
        public void testExecutionTimeoutFallbackFailure() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_FAILURE);
            try {
                command.execute();
                fail("we shouldn't get here");
            } catch (Exception e) {
                if (e instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertFalse(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof TimeoutException);
                } else {
                    fail("the exception should be HystrixRuntimeException");
                }
            }
            // the time should be 50+ since we timeout at 50ms
            assertTrue("Execution Time is: " + command.getExecutionTimeInMilliseconds(), command.getExecutionTimeInMilliseconds() >= 50);
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that the circuit-breaker counts a command execution timeout as a 'timeout' and not just failure.
         */
        @Test
        public void testCircuitBreakerOnExecutionTimeout() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_SUCCESS);
            try {
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));

                command.execute();

                assertTrue(command.isResponseFromFallback());
                assertFalse(command.isCircuitBreakerOpen());
                assertFalse(command.isResponseShortCircuited());

                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));

            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isResponseTimedOut());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that the command finishing AFTER a timeout (because thread continues in background) does not register a SUCCESS
         */
        @Test
        public void testCountersOnExecutionTimeout() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_SUCCESS);
            try {
                command.execute();

                /* wait long enough for the command to have finished */
                Thread.sleep(200);

                /* response should still be the same as 'testCircuitBreakerOnExecutionTimeout' */
                assertTrue(command.isResponseFromFallback());
                assertFalse(command.isCircuitBreakerOpen());
                assertFalse(command.isResponseShortCircuited());

                assertTrue(command.getExecutionTimeInMilliseconds() > -1);
                assertTrue(command.isResponseTimedOut());
                assertFalse(command.isSuccessfulExecution());

                /* failure and timeout count should be the same as 'testCircuitBreakerOnExecutionTimeout' */
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));

                /* we should NOT have a 'success' counter */
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));

            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a queued command execution timeout where the command didn't implement getFallback.
         * <p>
         * We specifically want to protect against developers queuing commands and using queue().get() without a timeout (such as queue().get(3000, TimeUnit.Milliseconds)) and ending up blocking
         * indefinitely by skipping the timeout protection of the execute() command.
         */
        @Test
        public void testQueuedExecutionTimeoutWithNoFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_NOT_IMPLEMENTED);
            try {
                command.queue().get();
                fail("we shouldn't get here");
            } catch (Exception e) {
                e.printStackTrace();
                if (e instanceof ExecutionException && e.getCause() instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e.getCause();
                    assertNotNull(de.getFallbackException());
                    assertTrue(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof TimeoutException);
                } else {
                    fail("the exception should be ExecutionException with cause as HystrixRuntimeException");
                }
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isResponseTimedOut());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a queued command execution timeout where the command implemented getFallback.
         * <p>
         * We specifically want to protect against developers queuing commands and using queue().get() without a timeout (such as queue().get(3000, TimeUnit.Milliseconds)) and ending up blocking
         * indefinitely by skipping the timeout protection of the execute() command.
         */
        @Test
        public void testQueuedExecutionTimeoutWithFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_SUCCESS);
            try {
                assertEquals(false, command.queue().get());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a queued command execution timeout where the command implemented getFallback but it fails.
         * <p>
         * We specifically want to protect against developers queuing commands and using queue().get() without a timeout (such as queue().get(3000, TimeUnit.Milliseconds)) and ending up blocking
         * indefinitely by skipping the timeout protection of the execute() command.
         */
        @Test
        public void testQueuedExecutionTimeoutFallbackFailure() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_FAILURE);
            try {
                command.queue().get();
                fail("we shouldn't get here");
            } catch (Exception e) {
                if (e instanceof ExecutionException && e.getCause() instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e.getCause();
                    assertNotNull(de.getFallbackException());
                    assertFalse(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof TimeoutException);
                } else {
                    fail("the exception should be ExecutionException with cause as HystrixRuntimeException");
                }
            }

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a queued command execution timeout where the command didn't implement getFallback.
         * <p>
         * We specifically want to protect against developers queuing commands and using queue().get() without a timeout (such as queue().get(3000, TimeUnit.Milliseconds)) and ending up blocking
         * indefinitely by skipping the timeout protection of the execute() command.
         */
        @Test
        public void testObservedExecutionTimeoutWithNoFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_NOT_IMPLEMENTED);
            try {
                command.observe().toBlockingObservable().single();
                fail("we shouldn't get here");
            } catch (Exception e) {
                e.printStackTrace();
                if (e instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertTrue(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof TimeoutException);
                } else {
                    fail("the exception should be ExecutionException with cause as HystrixRuntimeException");
                }
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isResponseTimedOut());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a queued command execution timeout where the command implemented getFallback.
         * <p>
         * We specifically want to protect against developers queuing commands and using queue().get() without a timeout (such as queue().get(3000, TimeUnit.Milliseconds)) and ending up blocking
         * indefinitely by skipping the timeout protection of the execute() command.
         */
        @Test
        public void testObservedExecutionTimeoutWithFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_SUCCESS);
            try {
                assertEquals(false, command.observe().toBlockingObservable().single());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test a queued command execution timeout where the command implemented getFallback but it fails.
         * <p>
         * We specifically want to protect against developers queuing commands and using queue().get() without a timeout (such as queue().get(3000, TimeUnit.Milliseconds)) and ending up blocking
         * indefinitely by skipping the timeout protection of the execute() command.
         */
        @Test
        public void testObservedExecutionTimeoutFallbackFailure() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_FAILURE);
            try {
                command.observe().toBlockingObservable().single();
                fail("we shouldn't get here");
            } catch (Exception e) {
                if (e instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertFalse(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof TimeoutException);
                } else {
                    fail("the exception should be ExecutionException with cause as HystrixRuntimeException");
                }
            }

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that the circuit-breaker counts a command execution timeout as a 'timeout' and not just failure.
         */
        @Test
        public void testShortCircuitFallbackCounter() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker().setForceShortCircuit(true);
            try {
                new KnownFailureTestCommandWithFallback(circuitBreaker).execute();

                assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));

                KnownFailureTestCommandWithFallback command = new KnownFailureTestCommandWithFallback(circuitBreaker);
                command.execute();
                assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));

                // will be -1 because it never attempted execution
                assertTrue(command.getExecutionTimeInMilliseconds() == -1);
                assertTrue(command.isResponseShortCircuited());
                assertFalse(command.isResponseTimedOut());

                // because it was short-circuited to a fallback we don't count an error
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));

            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test when a command fails to get queued up in the threadpool where the command didn't implement getFallback.
         * <p>
         * We specifically want to protect against developers getting random thread exceptions and instead just correctly receiving HystrixRuntimeException when no fallback exists.
         */
        @Test
        public void testRejectedThreadWithNoFallback() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SingleThreadedPool pool = new SingleThreadedPool(1);
            // fill up the queue
            pool.queue.add(new Runnable() {

                @Override
                public void run() {
                    System.out.println("**** queue filler1 ****");
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

            });

            Future<Boolean> f = null;
            TestCommandRejection command = null;
            try {
                f = new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_NOT_IMPLEMENTED).queue();
                command = new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_NOT_IMPLEMENTED);
                command.queue();
                fail("we shouldn't get here");
            } catch (Exception e) {
                e.printStackTrace();

                // will be -1 because it never attempted execution
                assertTrue(command.getExecutionTimeInMilliseconds() == -1);
                assertTrue(command.isResponseRejected());
                assertFalse(command.isResponseShortCircuited());
                assertFalse(command.isResponseTimedOut());

                assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                if (e instanceof HystrixRuntimeException && e.getCause() instanceof RejectedExecutionException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertTrue(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof RejectedExecutionException);
                } else {
                    fail("the exception should be HystrixRuntimeException with cause as RejectedExecutionException");
                }
            }

            try {
                f.get();
            } catch (Exception e) {
                e.printStackTrace();
                fail("The first one should succeed.");
            }

            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(50, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test when a command fails to get queued up in the threadpool where the command implemented getFallback.
         * <p>
         * We specifically want to protect against developers getting random thread exceptions and instead just correctly receives a fallback.
         */
        @Test
        public void testRejectedThreadWithFallback() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SingleThreadedPool pool = new SingleThreadedPool(1);
            // fill up the queue
            pool.queue.add(new Runnable() {

                @Override
                public void run() {
                    System.out.println("**** queue filler1 ****");
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

            });

            try {
                TestCommandRejection command1 = new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_SUCCESS);
                command1.queue();
                TestCommandRejection command2 = new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_SUCCESS);
                assertEquals(false, command2.queue().get());
                assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertFalse(command1.isResponseRejected());
                assertFalse(command1.isResponseFromFallback());
                assertTrue(command2.isResponseRejected());
                assertTrue(command2.isResponseFromFallback());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test when a command fails to get queued up in the threadpool where the command implemented getFallback but it fails.
         * <p>
         * We specifically want to protect against developers getting random thread exceptions and instead just correctly receives an HystrixRuntimeException.
         */
        @Test
        public void testRejectedThreadWithFallbackFailure() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SingleThreadedPool pool = new SingleThreadedPool(1);
            // fill up the queue
            pool.queue.add(new Runnable() {

                @Override
                public void run() {
                    System.out.println("**** queue filler1 ****");
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

            });

            try {
                new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_FAILURE).queue();
                assertEquals(false, new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_FAILURE).queue().get());
                fail("we shouldn't get here");
            } catch (Exception e) {
                e.printStackTrace();
                assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
                if (e instanceof HystrixRuntimeException && e.getCause() instanceof RejectedExecutionException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertFalse(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof RejectedExecutionException);
                } else {
                    fail("the exception should be HystrixRuntimeException with cause as RejectedExecutionException");
                }
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that we can reject a thread using isQueueSpaceAvailable() instead of just when the pool rejects.
         * <p>
         * For example, we have queue size set to 100 but want to reject when we hit 10.
         * <p>
         * This allows us to use FastProperties to control our rejection point whereas we can't resize a queue after it's created.
         */
        @Test
        public void testRejectedThreadUsingQueueSize() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SingleThreadedPool pool = new SingleThreadedPool(10, 1);
            // put 1 item in the queue
            // the thread pool won't pick it up because we're bypassing the pool and adding to the queue directly so this will keep the queue full
            pool.queue.add(new Runnable() {

                @Override
                public void run() {
                    System.out.println("**** queue filler1 ****");
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

            });

            TestCommandRejection command = null;
            try {
                // this should fail as we already have 1 in the queue
                command = new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_NOT_IMPLEMENTED);
                command.queue();
                fail("we shouldn't get here");
            } catch (Exception e) {
                e.printStackTrace();

                // will be -1 because it never attempted execution
                assertTrue(command.getExecutionTimeInMilliseconds() == -1);
                assertTrue(command.isResponseRejected());
                assertFalse(command.isResponseShortCircuited());
                assertFalse(command.isResponseTimedOut());

                assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
                if (e instanceof HystrixRuntimeException && e.getCause() instanceof RejectedExecutionException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertTrue(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof RejectedExecutionException);
                } else {
                    fail("the exception should be HystrixRuntimeException with cause as RejectedExecutionException");
                }
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testTimedOutCommandDoesNotExecute() {
            SingleThreadedPool pool = new SingleThreadedPool(5);

            TestCircuitBreaker s1 = new TestCircuitBreaker();
            TestCircuitBreaker s2 = new TestCircuitBreaker();

            // execution will take 100ms, thread pool has a 600ms timeout
            CommandWithCustomThreadPool c1 = new CommandWithCustomThreadPool(s1, pool, 100, HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(600));
            // execution will take 200ms, thread pool has a 20ms timeout
            CommandWithCustomThreadPool c2 = new CommandWithCustomThreadPool(s2, pool, 200, HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(20));
            // queue up c1 first
            Future<Boolean> c1f = c1.queue();
            // now queue up c2 and wait on it
            boolean receivedException = false;
            try {
                c2.queue().get();
            } catch (Exception e) {
                // we expect to get an exception here
                receivedException = true;
            }

            if (!receivedException) {
                fail("We expect to receive an exception for c2 as it's supposed to timeout.");
            }

            // c1 will complete after 100ms
            try {
                c1f.get();
            } catch (Exception e1) {
                e1.printStackTrace();
                fail("we should not have failed while getting c1");
            }
            assertTrue("c1 is expected to executed but didn't", c1.didExecute);

            // c2 will timeout after 20 ms ... we'll wait longer than the 200ms time to make sure
            // the thread doesn't keep running in the background and execute
            try {
                Thread.sleep(400);
            } catch (Exception e) {
                throw new RuntimeException("Failed to sleep");
            }
            assertFalse("c2 is not expected to execute, but did", c2.didExecute);

            assertEquals(1, s1.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, s1.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, s1.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, s2.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, s2.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, s2.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, s2.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testFallbackSemaphore() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            // single thread should work
            try {
                boolean result = new TestSemaphoreCommandWithSlowFallback(circuitBreaker, 1, 200).queue().get();
                assertTrue(result);
            } catch (Exception e) {
                // we shouldn't fail on this one
                throw new RuntimeException(e);
            }

            // 2 threads, the second should be rejected by the fallback semaphore
            boolean exceptionReceived = false;
            Future<Boolean> result = null;
            try {
                result = new TestSemaphoreCommandWithSlowFallback(circuitBreaker, 1, 400).queue();
                // make sure that thread gets a chance to run before queuing the next one
                Thread.sleep(50);
                Future<Boolean> result2 = new TestSemaphoreCommandWithSlowFallback(circuitBreaker, 1, 200).queue();
                result2.get();
            } catch (Exception e) {
                e.printStackTrace();
                exceptionReceived = true;
            }

            try {
                assertTrue(result.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            if (!exceptionReceived) {
                fail("We expected an exception on the 2nd get");
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            // TestSemaphoreCommandWithSlowFallback always fails so all 3 should show failure
            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            // the 1st thread executes single-threaded and gets a fallback, the next 2 are concurrent so only 1 of them is permitted by the fallback semaphore so 1 is rejected
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            // whenever a fallback_rejection occurs it is also a fallback_failure
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            // we should not have rejected any via the "execution semaphore" but instead via the "fallback semaphore"
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            // the rest should not be involved in this test
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testExecutionSemaphoreWithQueue() {
            final TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            // single thread should work
            try {
                boolean result = new TestSemaphoreCommand(circuitBreaker, 1, 200).queue().get();
                assertTrue(result);
            } catch (Exception e) {
                // we shouldn't fail on this one
                throw new RuntimeException(e);
            }

            final AtomicBoolean exceptionReceived = new AtomicBoolean();

            final TryableSemaphore semaphore =
                    new TryableSemaphore(HystrixProperty.Factory.asProperty(1));

            Runnable r = new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {

                @Override
                public void run() {
                    try {
                        new TestSemaphoreCommand(circuitBreaker, semaphore, 200).queue().get();
                    } catch (Exception e) {
                        e.printStackTrace();
                        exceptionReceived.set(true);
                    }
                }

            });
            // 2 threads, the second should be rejected by the semaphore
            Thread t1 = new Thread(r);
            Thread t2 = new Thread(r);

            t1.start();
            t2.start();
            try {
                t1.join();
                t2.join();
            } catch (Exception e) {
                e.printStackTrace();
                fail("failed waiting on threads");
            }

            if (!exceptionReceived.get()) {
                fail("We expected an exception on the 2nd get");
            }

            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            // we don't have a fallback so threw an exception when rejected
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            // not a failure as the command never executed so can't fail
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            // no fallback failure as there isn't a fallback implemented
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            // we should have rejected via semaphore
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            // the rest should not be involved in this test
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testExecutionSemaphoreWithExecution() {
            final TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            // single thread should work
            try {
                TestSemaphoreCommand command = new TestSemaphoreCommand(circuitBreaker, 1, 200);
                boolean result = command.execute();
                assertFalse(command.isExecutedInThread());
                assertTrue(result);
            } catch (Exception e) {
                // we shouldn't fail on this one
                throw new RuntimeException(e);
            }

            final ArrayBlockingQueue<Boolean> results = new ArrayBlockingQueue<Boolean>(2);

            final AtomicBoolean exceptionReceived = new AtomicBoolean();

            final TryableSemaphore semaphore =
                    new TryableSemaphore(HystrixProperty.Factory.asProperty(1));

            Runnable r = new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {

                @Override
                public void run() {
                    try {
                        results.add(new TestSemaphoreCommand(circuitBreaker, semaphore, 200).execute());
                    } catch (Exception e) {
                        e.printStackTrace();
                        exceptionReceived.set(true);
                    }
                }

            });
            // 2 threads, the second should be rejected by the semaphore
            Thread t1 = new Thread(r);
            Thread t2 = new Thread(r);

            t1.start();
            t2.start();
            try {
                t1.join();
                t2.join();
            } catch (Exception e) {
                e.printStackTrace();
                fail("failed waiting on threads");
            }

            if (!exceptionReceived.get()) {
                fail("We expected an exception on the 2nd get");
            }

            // only 1 value is expected as the other should have thrown an exception
            assertEquals(1, results.size());
            // should contain only a true result
            assertTrue(results.contains(Boolean.TRUE));
            assertFalse(results.contains(Boolean.FALSE));

            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            // no failure ... we throw an exception because of rejection but the command does not fail execution
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            // there is no fallback implemented so no failure can occur on it
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            // we rejected via semaphore
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            // the rest should not be involved in this test
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRejectedExecutionSemaphoreWithFallback() {
            final TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            final ArrayBlockingQueue<Boolean> results = new ArrayBlockingQueue<Boolean>(2);

            final AtomicBoolean exceptionReceived = new AtomicBoolean();

            Runnable r = new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {

                @Override
                public void run() {
                    try {
                        results.add(new TestSemaphoreCommandWithFallback(circuitBreaker, 1, 200, false).execute());
                    } catch (Exception e) {
                        e.printStackTrace();
                        exceptionReceived.set(true);
                    }
                }

            });

            // 2 threads, the second should be rejected by the semaphore and return fallback
            Thread t1 = new Thread(r);
            Thread t2 = new Thread(r);

            t1.start();
            t2.start();
            try {
                t1.join();
                t2.join();
            } catch (Exception e) {
                e.printStackTrace();
                fail("failed waiting on threads");
            }

            if (exceptionReceived.get()) {
                fail("We should have received a fallback response");
            }

            // both threads should have returned values
            assertEquals(2, results.size());
            // should contain both a true and false result
            assertTrue(results.contains(Boolean.TRUE));
            assertTrue(results.contains(Boolean.FALSE));

            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            // the rest should not be involved in this test
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            System.out.println("**** DONE");

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Tests that semaphores are counted separately for commands with unique keys
         */
        @Test
        public void testSemaphorePermitsInUse() {
            final TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();

            // this semaphore will be shared across multiple command instances
            final TryableSemaphore sharedSemaphore =
                    new TryableSemaphore(HystrixProperty.Factory.asProperty(3));

            // used to wait until all commands have started
            final CountDownLatch startLatch = new CountDownLatch(sharedSemaphore.numberOfPermits.get() + 1);

            // used to signal that all command can finish
            final CountDownLatch sharedLatch = new CountDownLatch(1);

            final Runnable sharedSemaphoreRunnable = new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {
                public void run() {
                    try {
                        new LatchedSemaphoreCommand(circuitBreaker, sharedSemaphore, startLatch, sharedLatch).execute();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });

            // creates group of threads each using command sharing a single semaphore

            // I create extra threads and commands so that I can verify that some of them fail to obtain a semaphore
            final int sharedThreadCount = sharedSemaphore.numberOfPermits.get() * 2;
            final Thread[] sharedSemaphoreThreads = new Thread[sharedThreadCount];
            for (int i = 0; i < sharedThreadCount; i++) {
                sharedSemaphoreThreads[i] = new Thread(sharedSemaphoreRunnable);
            }

            // creates thread using isolated semaphore
            final TryableSemaphore isolatedSemaphore =
                    new TryableSemaphore(HystrixProperty.Factory.asProperty(1));

            final CountDownLatch isolatedLatch = new CountDownLatch(1);

            // tracks failures to obtain semaphores
            final AtomicInteger failureCount = new AtomicInteger();

            final Thread isolatedThread = new Thread(new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {
                public void run() {
                    try {
                        new LatchedSemaphoreCommand(circuitBreaker, isolatedSemaphore, startLatch, isolatedLatch).execute();
                    } catch (Exception e) {
                        e.printStackTrace();
                        failureCount.incrementAndGet();
                    }
                }
            }));

            // verifies no permits in use before starting threads
            assertEquals("wrong number of permits for shared semaphore", 0, sharedSemaphore.getNumberOfPermitsUsed());
            assertEquals("wrong number of permits for isolated semaphore", 0, isolatedSemaphore.getNumberOfPermitsUsed());

            for (int i = 0; i < sharedThreadCount; i++) {
                sharedSemaphoreThreads[i].start();
            }
            isolatedThread.start();

            // waits until all commands have started
            try {
                startLatch.await(1000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            // verifies that all semaphores are in use
            assertEquals("wrong number of permits for shared semaphore",
                    sharedSemaphore.numberOfPermits.get().longValue(), sharedSemaphore.getNumberOfPermitsUsed());
            assertEquals("wrong number of permits for isolated semaphore",
                    isolatedSemaphore.numberOfPermits.get().longValue(), isolatedSemaphore.getNumberOfPermitsUsed());

            // signals commands to finish
            sharedLatch.countDown();
            isolatedLatch.countDown();

            try {
                for (int i = 0; i < sharedThreadCount; i++) {
                    sharedSemaphoreThreads[i].join();
                }
                isolatedThread.join();
            } catch (Exception e) {
                e.printStackTrace();
                fail("failed waiting on threads");
            }

            // verifies no permits in use after finishing threads
            assertEquals("wrong number of permits for shared semaphore", 0, sharedSemaphore.getNumberOfPermitsUsed());
            assertEquals("wrong number of permits for isolated semaphore", 0, isolatedSemaphore.getNumberOfPermitsUsed());

            // verifies that some executions failed
            final int expectedFailures = sharedSemaphore.getNumberOfPermitsUsed();
            assertEquals("failures expected but did not happen", expectedFailures, failureCount.get());
        }

        /**
         * Test that HystrixOwner can be passed in dynamically.
         */
        @Test
        public void testDynamicOwner() {
            try {
                TestHystrixCommand<Boolean> command = new DynamicOwnerTestCommand(CommandGroupForUnitTest.OWNER_ONE);
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(true, command.execute());
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            } catch (Exception e) {
                e.printStackTrace();
                fail("We received an exception.");
            }
        }

        /**
         * Test a successful command execution.
         */
        @Test
        public void testDynamicOwnerFails() {
            try {
                TestHystrixCommand<Boolean> command = new DynamicOwnerTestCommand(null);
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
                assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
                assertEquals(true, command.execute());
                fail("we should have thrown an exception as we need an owner");
            } catch (Exception e) {
                // success if we get here
            }
        }

        /**
         * Test that HystrixCommandKey can be passed in dynamically.
         */
        @Test
        public void testDynamicKey() {
            try {
                DynamicOwnerAndKeyTestCommand command1 = new DynamicOwnerAndKeyTestCommand(CommandGroupForUnitTest.OWNER_ONE, CommandKeyForUnitTest.KEY_ONE);
                assertEquals(true, command1.execute());
                DynamicOwnerAndKeyTestCommand command2 = new DynamicOwnerAndKeyTestCommand(CommandGroupForUnitTest.OWNER_ONE, CommandKeyForUnitTest.KEY_TWO);
                assertEquals(true, command2.execute());

                // 2 different circuit breakers should be created
                assertNotSame(command1.getCircuitBreaker(), command2.getCircuitBreaker());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We received an exception.");
            }
        }

        /**
         * Test Request scoped caching of commands so that a 2nd duplicate call doesn't execute but returns the previous Future
         */
        @Test
        public void testRequestCache1() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommand command1 = new SuccessfulCacheableCommand(circuitBreaker, true, "A");
            SuccessfulCacheableCommand command2 = new SuccessfulCacheableCommand(circuitBreaker, true, "A");

            assertTrue(command1.isCommandRunningInThread());

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            try {
                assertEquals("A", f1.get());
                assertEquals("A", f2.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertTrue(command1.executed);
            // the second one should not have executed as it should have received the cached value instead
            assertFalse(command2.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command1.getExecutionTimeInMilliseconds() > -1);
            assertFalse(command1.isResponseFromCache());

            // the execution log for command2 should show it came from cache
            assertEquals(2, command2.getExecutionEvents().size()); // it will include the SUCCESS + RESPONSE_FROM_CACHE
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.RESPONSE_FROM_CACHE));
            assertTrue(command2.getExecutionTimeInMilliseconds() == -1);
            assertTrue(command2.isResponseFromCache());

            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test Request scoped caching doesn't prevent different ones from executing
         */
        @Test
        public void testRequestCache2() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommand command1 = new SuccessfulCacheableCommand(circuitBreaker, true, "A");
            SuccessfulCacheableCommand command2 = new SuccessfulCacheableCommand(circuitBreaker, true, "B");

            assertTrue(command1.isCommandRunningInThread());

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertTrue(command1.executed);
            // both should execute as they are different
            assertTrue(command2.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command2 should show a SUCCESS
            assertEquals(1, command2.getExecutionEvents().size());
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command2.getExecutionTimeInMilliseconds() > -1);
            assertFalse(command2.isResponseFromCache());

            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testRequestCache3() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommand command1 = new SuccessfulCacheableCommand(circuitBreaker, true, "A");
            SuccessfulCacheableCommand command2 = new SuccessfulCacheableCommand(circuitBreaker, true, "B");
            SuccessfulCacheableCommand command3 = new SuccessfulCacheableCommand(circuitBreaker, true, "A");

            assertTrue(command1.isCommandRunningInThread());

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("A", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertTrue(command1.executed);
            // both should execute as they are different
            assertTrue(command2.executed);
            // but the 3rd should come from cache
            assertFalse(command3.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command2 should show a SUCCESS
            assertEquals(1, command2.getExecutionEvents().size());
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command3 should show it came from cache
            assertEquals(2, command3.getExecutionEvents().size()); // it will include the SUCCESS + RESPONSE_FROM_CACHE
            assertTrue(command3.getExecutionEvents().contains(HystrixEventType.RESPONSE_FROM_CACHE));
            assertTrue(command3.getExecutionTimeInMilliseconds() == -1);
            assertTrue(command3.isResponseFromCache());

            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test Request scoped caching of commands so that a 2nd duplicate call doesn't execute but returns the previous Future
         */
        @Test
        public void testRequestCacheWithSlowExecution() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SlowCacheableCommand command1 = new SlowCacheableCommand(circuitBreaker, "A", 200);
            SlowCacheableCommand command2 = new SlowCacheableCommand(circuitBreaker, "A", 100);
            SlowCacheableCommand command3 = new SlowCacheableCommand(circuitBreaker, "A", 100);
            SlowCacheableCommand command4 = new SlowCacheableCommand(circuitBreaker, "A", 100);

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();
            Future<String> f4 = command4.queue();

            try {
                assertEquals("A", f2.get());
                assertEquals("A", f3.get());
                assertEquals("A", f4.get());

                assertEquals("A", f1.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertTrue(command1.executed);
            // the second one should not have executed as it should have received the cached value instead
            assertFalse(command2.executed);
            assertFalse(command3.executed);
            assertFalse(command4.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command1.getExecutionTimeInMilliseconds() > -1);
            assertFalse(command1.isResponseFromCache());

            // the execution log for command2 should show it came from cache
            assertEquals(2, command2.getExecutionEvents().size()); // it will include the SUCCESS + RESPONSE_FROM_CACHE
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.RESPONSE_FROM_CACHE));
            assertTrue(command2.getExecutionTimeInMilliseconds() == -1);
            assertTrue(command2.isResponseFromCache());

            assertTrue(command3.isResponseFromCache());
            assertTrue(command3.getExecutionTimeInMilliseconds() == -1);
            assertTrue(command4.isResponseFromCache());
            assertTrue(command4.getExecutionTimeInMilliseconds() == -1);

            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            System.out.println("HystrixRequestLog: " + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testNoRequestCache3() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommand command1 = new SuccessfulCacheableCommand(circuitBreaker, false, "A");
            SuccessfulCacheableCommand command2 = new SuccessfulCacheableCommand(circuitBreaker, false, "B");
            SuccessfulCacheableCommand command3 = new SuccessfulCacheableCommand(circuitBreaker, false, "A");

            assertTrue(command1.isCommandRunningInThread());

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("A", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertTrue(command1.executed);
            // both should execute as they are different
            assertTrue(command2.executed);
            // this should also execute since we disabled the cache
            assertTrue(command3.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command2 should show a SUCCESS
            assertEquals(1, command2.getExecutionEvents().size());
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command3 should show a SUCCESS
            assertEquals(1, command3.getExecutionEvents().size());
            assertTrue(command3.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testRequestCacheViaQueueSemaphore1() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommandViaSemaphore command1 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, true, "A");
            SuccessfulCacheableCommandViaSemaphore command2 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, true, "B");
            SuccessfulCacheableCommandViaSemaphore command3 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, true, "A");

            assertFalse(command1.isCommandRunningInThread());

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("A", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertTrue(command1.executed);
            // both should execute as they are different
            assertTrue(command2.executed);
            // but the 3rd should come from cache
            assertFalse(command3.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command2 should show a SUCCESS
            assertEquals(1, command2.getExecutionEvents().size());
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command3 should show it comes from cache
            assertEquals(2, command3.getExecutionEvents().size()); // it will include the SUCCESS + RESPONSE_FROM_CACHE
            assertTrue(command3.getExecutionEvents().contains(HystrixEventType.SUCCESS));
            assertTrue(command3.getExecutionEvents().contains(HystrixEventType.RESPONSE_FROM_CACHE));

            assertTrue(command3.isResponseFromCache());
            assertTrue(command3.getExecutionTimeInMilliseconds() == -1);

            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testNoRequestCacheViaQueueSemaphore1() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommandViaSemaphore command1 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, false, "A");
            SuccessfulCacheableCommandViaSemaphore command2 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, false, "B");
            SuccessfulCacheableCommandViaSemaphore command3 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, false, "A");

            assertFalse(command1.isCommandRunningInThread());

            Future<String> f1 = command1.queue();
            Future<String> f2 = command2.queue();
            Future<String> f3 = command3.queue();

            try {
                assertEquals("A", f1.get());
                assertEquals("B", f2.get());
                assertEquals("A", f3.get());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertTrue(command1.executed);
            // both should execute as they are different
            assertTrue(command2.executed);
            // this should also execute because caching is disabled
            assertTrue(command3.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command2 should show a SUCCESS
            assertEquals(1, command2.getExecutionEvents().size());
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command3 should show a SUCCESS
            assertEquals(1, command3.getExecutionEvents().size());
            assertTrue(command3.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testRequestCacheViaExecuteSemaphore1() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommandViaSemaphore command1 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, true, "A");
            SuccessfulCacheableCommandViaSemaphore command2 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, true, "B");
            SuccessfulCacheableCommandViaSemaphore command3 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, true, "A");

            assertFalse(command1.isCommandRunningInThread());

            String f1 = command1.execute();
            String f2 = command2.execute();
            String f3 = command3.execute();

            assertEquals("A", f1);
            assertEquals("B", f2);
            assertEquals("A", f3);

            assertTrue(command1.executed);
            // both should execute as they are different
            assertTrue(command2.executed);
            // but the 3rd should come from cache
            assertFalse(command3.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command2 should show a SUCCESS
            assertEquals(1, command2.getExecutionEvents().size());
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command3 should show it comes from cache
            assertEquals(2, command3.getExecutionEvents().size()); // it will include the SUCCESS + RESPONSE_FROM_CACHE
            assertTrue(command3.getExecutionEvents().contains(HystrixEventType.RESPONSE_FROM_CACHE));

            assertEquals(2, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test Request scoped caching with a mixture of commands
         */
        @Test
        public void testNoRequestCacheViaExecuteSemaphore1() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SuccessfulCacheableCommandViaSemaphore command1 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, false, "A");
            SuccessfulCacheableCommandViaSemaphore command2 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, false, "B");
            SuccessfulCacheableCommandViaSemaphore command3 = new SuccessfulCacheableCommandViaSemaphore(circuitBreaker, false, "A");

            assertFalse(command1.isCommandRunningInThread());

            String f1 = command1.execute();
            String f2 = command2.execute();
            String f3 = command3.execute();

            assertEquals("A", f1);
            assertEquals("B", f2);
            assertEquals("A", f3);

            assertTrue(command1.executed);
            // both should execute as they are different
            assertTrue(command2.executed);
            // this should also execute because caching is disabled
            assertTrue(command3.executed);

            // the execution log for command1 should show a SUCCESS
            assertEquals(1, command1.getExecutionEvents().size());
            assertTrue(command1.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command2 should show a SUCCESS
            assertEquals(1, command2.getExecutionEvents().size());
            assertTrue(command2.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            // the execution log for command3 should show a SUCCESS
            assertEquals(1, command3.getExecutionEvents().size());
            assertTrue(command3.getExecutionEvents().contains(HystrixEventType.SUCCESS));

            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(0, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(3, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testNoRequestCacheOnTimeoutThrowsException() throws Exception {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            NoRequestCacheTimeoutWithoutFallback r1 = new NoRequestCacheTimeoutWithoutFallback(circuitBreaker);
            try {
                System.out.println("r1 value: " + r1.execute());
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (HystrixRuntimeException e) {
                assertTrue(r1.isResponseTimedOut());
                // what we want
            }

            NoRequestCacheTimeoutWithoutFallback r2 = new NoRequestCacheTimeoutWithoutFallback(circuitBreaker);
            try {
                r2.execute();
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (HystrixRuntimeException e) {
                assertTrue(r2.isResponseTimedOut());
                // what we want
            }

            NoRequestCacheTimeoutWithoutFallback r3 = new NoRequestCacheTimeoutWithoutFallback(circuitBreaker);
            Future<Boolean> f3 = r3.queue();
            try {
                f3.get();
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (ExecutionException e) {
                e.printStackTrace();
                assertTrue(r3.isResponseTimedOut());
                // what we want
            }

            Thread.sleep(500); // timeout on command is set to 200ms

            NoRequestCacheTimeoutWithoutFallback r4 = new NoRequestCacheTimeoutWithoutFallback(circuitBreaker);
            try {
                r4.execute();
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (HystrixRuntimeException e) {
                assertTrue(r4.isResponseTimedOut());
                assertFalse(r4.isResponseFromFallback());
                // what we want
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(4, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(4, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestCacheOnTimeoutCausesNullPointerException() throws Exception {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            // Expect it to time out - all results should be false
            assertFalse(new RequestCacheNullPointerExceptionCase(circuitBreaker).execute());
            assertFalse(new RequestCacheNullPointerExceptionCase(circuitBreaker).execute()); // return from cache #1
            assertFalse(new RequestCacheNullPointerExceptionCase(circuitBreaker).execute()); // return from cache #2
            Thread.sleep(500); // timeout on command is set to 200ms
            Boolean value = new RequestCacheNullPointerExceptionCase(circuitBreaker).execute(); // return from cache #3
            assertFalse(value);
            RequestCacheNullPointerExceptionCase c = new RequestCacheNullPointerExceptionCase(circuitBreaker);
            Future<Boolean> f = c.queue(); // return from cache #4
            // the bug is that we're getting a null Future back, rather than a Future that returns false
            assertNotNull(f);
            assertFalse(f.get());

            assertTrue(c.isResponseFromFallback());
            assertTrue(c.isResponseTimedOut());
            assertFalse(c.isFailedExecution());
            assertFalse(c.isResponseShortCircuited());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(4, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(5, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());

            HystrixCommand<?>[] executeCommands = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[] {});

            System.out.println(":executeCommands[0].getExecutionEvents()" + executeCommands[0].getExecutionEvents());
            assertEquals(2, executeCommands[0].getExecutionEvents().size());
            assertTrue(executeCommands[0].getExecutionEvents().contains(HystrixEventType.FALLBACK_SUCCESS));
            assertTrue(executeCommands[0].getExecutionEvents().contains(HystrixEventType.TIMEOUT));
            assertTrue(executeCommands[0].getExecutionTimeInMilliseconds() > -1);
            assertTrue(executeCommands[0].isResponseTimedOut());
            assertTrue(executeCommands[0].isResponseFromFallback());
            assertFalse(executeCommands[0].isResponseFromCache());

            assertEquals(3, executeCommands[1].getExecutionEvents().size()); // it will include FALLBACK_SUCCESS/TIMEOUT + RESPONSE_FROM_CACHE
            assertTrue(executeCommands[1].getExecutionEvents().contains(HystrixEventType.RESPONSE_FROM_CACHE));
            assertTrue(executeCommands[1].getExecutionTimeInMilliseconds() == -1);
            assertTrue(executeCommands[1].isResponseFromCache());
            assertTrue(executeCommands[1].isResponseTimedOut());
            assertTrue(executeCommands[1].isResponseFromFallback());
        }

        @Test
        public void testRequestCacheOnTimeoutThrowsException() throws Exception {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            RequestCacheTimeoutWithoutFallback r1 = new RequestCacheTimeoutWithoutFallback(circuitBreaker);
            try {
                System.out.println("r1 value: " + r1.execute());
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (HystrixRuntimeException e) {
                assertTrue(r1.isResponseTimedOut());
                // what we want
            }

            RequestCacheTimeoutWithoutFallback r2 = new RequestCacheTimeoutWithoutFallback(circuitBreaker);
            try {
                r2.execute();
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (HystrixRuntimeException e) {
                assertTrue(r2.isResponseTimedOut());
                // what we want
            }

            RequestCacheTimeoutWithoutFallback r3 = new RequestCacheTimeoutWithoutFallback(circuitBreaker);
            Future<Boolean> f3 = r3.queue();
            try {
                f3.get();
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (ExecutionException e) {
                e.printStackTrace();
                assertTrue(r3.isResponseTimedOut());
                // what we want
            }

            Thread.sleep(500); // timeout on command is set to 200ms

            RequestCacheTimeoutWithoutFallback r4 = new RequestCacheTimeoutWithoutFallback(circuitBreaker);
            try {
                r4.execute();
                // we should have thrown an exception
                fail("expected a timeout");
            } catch (HystrixRuntimeException e) {
                assertTrue(r4.isResponseTimedOut());
                assertFalse(r4.isResponseFromFallback());
                // what we want
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testRequestCacheOnThreadRejectionThrowsException() throws Exception {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            CountDownLatch completionLatch = new CountDownLatch(1);
            RequestCacheThreadRejectionWithoutFallback r1 = new RequestCacheThreadRejectionWithoutFallback(circuitBreaker, completionLatch);
            try {
                System.out.println("r1: " + r1.execute());
                // we should have thrown an exception
                fail("expected a rejection");
            } catch (HystrixRuntimeException e) {
                assertTrue(r1.isResponseRejected());
                // what we want
            }

            RequestCacheThreadRejectionWithoutFallback r2 = new RequestCacheThreadRejectionWithoutFallback(circuitBreaker, completionLatch);
            try {
                System.out.println("r2: " + r2.execute());
                // we should have thrown an exception
                fail("expected a rejection");
            } catch (HystrixRuntimeException e) {
                //                e.printStackTrace();
                assertTrue(r2.isResponseRejected());
                // what we want
            }

            RequestCacheThreadRejectionWithoutFallback r3 = new RequestCacheThreadRejectionWithoutFallback(circuitBreaker, completionLatch);
            try {
                System.out.println("f3: " + r3.queue().get());
                // we should have thrown an exception
                fail("expected a rejection");
            } catch (HystrixRuntimeException e) {
                //                e.printStackTrace();
                assertTrue(r3.isResponseRejected());
                // what we want
            }

            // let the command finish (only 1 should actually be blocked on this due to the response cache)
            completionLatch.countDown();

            // then another after the command has completed
            RequestCacheThreadRejectionWithoutFallback r4 = new RequestCacheThreadRejectionWithoutFallback(circuitBreaker, completionLatch);
            try {
                System.out.println("r4: " + r4.execute());
                // we should have thrown an exception
                fail("expected a rejection");
            } catch (HystrixRuntimeException e) {
                //                e.printStackTrace();
                assertTrue(r4.isResponseRejected());
                assertFalse(r4.isResponseFromFallback());
                // what we want
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(3, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, circuitBreaker.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(4, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /**
         * Test that we can do basic execution without a RequestVariable being initialized.
         */
        @Test
        public void testBasicExecutionWorksWithoutRequestVariable() {
            try {
                /* force the RequestVariable to not be initialized */
                HystrixRequestContext.setContextOnCurrentThread(null);

                TestHystrixCommand<Boolean> command = new SuccessfulTestCommand();
                assertEquals(true, command.execute());

                TestHystrixCommand<Boolean> command2 = new SuccessfulTestCommand();
                assertEquals(true, command2.queue().get());

                // we should be able to execute without a RequestVariable if ...
                // 1) We don't have a cacheKey
                // 2) We don't ask for the RequestLog
                // 3) We don't do collapsing

            } catch (Exception e) {
                e.printStackTrace();
                fail("We received an exception => " + e.getMessage());
            }
        }

        /**
         * Test that if we try and execute a command with a cacheKey without initializing RequestVariable that it gives an error.
         */
        @Test
        public void testCacheKeyExecutionRequiresRequestVariable() {
            try {
                /* force the RequestVariable to not be initialized */
                HystrixRequestContext.setContextOnCurrentThread(null);

                TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();

                SuccessfulCacheableCommand command = new SuccessfulCacheableCommand(circuitBreaker, true, "one");
                assertEquals(true, command.execute());

                SuccessfulCacheableCommand command2 = new SuccessfulCacheableCommand(circuitBreaker, true, "two");
                assertEquals(true, command2.queue().get());

                fail("We expect an exception because cacheKey requires RequestVariable.");

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        /**
         * Test that a BadRequestException can be thrown and not count towards errors and bypasses fallback.
         */
        @Test
        public void testBadRequestExceptionViaExecuteInThread() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            try {
                new BadRequestCommand(circuitBreaker, ExecutionIsolationStrategy.THREAD).execute();
                fail("we expect to receive a " + HystrixBadRequestException.class.getSimpleName());
            } catch (HystrixBadRequestException e) {
                // success
                e.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
                fail("We expect a " + HystrixBadRequestException.class.getSimpleName() + " but got a " + e.getClass().getSimpleName());
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
        }

        /**
         * Test that a BadRequestException can be thrown and not count towards errors and bypasses fallback.
         */
        @Test
        public void testBadRequestExceptionViaQueueInThread() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            try {
                new BadRequestCommand(circuitBreaker, ExecutionIsolationStrategy.THREAD).queue().get();
                fail("we expect to receive a " + HystrixBadRequestException.class.getSimpleName());
            } catch (ExecutionException e) {
                e.printStackTrace();
                if (e.getCause() instanceof HystrixBadRequestException) {
                    // success    
                } else {
                    fail("We expect a " + HystrixBadRequestException.class.getSimpleName() + " but got a " + e.getClass().getSimpleName());
                }
            } catch (Exception e) {
                e.printStackTrace();
                fail();
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
        }
        
        /**
         * Test that BadRequestException behavior works the same on a cached response.
         */
        @Test
        public void testBadRequestExceptionViaQueueInThreadOnResponseFromCache() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();

            // execute once to cache the value
            try {
                new BadRequestCommand(circuitBreaker, ExecutionIsolationStrategy.THREAD).execute();
            } catch (Throwable e) {
                // ignore
            }

            try {
                new BadRequestCommand(circuitBreaker, ExecutionIsolationStrategy.THREAD).queue().get();
                fail("we expect to receive a " + HystrixBadRequestException.class.getSimpleName());
            } catch (ExecutionException e) {
                e.printStackTrace();
                if (e.getCause() instanceof HystrixBadRequestException) {
                    // success    
                } else {
                    fail("We expect a " + HystrixBadRequestException.class.getSimpleName() + " but got a " + e.getClass().getSimpleName());
                }
            } catch (Exception e) {
                e.printStackTrace();
                fail();
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
        }

        /**
         * Test that a BadRequestException can be thrown and not count towards errors and bypasses fallback.
         */
        @Test
        public void testBadRequestExceptionViaExecuteInSemaphore() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            try {
                new BadRequestCommand(circuitBreaker, ExecutionIsolationStrategy.SEMAPHORE).execute();
                fail("we expect to receive a " + HystrixBadRequestException.class.getSimpleName());
            } catch (HystrixBadRequestException e) {
                // success
                e.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
                fail("We expect a " + HystrixBadRequestException.class.getSimpleName() + " but got a " + e.getClass().getSimpleName());
            }

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
        }

        /**
         * Test that a BadRequestException can be thrown and not count towards errors and bypasses fallback.
         */
        @Test
        public void testBadRequestExceptionViaQueueInSemaphore() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            try {
                new BadRequestCommand(circuitBreaker, ExecutionIsolationStrategy.SEMAPHORE).queue().get();
                fail("we expect to receive a " + HystrixBadRequestException.class.getSimpleName());
            } catch (ExecutionException e) {
                e.printStackTrace();
                if (e.getCause() instanceof HystrixBadRequestException) {
                    // success    
                } else {
                    fail("We expect a " + HystrixBadRequestException.class.getSimpleName() + " but got a " + e.getClass().getSimpleName());
                }
            } catch (Exception e) {
                e.printStackTrace();
                fail();
            }
            
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
        }

        /**
         * Test a checked Exception being thrown
         */
        @Test
        public void testCheckedExceptionViaExecute() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            CommandWithCheckedException command = new CommandWithCheckedException(circuitBreaker);
            try {
                command.execute();
                fail("we expect to receive a " + Exception.class.getSimpleName());
            } catch (Exception e) {
                assertEquals("simulated checked exception message", e.getCause().getMessage());
            }

            assertEquals("simulated checked exception message", command.getFailedExecutionException().getMessage());

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
        }

        /**
         * Test a java.lang.Error being thrown
         * 
         * @throws InterruptedException
         */
        @Test
        public void testCheckedExceptionViaObserve() throws InterruptedException {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            CommandWithCheckedException command = new CommandWithCheckedException(circuitBreaker);
            final AtomicReference<Throwable> t = new AtomicReference<Throwable>();
            final CountDownLatch latch = new CountDownLatch(1);
            try {
                command.observe().subscribe(new Observer<Boolean>() {

                    @Override
                    public void onCompleted() {
                        latch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        t.set(e);
                        latch.countDown();
                    }

                    @Override
                    public void onNext(Boolean args) {

                    }

                });
            } catch (Exception e) {
                e.printStackTrace();
                fail("we should not get anything thrown, it should be emitted via the Observer#onError method");
            }

            latch.await(1, TimeUnit.SECONDS);
            assertNotNull(t.get());
            t.get().printStackTrace();

            assertTrue(t.get() instanceof HystrixRuntimeException);
            assertEquals("simulated checked exception message", t.get().getCause().getMessage());
            assertEquals("simulated checked exception message", command.getFailedExecutionException().getMessage());

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
        }

        /**
         * Test a java.lang.Error being thrown
         */
        @Test
        public void testErrorThrownViaExecute() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            CommandWithErrorThrown command = new CommandWithErrorThrown(circuitBreaker);
            try {
                command.execute();
                fail("we expect to receive a " + Error.class.getSimpleName());
            } catch (Exception e) {
                // the actual error is an extra cause level deep because Hystrix needs to wrap Throwable/Error as it's public
                // methods only support Exception and it's not a strong enough reason to break backwards compatibility and jump to version 2.x
                // so HystrixRuntimeException -> wrapper Exception -> actual Error
                assertEquals("simulated java.lang.Error message", e.getCause().getCause().getMessage());
            }

            assertEquals("simulated java.lang.Error message", command.getFailedExecutionException().getCause().getMessage());

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
        }

        /**
         * Test a java.lang.Error being thrown
         */
        @Test
        public void testErrorThrownViaQueue() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            CommandWithErrorThrown command = new CommandWithErrorThrown(circuitBreaker);
            try {
                command.queue().get();
                fail("we expect to receive an Exception");
            } catch (Exception e) {
                // one cause down from ExecutionException to HystrixRuntime
                // then the actual error is an extra cause level deep because Hystrix needs to wrap Throwable/Error as it's public
                // methods only support Exception and it's not a strong enough reason to break backwards compatibility and jump to version 2.x
                // so ExecutionException -> HystrixRuntimeException -> wrapper Exception -> actual Error
                assertEquals("simulated java.lang.Error message", e.getCause().getCause().getCause().getMessage());
            }

            assertEquals("simulated java.lang.Error message", command.getFailedExecutionException().getCause().getMessage());

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
        }

        /**
         * Test a java.lang.Error being thrown
         * 
         * @throws InterruptedException
         */
        @Test
        public void testErrorThrownViaObserve() throws InterruptedException {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            CommandWithErrorThrown command = new CommandWithErrorThrown(circuitBreaker);
            final AtomicReference<Throwable> t = new AtomicReference<Throwable>();
            final CountDownLatch latch = new CountDownLatch(1);
            try {
                command.observe().subscribe(new Observer<Boolean>() {

                    @Override
                    public void onCompleted() {
                        latch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        t.set(e);
                        latch.countDown();
                    }

                    @Override
                    public void onNext(Boolean args) {

                    }

                });
            } catch (Exception e) {
                e.printStackTrace();
                fail("we should not get anything thrown, it should be emitted via the Observer#onError method");
            }

            latch.await(1, TimeUnit.SECONDS);
            assertNotNull(t.get());
            t.get().printStackTrace();

            assertTrue(t.get() instanceof HystrixRuntimeException);
            // the actual error is an extra cause level deep because Hystrix needs to wrap Throwable/Error as it's public
            // methods only support Exception and it's not a strong enough reason to break backwards compatibility and jump to version 2.x
            assertEquals("simulated java.lang.Error message", t.get().getCause().getCause().getMessage());
            assertEquals("simulated java.lang.Error message", command.getFailedExecutionException().getCause().getMessage());

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isFailedExecution());

            assertEquals(0, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(1, circuitBreaker.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
        }

        /**
         * Execution hook on successful execution
         */
        @Test
        public void testExecutionHookSuccessfulCommand() {
            /* test with execute() */
            TestHystrixCommand<Boolean> command = new SuccessfulTestCommand();
            command.execute();

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we expect a successful response from run()
            assertNotNull(command.builder.executionHook.runSuccessResponse);
            // we do not expect an exception
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should not be run as we were successful
            assertEquals(0, command.builder.executionHook.startFallback.get());
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the execute() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from execute() since run() succeeded
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception since run() succeeded
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());

            /* test with queue() */
            command = new SuccessfulTestCommand();
            try {
                command.queue().get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we expect a successful response from run()
            assertNotNull(command.builder.executionHook.runSuccessResponse);
            // we do not expect an exception
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should not be run as we were successful
            assertEquals(0, command.builder.executionHook.startFallback.get());
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the queue() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from queue() since run() succeeded
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception since run() succeeded
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on successful execution with "fire and forget" approach
         */
        @Test
        public void testExecutionHookSuccessfulCommandViaFireAndForget() {
            TestHystrixCommand<Boolean> command = new SuccessfulTestCommand();
            try {
                // do not block on "get()" ... fire this asynchronously
                command.queue();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // wait for command to execute without calling get on the future
            while (!command.isExecutionComplete()) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException("interrupted");
                }
            }

            /*
             * All the hooks should still work even though we didn't call get() on the future
             */

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we expect a successful response from run()
            assertNotNull(command.builder.executionHook.runSuccessResponse);
            // we do not expect an exception
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should not be run as we were successful
            assertEquals(0, command.builder.executionHook.startFallback.get());
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the queue() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from queue() since run() succeeded
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception since run() succeeded
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on successful execution with multiple get() calls to Future
         */
        @Test
        public void testExecutionHookSuccessfulCommandWithMultipleGetsOnFuture() {
            TestHystrixCommand<Boolean> command = new SuccessfulTestCommand();
            try {
                Future<Boolean> f = command.queue();
                f.get();
                f.get();
                f.get();
                f.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            /*
             * Despite multiple calls to get() we should only have 1 call to the hooks.
             */

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we expect a successful response from run()
            assertNotNull(command.builder.executionHook.runSuccessResponse);
            // we do not expect an exception
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should not be run as we were successful
            assertEquals(0, command.builder.executionHook.startFallback.get());
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the queue() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from queue() since run() succeeded
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception since run() succeeded
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on failed execution without a fallback
         */
        @Test
        public void testExecutionHookRunFailureWithoutFallback() {
            /* test with execute() */
            TestHystrixCommand<Boolean> command = new UnknownFailureTestCommandWithoutFallback();
            try {
                command.execute();
                fail("Expecting exception");
            } catch (Exception e) {
                // ignore
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should have an exception
            assertNotNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run since run() failed
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // no response since fallback is not implemented
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since it's not implemented and throws an exception
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // the execute() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response from execute() since we do not have a fallback and run() failed
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should have an exception since run() failed
            assertNotNull(command.builder.executionHook.endExecuteFailureException);
            // run() failure
            assertEquals(FailureType.COMMAND_EXCEPTION, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());

            /* test with queue() */
            command = new UnknownFailureTestCommandWithoutFallback();
            try {
                command.queue().get();
                fail("Expecting exception");
            } catch (Exception e) {
                // ignore
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should have an exception
            assertNotNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run since run() failed
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // no response since fallback is not implemented
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since it's not implemented and throws an exception
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // the queue() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response from queue() since we do not have a fallback and run() failed
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should have an exception since run() failed
            assertNotNull(command.builder.executionHook.endExecuteFailureException);
            // run() failure
            assertEquals(FailureType.COMMAND_EXCEPTION, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());

        }

        /**
         * Execution hook on failed execution with a fallback
         */
        @Test
        public void testExecutionHookRunFailureWithFallback() {
            /* test with execute() */
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithFallback(new TestCircuitBreaker());
            command.execute();

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response from run since run() failed
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should have an exception since run() failed
            assertNotNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run since run() failed
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // a response since fallback is implemented
            assertNotNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it's implemented and succeeds
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the execute() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from execute() since we expect a fallback despite failure of run()
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception because we expect a fallback
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());

            /* test with queue() */
            command = new KnownFailureTestCommandWithFallback(new TestCircuitBreaker());
            try {
                command.queue().get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response from run since run() failed
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should have an exception since run() failed
            assertNotNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run since run() failed
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // a response since fallback is implemented
            assertNotNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it's implemented and succeeds
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the queue() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from queue() since we expect a fallback despite failure of run()
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception because we expect a fallback
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on failed execution with a fallback failure
         */
        @Test
        public void testExecutionHookRunFailureWithFallbackFailure() {
            /* test with execute() */
            TestHystrixCommand<Boolean> command = new KnownFailureTestCommandWithFallbackFailure();
            try {
                command.execute();
                fail("Expecting exception");
            } catch (Exception e) {
                // ignore
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response because run() and fallback fail
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should have an exception because run() and fallback fail
            assertNotNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run since run() failed
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // no response since fallback fails
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since it's implemented but fails
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // the execute() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response because run() and fallback fail
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should have an exception because run() and fallback fail
            assertNotNull(command.builder.executionHook.endExecuteFailureException);
            // run() failure
            assertEquals(FailureType.COMMAND_EXCEPTION, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());

            /* test with queue() */
            command = new KnownFailureTestCommandWithFallbackFailure();
            try {
                command.queue().get();
                fail("Expecting exception");
            } catch (Exception e) {
                // ignore
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response because run() and fallback fail
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should have an exception because run() and fallback fail
            assertNotNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run since run() failed
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // no response since fallback fails
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since it's implemented but fails
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // the queue() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response because run() and fallback fail
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should have an exception because run() and fallback fail
            assertNotNull(command.builder.executionHook.endExecuteFailureException);
            // run() failure
            assertEquals(FailureType.COMMAND_EXCEPTION, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());
            assertEquals(1, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on timeout without a fallback
         */
        @Test
        public void testExecutionHookTimeoutWithoutFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_NOT_IMPLEMENTED);
            try {
                command.queue().get();
                fail("Expecting exception");
            } catch (Exception e) {
                // ignore
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response because of timeout and no fallback
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should not have an exception because run() didn't fail, it timed out
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run due to timeout
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // no response since no fallback
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since no fallback implementation
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // execution occurred
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response because of timeout and no fallback
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should have an exception because of timeout and no fallback
            assertNotNull(command.builder.executionHook.endExecuteFailureException);
            // timeout failure
            assertEquals(FailureType.TIMEOUT, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());

            // we need to wait for the thread to complete before the onThreadComplete hook will be called
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                // ignore
            }
            assertEquals(1, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on timeout with a fallback
         */
        @Test
        public void testExecutionHookTimeoutWithFallback() {
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_SUCCESS);
            try {
                command.queue().get();
            } catch (Exception e) {
                throw new RuntimeException("not expecting", e);
            }

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we should not have a response because of timeout
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should not have an exception because run() didn't fail, it timed out
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run due to timeout
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // response since we have a fallback
            assertNotNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since fallback succeeds
            assertNull(command.builder.executionHook.fallbackFailureException);

            // execution occurred
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response because of fallback
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception because of fallback
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(1, command.builder.executionHook.threadStart.get());

            // we need to wait for the thread to complete before the onThreadComplete hook will be called
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                // ignore
            }
            assertEquals(1, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on rejected with a fallback
         */
        @Test
        public void testExecutionHookRejectedWithFallback() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
            SingleThreadedPool pool = new SingleThreadedPool(1);

            try {
                // fill the queue
                new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_SUCCESS).queue();
                new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_SUCCESS).queue();
            } catch (Exception e) {
                // ignore
            }

            TestCommandRejection command = new TestCommandRejection(circuitBreaker, pool, 500, 600, TestCommandRejection.FALLBACK_SUCCESS);
            try {
                // now execute one that will be rejected
                command.queue().get();
            } catch (Exception e) {
                throw new RuntimeException("not expecting", e);
            }

            assertTrue(command.isResponseRejected());

            // the run() method should not run as we're rejected
            assertEquals(0, command.builder.executionHook.startRun.get());
            // we should not have a response because of rejection
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should not have an exception because we didn't run
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run due to rejection
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // response since we have a fallback
            assertNotNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since fallback succeeds
            assertNull(command.builder.executionHook.fallbackFailureException);

            // execution occurred
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response because of fallback
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception because of fallback
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(0, command.builder.executionHook.threadStart.get());
            assertEquals(0, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on short-circuit with a fallback
         */
        @Test
        public void testExecutionHookShortCircuitedWithFallbackViaQueue() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker().setForceShortCircuit(true);
            KnownFailureTestCommandWithoutFallback command = new KnownFailureTestCommandWithoutFallback(circuitBreaker);
            try {
                // now execute one that will be short-circuited
                command.queue().get();
                fail("we expect an error as there is no fallback");
            } catch (Exception e) {
                // expecting
            }

            assertTrue(command.isResponseShortCircuited());

            // the run() method should not run as we're rejected
            assertEquals(0, command.builder.executionHook.startRun.get());
            // we should not have a response because of rejection
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should not have an exception because we didn't run
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run due to rejection
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // no response since we don't have a fallback
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since fallback fails and throws an exception
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // execution occurred
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response because fallback fails
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we won't have an exception because short-circuit doesn't have one
            assertNull(command.builder.executionHook.endExecuteFailureException);
            // but we do expect to receive a onError call with FailureType.SHORTCIRCUIT
            assertEquals(FailureType.SHORTCIRCUIT, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(0, command.builder.executionHook.threadStart.get());
            assertEquals(0, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on short-circuit with a fallback
         */
        @Test
        public void testExecutionHookShortCircuitedWithFallbackViaExecute() {
            TestCircuitBreaker circuitBreaker = new TestCircuitBreaker().setForceShortCircuit(true);
            KnownFailureTestCommandWithoutFallback command = new KnownFailureTestCommandWithoutFallback(circuitBreaker);
            try {
                // now execute one that will be short-circuited
                command.execute();
                fail("we expect an error as there is no fallback");
            } catch (Exception e) {
                // expecting
            }

            assertTrue(command.isResponseShortCircuited());

            // the run() method should not run as we're rejected
            assertEquals(0, command.builder.executionHook.startRun.get());
            // we should not have a response because of rejection
            assertNull(command.builder.executionHook.runSuccessResponse);
            // we should not have an exception because we didn't run
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should be run due to rejection
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // no response since we don't have a fallback
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since fallback fails and throws an exception
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // execution occurred
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response because fallback fails
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we won't have an exception because short-circuit doesn't have one
            assertNull(command.builder.executionHook.endExecuteFailureException);
            // but we do expect to receive a onError call with FailureType.SHORTCIRCUIT
            assertEquals(FailureType.SHORTCIRCUIT, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(0, command.builder.executionHook.threadStart.get());
            assertEquals(0, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on successful execution with semaphore isolation
         */
        @Test
        public void testExecutionHookSuccessfulCommandWithSemaphoreIsolation() {
            /* test with execute() */
            TestSemaphoreCommand command = new TestSemaphoreCommand(new TestCircuitBreaker(), 1, 10);
            command.execute();

            assertFalse(command.isExecutedInThread());

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we expect a successful response from run()
            assertNotNull(command.builder.executionHook.runSuccessResponse);
            // we do not expect an exception
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should not be run as we were successful
            assertEquals(0, command.builder.executionHook.startFallback.get());
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the execute() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from execute() since run() succeeded
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception since run() succeeded
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(0, command.builder.executionHook.threadStart.get());
            assertEquals(0, command.builder.executionHook.threadComplete.get());

            /* test with queue() */
            command = new TestSemaphoreCommand(new TestCircuitBreaker(), 1, 10);
            try {
                command.queue().get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            assertFalse(command.isExecutedInThread());

            // the run() method should run as we're not short-circuited or rejected
            assertEquals(1, command.builder.executionHook.startRun.get());
            // we expect a successful response from run()
            assertNotNull(command.builder.executionHook.runSuccessResponse);
            // we do not expect an exception
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should not be run as we were successful
            assertEquals(0, command.builder.executionHook.startFallback.get());
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // null since it didn't run
            assertNull(command.builder.executionHook.fallbackFailureException);

            // the queue() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should have a response from queue() since run() succeeded
            assertNotNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we should not have an exception since run() succeeded
            assertNull(command.builder.executionHook.endExecuteFailureException);

            // thread execution
            assertEquals(0, command.builder.executionHook.threadStart.get());
            assertEquals(0, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Execution hook on successful execution with semaphore isolation
         */
        @Test
        public void testExecutionHookFailureWithSemaphoreIsolation() {
            /* test with execute() */
            final TryableSemaphore semaphore =
                    new TryableSemaphore(HystrixProperty.Factory.asProperty(0));

            TestSemaphoreCommand command = new TestSemaphoreCommand(new TestCircuitBreaker(), semaphore, 200);
            try {
                command.execute();
                fail("we expect a failure");
            } catch (Exception e) {
                // expected
            }

            assertFalse(command.isExecutedInThread());
            assertTrue(command.isResponseRejected());

            // the run() method should not run as we are rejected
            assertEquals(0, command.builder.executionHook.startRun.get());
            // null as run() does not get invoked
            assertNull(command.builder.executionHook.runSuccessResponse);
            // null as run() does not get invoked
            assertNull(command.builder.executionHook.runFailureException);

            // the fallback() method should run because of rejection
            assertEquals(1, command.builder.executionHook.startFallback.get());
            // null since there is no fallback
            assertNull(command.builder.executionHook.fallbackSuccessResponse);
            // not null since the fallback is not implemented
            assertNotNull(command.builder.executionHook.fallbackFailureException);

            // the execute() method was used
            assertEquals(1, command.builder.executionHook.startExecute.get());
            // we should not have a response since fallback has nothing
            assertNull(command.builder.executionHook.endExecuteSuccessResponse);
            // we won't have an exception because rejection doesn't have one
            assertNull(command.builder.executionHook.endExecuteFailureException);
            // but we do expect to receive a onError call with FailureType.SHORTCIRCUIT
            assertEquals(FailureType.REJECTED_SEMAPHORE_EXECUTION, command.builder.executionHook.endExecuteFailureType);

            // thread execution
            assertEquals(0, command.builder.executionHook.threadStart.get());
            assertEquals(0, command.builder.executionHook.threadComplete.get());
        }

        /**
         * Test a command execution that fails but has a fallback.
         */
        @Test
        public void testExecutionFailureWithFallbackImplementedButDisabled() {
            TestHystrixCommand<Boolean> commandEnabled = new KnownFailureTestCommandWithFallback(new TestCircuitBreaker(), true);
            try {
                assertEquals(false, commandEnabled.execute());
            } catch (Exception e) {
                e.printStackTrace();
                fail("We should have received a response from the fallback.");
            }

            TestHystrixCommand<Boolean> commandDisabled = new KnownFailureTestCommandWithFallback(new TestCircuitBreaker(), false);
            try {
                assertEquals(false, commandDisabled.execute());
                fail("expect exception thrown");
            } catch (Exception e) {
                // expected
            }

            assertEquals("we failed with a simulated issue", commandDisabled.getFailedExecutionException().getMessage());

            assertTrue(commandDisabled.isFailedExecution());

            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(1, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, commandDisabled.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, commandDisabled.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(2, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        @Test
        public void testExecutionTimeoutValue() {
            HystrixCommand.Setter properties = HystrixCommand.Setter
                    .withGroupKey(HystrixCommandGroupKey.Factory.asKey("TestKey"))
                    .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                            .withExecutionIsolationThreadTimeoutInMilliseconds(50));

            HystrixCommand<String> command = new HystrixCommand<String>(properties) {
                @Override
                protected String run() throws Exception {
                    Thread.sleep(3000);
                    // should never reach here
                    return "hello";
                }

                @Override
                protected String getFallback() {
                    if (isResponseTimedOut()) {
                        return "timed-out";
                    } else {
                        return "abc";
                    }
                }
            };

            String value = command.execute();
            assertTrue(command.isResponseTimedOut());
            assertEquals("expected fallback value", "timed-out", value);

        }

        /**
         * See https://github.com/Netflix/Hystrix/issues/212
         */
        @Test
        public void testObservableTimeoutNoFallbackThreadContext() {
            final AtomicReference<Thread> onErrorThread = new AtomicReference<Thread>();
            final AtomicBoolean isRequestContextInitialized = new AtomicBoolean();
            TestHystrixCommand<Boolean> command = new TestCommandWithTimeout(50, TestCommandWithTimeout.FALLBACK_NOT_IMPLEMENTED);
            try {
                command.toObservable().doOnError(new Action1<Throwable>() {

                    @Override
                    public void call(Throwable t1) {
                        System.out.println("onError: " + t1);
                        System.out.println("onError Thread: " + Thread.currentThread());
                        System.out.println("ThreadContext in onError: " + HystrixRequestContext.isCurrentThreadInitialized());
                        onErrorThread.set(Thread.currentThread());
                        isRequestContextInitialized.set(HystrixRequestContext.isCurrentThreadInitialized());
                    }

                }).toBlockingObservable().single();
                throw new RuntimeException("expected error to be thrown");
            } catch (Throwable e) {
                assertTrue(isRequestContextInitialized.get());
                assertTrue(onErrorThread.get().getName().startsWith("RxComputationThreadPool"));

                if (e instanceof HystrixRuntimeException) {
                    HystrixRuntimeException de = (HystrixRuntimeException) e;
                    assertNotNull(de.getFallbackException());
                    assertTrue(de.getFallbackException() instanceof UnsupportedOperationException);
                    assertNotNull(de.getImplementingClass());
                    assertNotNull(de.getCause());
                    assertTrue(de.getCause() instanceof TimeoutException);
                } else {
                    fail("the exception should be ExecutionException with cause as HystrixRuntimeException");
                }
            }

            assertTrue(command.getExecutionTimeInMilliseconds() > -1);
            assertTrue(command.isResponseTimedOut());

            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SUCCESS));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_SUCCESS));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SEMAPHORE_REJECTED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.SHORT_CIRCUITED));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.THREAD_POOL_REJECTED));
            assertEquals(1, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.TIMEOUT));
            assertEquals(0, command.builder.metrics.getRollingCount(HystrixRollingNumberEvent.RESPONSE_FROM_CACHE));

            assertEquals(100, command.builder.metrics.getHealthCounts().getErrorPercentage());

            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
        }

        /* ******************************************************************************** */
        /* ******************************************************************************** */
        /* private HystrixCommand class implementations for unit testing */
        /* ******************************************************************************** */
        /* ******************************************************************************** */

        /**
         * Used by UnitTest command implementations to provide base defaults for constructor and a builder pattern for the arguments being passed in.
         */
        /* package */static abstract class TestHystrixCommand<K> extends HystrixCommand<K> {

            final TestCommandBuilder builder;

            TestHystrixCommand(TestCommandBuilder builder) {
                super(builder.owner, builder.dependencyKey, builder.threadPoolKey, builder.circuitBreaker, builder.threadPool,
                        builder.commandPropertiesDefaults, builder.threadPoolPropertiesDefaults, builder.metrics,
                        builder.fallbackSemaphore, builder.executionSemaphore, TEST_PROPERTIES_FACTORY, builder.executionHook);
                this.builder = builder;
            }

            static TestCommandBuilder testPropsBuilder() {
                return new TestCommandBuilder();
            }

            static class TestCommandBuilder {
                TestCircuitBreaker _cb = new TestCircuitBreaker();
                HystrixCommandGroupKey owner = CommandGroupForUnitTest.OWNER_ONE;
                HystrixCommandKey dependencyKey = null;
                HystrixThreadPoolKey threadPoolKey = null;
                HystrixCircuitBreaker circuitBreaker = _cb;
                HystrixThreadPool threadPool = null;
                HystrixCommandProperties.Setter commandPropertiesDefaults = HystrixCommandProperties.Setter.getUnitTestPropertiesSetter();
                HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults = HystrixThreadPoolProperties.Setter.getUnitTestPropertiesBuilder();
                HystrixCommandMetrics metrics = _cb.metrics;
                TryableSemaphore fallbackSemaphore = null;
                TryableSemaphore executionSemaphore = null;
                TestExecutionHook executionHook = new TestExecutionHook();

                TestCommandBuilder setOwner(HystrixCommandGroupKey owner) {
                    this.owner = owner;
                    return this;
                }

                TestCommandBuilder setCommandKey(HystrixCommandKey dependencyKey) {
                    this.dependencyKey = dependencyKey;
                    return this;
                }

                TestCommandBuilder setThreadPoolKey(HystrixThreadPoolKey threadPoolKey) {
                    this.threadPoolKey = threadPoolKey;
                    return this;
                }

                TestCommandBuilder setCircuitBreaker(HystrixCircuitBreaker circuitBreaker) {
                    this.circuitBreaker = circuitBreaker;
                    return this;
                }

                TestCommandBuilder setThreadPool(HystrixThreadPool threadPool) {
                    this.threadPool = threadPool;
                    return this;
                }

                TestCommandBuilder setCommandPropertiesDefaults(HystrixCommandProperties.Setter commandPropertiesDefaults) {
                    this.commandPropertiesDefaults = commandPropertiesDefaults;
                    return this;
                }

                TestCommandBuilder setThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults) {
                    this.threadPoolPropertiesDefaults = threadPoolPropertiesDefaults;
                    return this;
                }

                TestCommandBuilder setMetrics(HystrixCommandMetrics metrics) {
                    this.metrics = metrics;
                    return this;
                }

                TestCommandBuilder setFallbackSemaphore(TryableSemaphore fallbackSemaphore) {
                    this.fallbackSemaphore = fallbackSemaphore;
                    return this;
                }

                TestCommandBuilder setExecutionSemaphore(TryableSemaphore executionSemaphore) {
                    this.executionSemaphore = executionSemaphore;
                    return this;
                }

            }

        }

        /**
         * Successful execution - no fallback implementation.
         */
        private static class SuccessfulTestCommand extends TestHystrixCommand<Boolean> {

            public SuccessfulTestCommand() {
                this(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter());
            }

            public SuccessfulTestCommand(HystrixCommandProperties.Setter properties) {
                super(testPropsBuilder().setCommandPropertiesDefaults(properties));
            }

            @Override
            protected Boolean run() {
                return true;
            }

        }

        /**
         * Successful execution - no fallback implementation.
         */
        private static class DynamicOwnerTestCommand extends TestHystrixCommand<Boolean> {

            public DynamicOwnerTestCommand(HystrixCommandGroupKey owner) {
                super(testPropsBuilder().setOwner(owner));
            }

            @Override
            protected Boolean run() {
                System.out.println("successfully executed");
                return true;
            }

        }

        /**
         * Successful execution - no fallback implementation.
         */
        private static class DynamicOwnerAndKeyTestCommand extends TestHystrixCommand<Boolean> {

            public DynamicOwnerAndKeyTestCommand(HystrixCommandGroupKey owner, HystrixCommandKey key) {
                super(testPropsBuilder().setOwner(owner).setCommandKey(key).setCircuitBreaker(null).setMetrics(null));
                // we specifically are NOT passing in a circuit breaker here so we test that it creates a new one correctly based on the dynamic key
            }

            @Override
            protected Boolean run() {
                System.out.println("successfully executed");
                return true;
            }

        }

        /**
         * Failed execution with unknown exception (not HystrixException) - no fallback implementation.
         */
        private static class UnknownFailureTestCommandWithoutFallback extends TestHystrixCommand<Boolean> {

            private UnknownFailureTestCommandWithoutFallback() {
                super(testPropsBuilder());
            }

            @Override
            protected Boolean run() {
                System.out.println("*** simulated failed execution ***");
                throw new RuntimeException("we failed with an unknown issue");
            }

        }

        /**
         * Failed execution with known exception (HystrixException) - no fallback implementation.
         */
        private static class KnownFailureTestCommandWithoutFallback extends TestHystrixCommand<Boolean> {

            private KnownFailureTestCommandWithoutFallback(TestCircuitBreaker circuitBreaker) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics));
            }

            @Override
            protected Boolean run() {
                System.out.println("*** simulated failed execution ***");
                throw new RuntimeException("we failed with a simulated issue");
            }

        }

        /**
         * Failed execution - fallback implementation successfully returns value.
         */
        private static class KnownFailureTestCommandWithFallback extends TestHystrixCommand<Boolean> {

            public KnownFailureTestCommandWithFallback(TestCircuitBreaker circuitBreaker) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics));
            }

            public KnownFailureTestCommandWithFallback(TestCircuitBreaker circuitBreaker, boolean fallbackEnabled) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withFallbackEnabled(fallbackEnabled)));
            }

            @Override
            protected Boolean run() {
                System.out.println("*** simulated failed execution ***");
                throw new RuntimeException("we failed with a simulated issue");
            }

            @Override
            protected Boolean getFallback() {
                return false;
            }
        }

        /**
         * Failed execution - fallback implementation throws exception.
         */
        private static class KnownFailureTestCommandWithFallbackFailure extends TestHystrixCommand<Boolean> {

            private KnownFailureTestCommandWithFallbackFailure() {
                super(testPropsBuilder());
            }

            @Override
            protected Boolean run() {
                System.out.println("*** simulated failed execution ***");
                throw new RuntimeException("we failed with a simulated issue");
            }

            @Override
            protected Boolean getFallback() {
                throw new RuntimeException("failed while getting fallback");
            }
        }

        /**
         * A Command implementation that supports caching.
         */
        private static class SuccessfulCacheableCommand extends TestHystrixCommand<String> {

            private final boolean cacheEnabled;
            private volatile boolean executed = false;
            private final String value;

            public SuccessfulCacheableCommand(TestCircuitBreaker circuitBreaker, boolean cacheEnabled, String value) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics));
                this.value = value;
                this.cacheEnabled = cacheEnabled;
            }

            @Override
            protected String run() {
                executed = true;
                System.out.println("successfully executed");
                return value;
            }

            public boolean isCommandRunningInThread() {
                return super.getProperties().executionIsolationStrategy().get().equals(ExecutionIsolationStrategy.THREAD);
            }

            @Override
            public String getCacheKey() {
                if (cacheEnabled)
                    return value;
                else
                    return null;
            }
        }

        /**
         * A Command implementation that supports caching.
         */
        private static class SuccessfulCacheableCommandViaSemaphore extends TestHystrixCommand<String> {

            private final boolean cacheEnabled;
            private volatile boolean executed = false;
            private final String value;

            public SuccessfulCacheableCommandViaSemaphore(TestCircuitBreaker circuitBreaker, boolean cacheEnabled, String value) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)));
                this.value = value;
                this.cacheEnabled = cacheEnabled;
            }

            @Override
            protected String run() {
                executed = true;
                System.out.println("successfully executed");
                return value;
            }

            public boolean isCommandRunningInThread() {
                return super.getProperties().executionIsolationStrategy().get().equals(ExecutionIsolationStrategy.THREAD);
            }

            @Override
            public String getCacheKey() {
                if (cacheEnabled)
                    return value;
                else
                    return null;
            }
        }

        /**
         * A Command implementation that supports caching and execution takes a while.
         * <p>
         * Used to test scenario where Futures are returned with a backing call still executing.
         */
        private static class SlowCacheableCommand extends TestHystrixCommand<String> {

            private final String value;
            private final int duration;
            private volatile boolean executed = false;

            public SlowCacheableCommand(TestCircuitBreaker circuitBreaker, String value, int duration) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics));
                this.value = value;
                this.duration = duration;
            }

            @Override
            protected String run() {
                executed = true;
                try {
                    Thread.sleep(duration);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println("successfully executed");
                return value;
            }

            @Override
            public String getCacheKey() {
                return value;
            }
        }

        /**
         * Successful execution - no fallback implementation, circuit-breaker disabled.
         */
        private static class TestCommandWithoutCircuitBreaker extends TestHystrixCommand<Boolean> {

            private TestCommandWithoutCircuitBreaker() {
                super(testPropsBuilder().setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withCircuitBreakerEnabled(false)));
            }

            @Override
            protected Boolean run() {
                System.out.println("successfully executed");
                return true;
            }

        }

        /**
         * This should timeout.
         */
        private static class TestCommandWithTimeout extends TestHystrixCommand<Boolean> {

            private final long timeout;

            private final static int FALLBACK_NOT_IMPLEMENTED = 1;
            private final static int FALLBACK_SUCCESS = 2;
            private final static int FALLBACK_FAILURE = 3;

            private final int fallbackBehavior;

            private TestCommandWithTimeout(long timeout, int fallbackBehavior) {
                super(testPropsBuilder().setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds((int) timeout)));
                this.timeout = timeout;
                this.fallbackBehavior = fallbackBehavior;
            }

            @Override
            protected Boolean run() {
                System.out.println("***** running");
                try {
                    Thread.sleep(timeout * 10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    // ignore and sleep some more to simulate a dependency that doesn't obey interrupts
                    try {
                        Thread.sleep(timeout * 2);
                    } catch (Exception e2) {
                        // ignore
                    }
                    System.out.println("after interruption with extra sleep");
                }
                return true;
            }

            @Override
            protected Boolean getFallback() {
                if (fallbackBehavior == FALLBACK_SUCCESS) {
                    return false;
                } else if (fallbackBehavior == FALLBACK_FAILURE) {
                    throw new RuntimeException("failed on fallback");
                } else {
                    // FALLBACK_NOT_IMPLEMENTED
                    return super.getFallback();
                }
            }
        }

        /**
         * Threadpool with 1 thread, queue of size 1
         */
        private static class SingleThreadedPool implements HystrixThreadPool {

            final LinkedBlockingQueue<Runnable> queue;
            final ThreadPoolExecutor pool;
            private final int rejectionQueueSizeThreshold;

            public SingleThreadedPool(int queueSize) {
                this(queueSize, 100);
            }

            public SingleThreadedPool(int queueSize, int rejectionQueueSizeThreshold) {
                queue = new LinkedBlockingQueue<Runnable>(queueSize);
                pool = new ThreadPoolExecutor(1, 1, 1, TimeUnit.MINUTES, queue);
                this.rejectionQueueSizeThreshold = rejectionQueueSizeThreshold;
            }

            @Override
            public ThreadPoolExecutor getExecutor() {
                return pool;
            }

            @Override
            public void markThreadExecution() {
                // not used for this test
            }

            @Override
            public void markThreadCompletion() {
                // not used for this test
            }

            @Override
            public boolean isQueueSpaceAvailable() {
                return queue.size() < rejectionQueueSizeThreshold;
            }

        }

        /**
         * This has a ThreadPool that has a single thread and queueSize of 1.
         */
        private static class TestCommandRejection extends TestHystrixCommand<Boolean> {

            private final static int FALLBACK_NOT_IMPLEMENTED = 1;
            private final static int FALLBACK_SUCCESS = 2;
            private final static int FALLBACK_FAILURE = 3;

            private final int fallbackBehavior;

            private final int sleepTime;

            private TestCommandRejection(TestCircuitBreaker circuitBreaker, HystrixThreadPool threadPool, int sleepTime, int timeout, int fallbackBehavior) {
                super(testPropsBuilder().setThreadPool(threadPool).setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(timeout)));
                this.fallbackBehavior = fallbackBehavior;
                this.sleepTime = sleepTime;
            }

            @Override
            protected Boolean run() {
                System.out.println(">>> TestCommandRejection running");
                try {
                    Thread.sleep(sleepTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return true;
            }

            @Override
            protected Boolean getFallback() {
                if (fallbackBehavior == FALLBACK_SUCCESS) {
                    return false;
                } else if (fallbackBehavior == FALLBACK_FAILURE) {
                    throw new RuntimeException("failed on fallback");
                } else {
                    // FALLBACK_NOT_IMPLEMENTED
                    return super.getFallback();
                }
            }
        }

        /**
         * Command that receives a custom thread-pool, sleepTime, timeout
         */
        private static class CommandWithCustomThreadPool extends TestHystrixCommand<Boolean> {

            public boolean didExecute = false;

            private final int sleepTime;

            private CommandWithCustomThreadPool(TestCircuitBreaker circuitBreaker, HystrixThreadPool threadPool, int sleepTime, HystrixCommandProperties.Setter properties) {
                super(testPropsBuilder().setThreadPool(threadPool).setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(properties));
                this.sleepTime = sleepTime;
            }

            @Override
            protected Boolean run() {
                System.out.println("**** Executing CommandWithCustomThreadPool. Execution => " + sleepTime);
                didExecute = true;
                try {
                    Thread.sleep(sleepTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return true;
            }
        }

        /**
         * The run() will fail and getFallback() take a long time.
         */
        private static class TestSemaphoreCommandWithSlowFallback extends TestHystrixCommand<Boolean> {

            private final long fallbackSleep;

            private TestSemaphoreCommandWithSlowFallback(TestCircuitBreaker circuitBreaker, int fallbackSemaphoreExecutionCount, long fallbackSleep) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withFallbackIsolationSemaphoreMaxConcurrentRequests(fallbackSemaphoreExecutionCount)));
                this.fallbackSleep = fallbackSleep;
            }

            @Override
            protected Boolean run() {
                throw new RuntimeException("run fails");
            }

            @Override
            protected Boolean getFallback() {
                try {
                    Thread.sleep(fallbackSleep);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return true;
            }
        }

        private static class NoRequestCacheTimeoutWithoutFallback extends TestHystrixCommand<Boolean> {
            public NoRequestCacheTimeoutWithoutFallback(TestCircuitBreaker circuitBreaker) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(200)));

                // we want it to timeout
            }

            @Override
            protected Boolean run() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    System.out.println(">>>> Sleep Interrupted: " + e.getMessage());
                    //                    e.printStackTrace();
                }
                return true;
            }

            @Override
            public String getCacheKey() {
                return null;
            }
        }

        /**
         * The run() will take time. No fallback implementation.
         */
        private static class TestSemaphoreCommand extends TestHystrixCommand<Boolean> {

            private final long executionSleep;

            private TestSemaphoreCommand(TestCircuitBreaker circuitBreaker, int executionSemaphoreCount, long executionSleep) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter()
                                .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)
                                .withExecutionIsolationSemaphoreMaxConcurrentRequests(executionSemaphoreCount)));
                this.executionSleep = executionSleep;
            }

            private TestSemaphoreCommand(TestCircuitBreaker circuitBreaker, TryableSemaphore semaphore, long executionSleep) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter()
                                .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE))
                        .setExecutionSemaphore(semaphore));
                this.executionSleep = executionSleep;
            }

            @Override
            protected Boolean run() {
                try {
                    Thread.sleep(executionSleep);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return true;
            }
        }

        /**
         * Semaphore based command that allows caller to use latches to know when it has started and signal when it
         * would like the command to finish
         */
        private static class LatchedSemaphoreCommand extends TestHystrixCommand<Boolean> {

            private final CountDownLatch startLatch, waitLatch;

            /**
             * 
             * @param circuitBreaker
             * @param semaphore
             * @param startLatch
             *            this command calls {@link java.util.concurrent.CountDownLatch#countDown()} immediately
             *            upon running
             * @param waitLatch
             *            this command calls {@link java.util.concurrent.CountDownLatch#await()} once it starts
             *            to run. The caller can use the latch to signal the command to finish
             */
            private LatchedSemaphoreCommand(TestCircuitBreaker circuitBreaker, TryableSemaphore semaphore,
                    CountDownLatch startLatch, CountDownLatch waitLatch) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE))
                        .setExecutionSemaphore(semaphore));
                this.startLatch = startLatch;
                this.waitLatch = waitLatch;
            }

            @Override
            protected Boolean run() {
                // signals caller that run has started
                this.startLatch.countDown();

                try {
                    // waits for caller to countDown latch
                    this.waitLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    return false;
                }
                return true;
            }
        }

        /**
         * The run() will take time. Contains fallback.
         */
        private static class TestSemaphoreCommandWithFallback extends TestHystrixCommand<Boolean> {

            private final long executionSleep;
            private final Boolean fallback;

            private TestSemaphoreCommandWithFallback(TestCircuitBreaker circuitBreaker, int executionSemaphoreCount, long executionSleep, Boolean fallback) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE).withExecutionIsolationSemaphoreMaxConcurrentRequests(executionSemaphoreCount)));
                this.executionSleep = executionSleep;
                this.fallback = fallback;
            }

            @Override
            protected Boolean run() {
                try {
                    Thread.sleep(executionSleep);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return true;
            }

            @Override
            protected Boolean getFallback() {
                return fallback;
            }

        }

        private static class RequestCacheNullPointerExceptionCase extends TestHystrixCommand<Boolean> {
            public RequestCacheNullPointerExceptionCase(TestCircuitBreaker circuitBreaker) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(200)));
                // we want it to timeout
            }

            @Override
            protected Boolean run() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return true;
            }

            @Override
            protected Boolean getFallback() {
                return false;
            }

            @Override
            public String getCacheKey() {
                return "A";
            }
        }

        private static class RequestCacheTimeoutWithoutFallback extends TestHystrixCommand<Boolean> {
            public RequestCacheTimeoutWithoutFallback(TestCircuitBreaker circuitBreaker) {
                super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationThreadTimeoutInMilliseconds(200)));
                // we want it to timeout
            }

            @Override
            protected Boolean run() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    System.out.println(">>>> Sleep Interrupted: " + e.getMessage());
                    //                    e.printStackTrace();
                }
                return true;
            }

            @Override
            public String getCacheKey() {
                return "A";
            }
        }

        private static class RequestCacheThreadRejectionWithoutFallback extends TestHystrixCommand<Boolean> {

            final CountDownLatch completionLatch;

            public RequestCacheThreadRejectionWithoutFallback(TestCircuitBreaker circuitBreaker, CountDownLatch completionLatch) {
                super(testPropsBuilder()
                        .setCircuitBreaker(circuitBreaker)
                        .setMetrics(circuitBreaker.metrics)
                        .setThreadPool(new HystrixThreadPool() {

                            @Override
                            public ThreadPoolExecutor getExecutor() {
                                return null;
                            }

                            @Override
                            public void markThreadExecution() {

                            }

                            @Override
                            public void markThreadCompletion() {

                            }

                            @Override
                            public boolean isQueueSpaceAvailable() {
                                // always return false so we reject everything
                                return false;
                            }

                        }));
                this.completionLatch = completionLatch;
            }

            @Override
            protected Boolean run() {
                try {
                    if (completionLatch.await(1000, TimeUnit.MILLISECONDS)) {
                        throw new RuntimeException("timed out waiting on completionLatch");
                    }
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                return true;
            }

            @Override
            public String getCacheKey() {
                return "A";
            }
        }

        private static class BadRequestCommand extends TestHystrixCommand<Boolean> {

            public BadRequestCommand(TestCircuitBreaker circuitBreaker, ExecutionIsolationStrategy isolationType) {
                super(testPropsBuilder()
                        .setCircuitBreaker(circuitBreaker)
                        .setCommandPropertiesDefaults(HystrixCommandProperties.Setter.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(isolationType)));
            }

            @Override
            protected Boolean run() {
                throw new HystrixBadRequestException("Message to developer that they passed in bad data or something like that.");
            }

            @Override
            protected Boolean getFallback() {
                return false;
            }

            @Override
            protected String getCacheKey() {
                return "one";
            }

        }

        private static class CommandWithErrorThrown extends TestHystrixCommand<Boolean> {

            public CommandWithErrorThrown(TestCircuitBreaker circuitBreaker) {
                super(testPropsBuilder()
                        .setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics));
            }

            @Override
            protected Boolean run() throws Exception {
                throw new Error("simulated java.lang.Error message");
            }

        }

        private static class CommandWithCheckedException extends TestHystrixCommand<Boolean> {

            public CommandWithCheckedException(TestCircuitBreaker circuitBreaker) {
                super(testPropsBuilder()
                        .setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics));
            }

            @Override
            protected Boolean run() throws Exception {
                throw new IOException("simulated checked exception message");
            }

        }

        enum CommandKeyForUnitTest implements HystrixCommandKey {
            KEY_ONE, KEY_TWO;
        }

        enum CommandGroupForUnitTest implements HystrixCommandGroupKey {
            OWNER_ONE, OWNER_TWO;
        }

        enum ThreadPoolKeyForUnitTest implements HystrixThreadPoolKey {
            THREAD_POOL_ONE, THREAD_POOL_TWO;
        }

        private static HystrixPropertiesStrategy TEST_PROPERTIES_FACTORY = new TestPropertiesFactory();

        private static class TestPropertiesFactory extends HystrixPropertiesStrategy {

            @Override
            public HystrixCommandProperties getCommandProperties(HystrixCommandKey commandKey, HystrixCommandProperties.Setter builder) {
                if (builder == null) {
                    builder = HystrixCommandProperties.Setter.getUnitTestPropertiesSetter();
                }
                return HystrixCommandProperties.Setter.asMock(builder);
            }

            @Override
            public HystrixThreadPoolProperties getThreadPoolProperties(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter builder) {
                if (builder == null) {
                    builder = HystrixThreadPoolProperties.Setter.getUnitTestPropertiesBuilder();
                }
                return HystrixThreadPoolProperties.Setter.asMock(builder);
            }

            @Override
            public HystrixCollapserProperties getCollapserProperties(HystrixCollapserKey collapserKey, HystrixCollapserProperties.Setter builder) {
                throw new IllegalStateException("not expecting collapser properties");
            }

            @Override
            public String getCommandPropertiesCacheKey(HystrixCommandKey commandKey, HystrixCommandProperties.Setter builder) {
                return null;
            }

            @Override
            public String getThreadPoolPropertiesCacheKey(HystrixThreadPoolKey threadPoolKey, com.netflix.hystrix.HystrixThreadPoolProperties.Setter builder) {
                return null;
            }

            @Override
            public String getCollapserPropertiesCacheKey(HystrixCollapserKey collapserKey, com.netflix.hystrix.HystrixCollapserProperties.Setter builder) {
                return null;
            }

        }

        private static class TestExecutionHook extends HystrixCommandExecutionHook {

            AtomicInteger startExecute = new AtomicInteger();

            @Override
            public <T> void onStart(HystrixCommand<T> commandInstance) {
                super.onStart(commandInstance);
                startExecute.incrementAndGet();
            }

            Object endExecuteSuccessResponse = null;

            @Override
            public <T> T onComplete(HystrixCommand<T> commandInstance, T response) {
                endExecuteSuccessResponse = response;
                return super.onComplete(commandInstance, response);
            }

            Exception endExecuteFailureException = null;
            FailureType endExecuteFailureType = null;

            @Override
            public <T> Exception onError(HystrixCommand<T> commandInstance, FailureType failureType, Exception e) {
                endExecuteFailureException = e;
                endExecuteFailureType = failureType;
                return super.onError(commandInstance, failureType, e);
            }

            AtomicInteger startRun = new AtomicInteger();

            @Override
            public <T> void onRunStart(HystrixCommand<T> commandInstance) {
                super.onRunStart(commandInstance);
                startRun.incrementAndGet();
            }

            Object runSuccessResponse = null;

            @Override
            public <T> T onRunSuccess(HystrixCommand<T> commandInstance, T response) {
                runSuccessResponse = response;
                return super.onRunSuccess(commandInstance, response);
            }

            Exception runFailureException = null;

            @Override
            public <T> Exception onRunError(HystrixCommand<T> commandInstance, Exception e) {
                runFailureException = e;
                return super.onRunError(commandInstance, e);
            }

            AtomicInteger startFallback = new AtomicInteger();

            @Override
            public <T> void onFallbackStart(HystrixCommand<T> commandInstance) {
                super.onFallbackStart(commandInstance);
                startFallback.incrementAndGet();
            }

            Object fallbackSuccessResponse = null;

            @Override
            public <T> T onFallbackSuccess(HystrixCommand<T> commandInstance, T response) {
                fallbackSuccessResponse = response;
                return super.onFallbackSuccess(commandInstance, response);
            }

            Exception fallbackFailureException = null;

            @Override
            public <T> Exception onFallbackError(HystrixCommand<T> commandInstance, Exception e) {
                fallbackFailureException = e;
                return super.onFallbackError(commandInstance, e);
            }

            AtomicInteger threadStart = new AtomicInteger();

            @Override
            public <T> void onThreadStart(HystrixCommand<T> commandInstance) {
                super.onThreadStart(commandInstance);
                threadStart.incrementAndGet();
            }

            AtomicInteger threadComplete = new AtomicInteger();

            @Override
            public <T> void onThreadComplete(HystrixCommand<T> commandInstance) {
                super.onThreadComplete(commandInstance);
                threadComplete.incrementAndGet();
            }

        }
=======
    /* package */HystrixCircuitBreaker getCircuitBreaker() {
        return observableCommand.getCircuitBreaker();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        mw.visitVarInsn(ISTORE, context.var("int"));
=======
        mw.visitVarInsn(ISTORE, context.var("size"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        mw.visitVarInsn(ILOAD, context.var("int"));
=======
        mw.visitVarInsn(ILOAD, context.var("size"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
        {
=======
        if (elementType == String.class && context.writeDirect) {
            mw.visitVarInsn(ALOAD, context.var("out"));
            mw.visitVarInsn(ALOAD, context.var("list"));
            mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "write", "(Ljava/util/List;)V");
        } else {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE

            mw.visitVarInsn(ILOAD, context.var("int"));
            mw.visitInsn(ICONST_1);
            mw.visitInsn(ISUB);

=======
            mw.visitVarInsn(ILOAD, context.var("size"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
=======
            
           
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            if (elementType == String.class) {
=======
            if (elementType == String.class && context.writeDirect) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
=======
                
                mw.visitVarInsn(ILOAD, context.var("i"));
                mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "writeStringWithDoubleQuoteDirect",
                        "(Ljava/lang/String;I)V");
            } else {
                Label _first = new Label();
                mw.visitVarInsn(ILOAD, context.var("i"));
                mw.visitJumpInsn(IFEQ, _first); // i < list.size - 1
                
                mw.visitVarInsn(ALOAD, context.var("out"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
=======
                mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "write", "(I)V");
                
                mw.visitLabel(_first);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                if (context.writeDirect) {
                    mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "writeStringWithDoubleQuoteDirect",
                            "(Ljava/lang/String;C)V");
                } else {
                    mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "writeString",
                                       "(Ljava/lang/String;C)V");
                }
            } else {
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
                mw.visitVarInsn(ALOAD, context.var("out"));
                mw.visitVarInsn(BIPUSH, ',');
                mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "write", "(I)V");
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE

            if (elementType == String.class) {
                // out.write((String)list.get(size - 1));
                mw.visitVarInsn(ALOAD, context.var("out"));
                mw.visitVarInsn(ALOAD, context.var("list"));
                mw.visitVarInsn(ILOAD, context.var("int"));
                mw.visitInsn(ICONST_1);
                mw.visitInsn(ISUB);
                mw.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "get", "(I)Ljava/lang/Object;");
                mw.visitTypeInsn(CHECKCAST, "java/lang/String"); // cast to string
                mw.visitVarInsn(BIPUSH, ']');
                if (context.writeDirect) {
                    mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "writeStringWithDoubleQuoteDirect",
                            "(Ljava/lang/String;C)V");
                } else {
                    mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "writeString",
                                       "(Ljava/lang/String;C)V");
                }
            } else {
                mw.visitVarInsn(ALOAD, Context.serializer);
                mw.visitVarInsn(ALOAD, context.var("list"));
                mw.visitVarInsn(ILOAD, context.var("i"));
                mw.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "get", "(I)Ljava/lang/Object;");
                mw.visitVarInsn(ILOAD, context.var("i"));
                mw.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;");

                if (elementClass != null && Modifier.isPublic(elementClass.getModifiers())) {
                    mw.visitLdcInsn(com.alibaba.fastjson.asm.Type.getType(desc((Class<?>) elementType)));
                    mw.visitLdcInsn(property.serialzeFeatures);
                    mw.visitMethodInsn(INVOKEVIRTUAL, JSONSerializer, "writeWithFieldName",
                                       "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V");
                } else {
                    mw.visitMethodInsn(INVOKEVIRTUAL, JSONSerializer, "writeWithFieldName",
                                       "(Ljava/lang/Object;Ljava/lang/Object;)V");
                }

                mw.visitVarInsn(ALOAD, context.var("out"));
                mw.visitVarInsn(BIPUSH, ']');
                mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "write", "(I)V");
            }
=======
            
            mw.visitVarInsn(ALOAD, context.var("out"));
            mw.visitVarInsn(BIPUSH, ']');
            mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, "write", "(I)V");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/main/java/com/alibaba/fastjson/serializer/JSONSerializer.java;<<<<<<< MINE
        return out.writeDirect // 
                && this.writeDirect
                && javaBeanDeser.writeDirect
                ;
=======
        return out.writeDirect //
               && this.writeDirect //
               && javaBeanDeser.writeDirect;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/test/java/com/alibaba/json/test/codec/FastjsonManualCodec.java;<<<<<<< MINE
            for (int i = 0, size = persons.size(); i < size; ++i) {
                out.write('[');
                if (i != 0) {
                    out.write(',');
                }
                out.writeStringWithDoubleQuoteDirect(persons.get(i), (char) 0);
                out.write(']');
            }
=======
            out.writeFieldName("persons");
            out.write(persons);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_969d52e_9f78225/rev_969d52e-9f78225/src/test/java/com/alibaba/json/bvt/serializer/ListFieldTest.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.serializer;

import java.util.ArrayList;
import java.util.List;

import org.junit.Assert;

import com.alibaba.fastjson.JSON;

import junit.framework.TestCase;

public class ListFieldTest extends TestCase {

    public void test_for_list() throws Exception {
        Model model = new Model();
        model.id = 1000;
        Assert.assertEquals("{\"id\":1000,\"values\":[]}", JSON.toJSONString(model));
        
        model.values.add("1001");
        Assert.assertEquals("{\"id\":1000,\"values\":[\"1001\"]}", JSON.toJSONString(model));
        
        model.values.add("1002");
        Assert.assertEquals("{\"id\":1000,\"values\":[\"1001\",\"1002\"]}", JSON.toJSONString(model));
        
        model.values.add("1003");
        Assert.assertEquals("{\"id\":1000,\"values\":[\"1001\",\"1002\",\"1003\"]}", JSON.toJSONString(model));
    }

    public static class Model {

        private int          id;
        private List<String> values = new ArrayList<String>();

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public List<String> getValues() {
            return values;
        }

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_e57de32_3b30e33/rev_e57de32-3b30e33/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolMetrics.java;<<<<<<< MINE
    /**
     * Clears all state from metrics. If new requests come in instances will be recreated and metrics started from scratch.
     *
     */
    /* package */ static void reset() {
        metrics.clear();
    }

=======
    public static void resetAll() {
        metrics.clear();
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c76d44b_a12ff69/rev_c76d44b-a12ff69/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                            if (deserizer == null) {
=======
                            if (deserializer == null) {
                                userType = TypeUtils.loadClass(typeName, config.getDefaultClassLoader());
                                
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_c76d44b_a12ff69/rev_c76d44b-a12ff69/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java;<<<<<<< MINE
                                userType = config.checkAutoType(typeName, expectClass);
                                deserizer = parser.getConfig().getDeserializer(userType);
=======
                                if (expectClass == null || 
                                    (userType != null && expectClass.isAssignableFrom(userType))) {
                                    deserializer = parser.getConfig().getDeserializer(userType);
                                } else {
                                    throw new JSONException("type not match");
                                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_2292e51_354d504/rev_2292e51-354d504/src/test/java/com/alibaba/json/bvt/issue_1200/Issue1254.java;<<<<<<< MINE
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.json.bvt.bug.Bug_101_for_rongganlin_case2;
import junit.framework.TestCase;
import org.apache.commons.beanutils.BeanUtils;

import java.util.Map;

/**
 * Created by kimmking on 09/06/2017.
 */
public class Issue1254 extends TestCase {
    public void test_for_issue() throws Exception {
        A a = new A();
        a._parentId = "001";
        String test = JSON.toJSONString(a);
        System.out.println(test);
        assertEquals("{\"_parentId\":\"001\"}", test);

        B b = new B();
        b.set_parentId("001");


//        Object o = BeanUtils.getProperty(b,"_parentId");
//        System.out.println(o); //test ok, println 001
//
//        //BeanUtils.getProperty(b,"parentId"); //java.lang.NoSuchMethodException: Unknown property 'parentId' on class 'class com.alibaba.json.bvt.issue_1200.Issue1254$B'

        String testB = JSON.toJSONString(b);
        System.out.println(testB);
        assertEquals("{\"_parentId\":\"001\"}", testB);

    }

    public static class A {
        public String _parentId;
    }

    public static class B {
        private String _parentId;

        public String get_parentId() {
            return _parentId;
        }

        public void set_parentId(String _parentId) {
            this._parentId = _parentId;
        }
    }
}=======
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.json.bvt.bug.Bug_101_for_rongganlin_case2;
import junit.framework.TestCase;
import org.apache.commons.beanutils.BeanUtils;

import java.util.Map;

/**
 * Created by kimmking on 09/06/2017.
 */
public class Issue1254 extends TestCase {
    public void test_for_issue() throws Exception {
        A a = new A();
        a._parentId = "001";
        String test = JSON.toJSONString(a);
        System.out.println(test);
        assertEquals("{\"_parentId\":\"001\"}", test);

        B b = new B();
        b.set_parentId("001");


        String testB = JSON.toJSONString(b);
        System.out.println(testB);
        assertEquals("{\"_parentId\":\"001\"}", testB);

    }

    public static class A {
        public String _parentId;
    }

    public static class B {
        @JSONField(name = "_parentId")
        private String _parentId;

        public String get_parentId() {
            return _parentId;
        }

        public void set_parentId(String _parentId) {
            this._parentId = _parentId;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/main/java/com/alibaba/fastjson/parser/deserializer/ThrowableDeserializer.java;<<<<<<< MINE
                // TODO
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/main/java/com/alibaba/fastjson/parser/deserializer/ThrowableDeserializer.java;<<<<<<< MINE
=======
        for (Map.Entry<String, Object> entry : otherValues.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            FieldDeserializer fieldDeserializer = this.getFieldDeserializer(key);
            if (fieldDeserializer != null) {
                fieldDeserializer.setValue(ex, value);
            }
        }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
=======
            boolean disableCircularReferenceDetect = (fieldInfo.serialzeFeatures & SerializerFeature.DisableCircularReferenceDetect.mask) != 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/main/java/com/alibaba/fastjson/serializer/ASMSerializerFactory.java;<<<<<<< MINE
            if (context.nonContext && context.writeDirect) {
=======
            if (disableCircularReferenceDetect || (context.nonContext && context.writeDirect)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/test/java/com/alibaba/json/bvt/bug/Bug_for_luogongwu.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.bug;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.fastjson.annotation.JSONType;
import com.alibaba.fastjson.parser.ParserConfig;
import com.alibaba.fastjson.serializer.SerializeConfig;
import com.alibaba.fastjson.serializer.SerializerFeature;
import junit.framework.TestCase;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by wenshao on 15/06/2017.
 */
public class Bug_for_luogongwu extends TestCase {

    public void test_for_issue() throws Exception {
        List<IflowItemImage> imageList = new ArrayList<IflowItemImage>();
        IflowItemImage image = new IflowItemImage();
        image.id = "72c7275c6b";
        imageList.add(image);

        imageList = new ArrayList();
        image = new IflowItemImage();
        image.id = "72c7275c6c";
        imageList.add(image);

        // force ASM
        boolean asm = SerializeConfig.globalInstance.isAsmEnable();
        SerializeConfig.globalInstance.setAsmEnable(true);

        // Test ASM
        Foo foo = new Foo();
        foo.thumbnails = imageList;

        String jsonString = JSON.toJSONString(foo);
        System.out.println(jsonString);

        Foo foo1 = JSON.parseObject(jsonString, Foo.class);

        assertEquals(1, foo1.thumbnails.size());
        assertNotNull(foo1.thumbnails.get(0));
        assertSame(foo1.getThumbnail(), foo1.thumbnails.get(0));


        // test Not ASM
        SerializeConfig.globalInstance.setAsmEnable(false);
        FooNotAsm fooNotAsm = new FooNotAsm();
        fooNotAsm.thumbnails = imageList;

        jsonString = JSON.toJSONString(foo);
        System.out.println(jsonString);

        FooNotAsm fooNotAsm1 = JSON.parseObject(jsonString, FooNotAsm.class);

        assertEquals(1, fooNotAsm1.thumbnails.size());
        assertNotNull(fooNotAsm1.thumbnails.get(0));
        assertSame(fooNotAsm1.getThumbnail(), fooNotAsm1.thumbnails.get(0));

        // restore
        SerializeConfig.globalInstance.setAsmEnable(asm);
    }

    @JSONType(asm=false)
    public static class FooNotAsm {
        @JSONField(serialzeFeatures = SerializerFeature.DisableCircularReferenceDetect)
        public List<IflowItemImage> thumbnails;

        public IflowItemImage getThumbnail() {
            return thumbnails != null && thumbnails.size() > 0 ? thumbnails.get(0) : null;
        }
    }

    public static class Foo {
        @JSONField(serialzeFeatures = SerializerFeature.DisableCircularReferenceDetect)
        public List<IflowItemImage> thumbnails;

        public IflowItemImage getThumbnail() {
            return thumbnails != null && thumbnails.size() > 0 ? thumbnails.get(0) : null;
        }
    }

    public static class IflowItemImage {
        public String id;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/test/java/com/alibaba/json/bvt/issue_1200/Issue1262.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by wenshao on 15/06/2017.
 */
public class Issue1262 extends TestCase {
    public void test_for_issue() throws Exception {
        Model model = JSON.parseObject("{\"chatterMap\":{}}", Model.class);
    }

    public static class Model {
        public Map<String, Chatter> chatterMap = new ConcurrentHashMap<String, Chatter>();
    }

    public static class Chatter {

    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9b6d748_e82a56a/rev_9b6d748-e82a56a/src/test/java/com/alibaba/json/bvt/issue_1200/Issue1276.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1200;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;

/**
 * Created by wenshao on 18/06/2017.
 */
public class Issue1276 extends TestCase {
    public void test_for_issue() throws Exception {
        MyException myException = new MyException(100,"error msg");
        String str = JSON.toJSONString(myException);
        System.out.println(str);

        MyException myException1 = JSON.parseObject(str, MyException.class);
        assertEquals(myException.getCode(), myException1.getCode());

        String str1 = JSON.toJSONString(myException1);
        assertEquals(str, str1);

    }

    public static class MyException extends RuntimeException{
        private static final long serialVersionUID = 7815426752583648734L;
        private long code;

        public MyException() {
            super();
        }

        public MyException(String message, Throwable cause) {
            super(message, cause);
        }

        public MyException(String message) {
            super(message);
        }

        public MyException(Throwable cause) {
            super(cause);
        }

        public MyException(long code) {
            super();
            this.code = code;
        }

        public MyException(long code, String message, Throwable cause) {
            super(message, cause);
            this.code = code;
        }

        public MyException(long code, String message) {
            super(message);
            this.code = code;
        }

        public MyException(long code, Throwable cause) {
            super(cause);
            this.code = code;
        }

        public void setCode(long code) {
            this.code = code;
        }

        public long getCode() {
            return code;
        }

        @Override
        public String toString() {
            return "MyException{" +
                    "code=" + code +
                    '}';
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_3b873c9_2f0524b/rev_3b873c9-2f0524b/hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java;<<<<<<< MINE
                    return new Thread(r, "HystrixTimer-" + counter.incrementAndGet());
=======
                    Thread thread = new Thread(r, "HystrixTimer-" + counter.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_3b873c9_2f0524b/rev_3b873c9-2f0524b/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java;<<<<<<< MINE
                return new Thread(r, "hystrix-" + threadPoolKey.name() + "-" + threadNumber.incrementAndGet());
=======
                Thread thread = new Thread(r, "hystrix-" + threadPoolKey.name() + "-" + threadNumber.incrementAndGet());
                thread.setDaemon(true);
                return thread; 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_e68ed42_ae7aedd/rev_e68ed42-ae7aedd/hystrix-core/src/jmh/java/com/netflix/hystrix/perf/RollingMaxPerfTest.java;<<<<<<< MINE
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingMaxPerfTest {
    @State(Scope.Thread)
    public static class CounterState {
        HystrixRollingNumber counter;

        @Setup(Level.Iteration)
        public void setUp() {
            counter = new HystrixRollingNumber(
                    HystrixProperty.Factory.asProperty(100),
                    HystrixProperty.Factory.asProperty(10));
        }
    }

    @State(Scope.Thread)
    public static class ValueState {
        final Random r = new Random();

        int value;

        @Setup(Level.Invocation)
        public void setUp() {
            value = r.nextInt(100);
        }
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readOnly(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeHeavyUpdateMax(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long writeHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber evenSplitUpdateMax(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long evenSplitReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber readHeavyUpdateMax(CounterState counterState, ValueState valueState) {
        counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
    }
}=======
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingMaxPerfTest {
	@State(Scope.Thread)
	public static class CounterState {
		HystrixRollingNumber counter;

		@Setup(Level.Iteration)
		public void setUp() {
			counter = new HystrixRollingNumber(
					HystrixProperty.Factory.asProperty(100),
					HystrixProperty.Factory.asProperty(10));
		}
	}

	@State(Scope.Thread)
	public static class ValueState {
		final Random r = new Random();

		int value;

		@Setup(Level.Invocation)
		public void setUp() {
			value = r.nextInt(100);
		}
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readOnly(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeHeavyUpdateMax(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long writeHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber evenSplitUpdateMax(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long evenSplitReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber readHeavyUpdateMax(CounterState counterState, ValueState valueState) {
		counterState.counter.updateRollingMax(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getRollingMaxValue(HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_e68ed42_ae7aedd/rev_e68ed42-ae7aedd/hystrix-core/src/jmh/java/com/netflix/hystrix/perf/RollingNumberPerfTest.java;<<<<<<< MINE
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingNumberPerfTest {
    @State(Scope.Thread)
    public static class CounterState {
        HystrixRollingNumber counter;

        @Setup(Level.Iteration)
        public void setUp() {
            counter = new HystrixRollingNumber(
                    HystrixProperty.Factory.asProperty(100),
                    HystrixProperty.Factory.asProperty(10));
        }
    }

    @State(Scope.Thread)
    public static class ValueState {
        final Random r = new Random();

        int value;
        HystrixRollingNumberEvent type;

        @Setup(Level.Invocation)
        public void setUp() {
            value = r.nextInt(100);
            int typeInt = r.nextInt(3);
            switch(typeInt) {
                case 0:
                    type = HystrixRollingNumberEvent.SUCCESS;
                    break;
                case 1:
                    type = HystrixRollingNumberEvent.FAILURE;
                    break;
                case 2:
                    type = HystrixRollingNumberEvent.TIMEOUT;
                    break;
                default: throw new RuntimeException("Unexpected : " + typeInt);
            }
        }
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readOnly(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber writeHeavyCounterAdd(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("writeHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long writeHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber evenSplitCounterAdd(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("evenSplit")
    @GroupThreads(4)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long evenSplitReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(1)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public HystrixRollingNumber readHeavyCounterAdd(CounterState counterState, ValueState valueState) {
        counterState.counter.add(valueState.type, valueState.value);
        return counterState.counter;
    }

    @Benchmark
    @Group("readHeavy")
    @GroupThreads(7)
    @BenchmarkMode({Mode.Throughput})
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public long readHeavyReadMetrics(CounterState counterState) {
        HystrixRollingNumber counter = counterState.counter;
        return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
                counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
                counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
                counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
    }
}=======
package com.netflix.hystrix.perf;

import com.netflix.hystrix.strategy.properties.HystrixProperty;
import com.netflix.hystrix.util.HystrixRollingNumber;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class RollingNumberPerfTest {
	@State(Scope.Thread)
	public static class CounterState {
		HystrixRollingNumber counter;

		@Setup(Level.Iteration)
		public void setUp() {
			counter = new HystrixRollingNumber(
					HystrixProperty.Factory.asProperty(100),
					HystrixProperty.Factory.asProperty(10));
		}
	}

	@State(Scope.Thread)
	public static class ValueState {
		final Random r = new Random();

		int value;
		HystrixRollingNumberEvent type;

		@Setup(Level.Invocation)
		public void setUp() {
			value = r.nextInt(100);
			int typeInt = r.nextInt(3);
			switch(typeInt) {
				case 0:
					type = HystrixRollingNumberEvent.SUCCESS;
					break;
				case 1:
					type = HystrixRollingNumberEvent.FAILURE;
					break;
				case 2:
					type = HystrixRollingNumberEvent.TIMEOUT;
					break;
				default: throw new RuntimeException("Unexpected : " + typeInt);
			}
		}
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeOnly(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readOnly(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber writeHeavyCounterAdd(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("writeHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long writeHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber evenSplitCounterAdd(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("evenSplit")
	@GroupThreads(4)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long evenSplitReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(1)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public HystrixRollingNumber readHeavyCounterAdd(CounterState counterState, ValueState valueState) {
		counterState.counter.add(valueState.type, valueState.value);
		return counterState.counter;
	}

	@Benchmark
	@Group("readHeavy")
	@GroupThreads(7)
	@BenchmarkMode({Mode.Throughput})
	@OutputTimeUnit(TimeUnit.MILLISECONDS)
	public long readHeavyReadMetrics(CounterState counterState) {
		HystrixRollingNumber counter = counterState.counter;
		return counter.getCumulativeSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getCumulativeSum(HystrixRollingNumberEvent.TIMEOUT) +
				counter.getRollingSum(HystrixRollingNumberEvent.SUCCESS) +
				counter.getRollingSum(HystrixRollingNumberEvent.FAILURE) +
				counter.getRollingSum(HystrixRollingNumberEvent.TIMEOUT);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
=======
import org.springframework.core.ResolvableType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
=======
import java.lang.reflect.ParameterizedType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
=======
import java.lang.reflect.TypeVariable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
        return readType(type, inputMessage);
=======
        return readType(getType(type, contextClass), inputMessage);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE

        return readType(clazz, inputMessage);
=======
        return readType(getType(clazz, null), inputMessage);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java;<<<<<<< MINE
=======
    protected Type getType(Type type, Class<?> contextClass) {
        if(contextClass != null) {
            ResolvableType resolvedType = ResolvableType.forType(type);
            if(type instanceof TypeVariable) {
                ResolvableType resolvedTypeVariable = this.resolveVariable((TypeVariable)type, ResolvableType.forClass(contextClass));
                if(resolvedTypeVariable != ResolvableType.NONE) {
                    return resolvedTypeVariable.resolve();
                }
            } else if(type instanceof ParameterizedType && resolvedType.hasUnresolvableGenerics()) {
                ParameterizedType parameterizedType = (ParameterizedType)type;
                Class<?>[] generics = new Class[parameterizedType.getActualTypeArguments().length];
                Type[] typeArguments = parameterizedType.getActualTypeArguments();

                for(int i = 0; i < typeArguments.length; ++i) {
                    Type typeArgument = typeArguments[i];
                    if(typeArgument instanceof TypeVariable) {
                        ResolvableType resolvedTypeArgument = this.resolveVariable((TypeVariable)typeArgument, ResolvableType.forClass(contextClass));
                        if(resolvedTypeArgument != ResolvableType.NONE) {
                            generics[i] = resolvedTypeArgument.resolve();
                        } else {
                            generics[i] = ResolvableType.forType(typeArgument).resolve();
                        }
                    } else {
                        generics[i] = ResolvableType.forType(typeArgument).resolve();
                    }
                }

                return ResolvableType.forClassWithGenerics(resolvedType.getRawClass(), generics).getType();
            }
        }

        return type;
    }

    private ResolvableType resolveVariable(TypeVariable<?> typeVariable, ResolvableType contextType) {
        ResolvableType resolvedType;
        if (contextType.hasGenerics()) {
            resolvedType = ResolvableType.forType(typeVariable, contextType);
            if (resolvedType.resolve() != null) {
                return resolvedType;
            }
        }

        ResolvableType superType = contextType.getSuperType();
        if (superType != ResolvableType.NONE) {
            resolvedType = resolveVariable(typeVariable, superType);
            if (resolvedType.resolve() != null) {
                return resolvedType;
            }
        }
        for (ResolvableType ifc : contextType.getInterfaces()) {
            resolvedType = resolveVariable(typeVariable, ifc);
            if (resolvedType.resolve() != null) {
                return resolvedType;
            }
        }
        return ResolvableType.NONE;
    }


>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/support/spring/FastJsonJsonViewTest.java;<<<<<<< MINE
import java.nio.charset.Charset;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

=======
import com.alibaba.fastjson.serializer.SerializeFilter;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.serializer.ValueFilter;
import com.alibaba.fastjson.support.config.FastJsonConfig;
import com.alibaba.fastjson.support.spring.FastJsonJsonView;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/support/spring/FastJsonJsonViewTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/support/spring/FastJsonJsonViewTest.java;<<<<<<< MINE
import com.alibaba.fastjson.serializer.SerializeFilter;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.serializer.ValueFilter;
import com.alibaba.fastjson.support.config.FastJsonConfig;
import com.alibaba.fastjson.support.spring.FastJsonJsonView;
=======
import java.nio.charset.Charset;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/support/spring/FastJsonJsonViewTest.java;<<<<<<< MINE
        Assert.assertEquals(contentLength, contentAsString.getBytes().length);
=======
        Assert.assertEquals(contentLength, contentAsString.getBytes(view.getFastJsonConfig().getCharset().name()).length);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/support/spring/FastJsonJsonViewTest.java;<<<<<<< MINE
		@Override
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1341.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1300;


import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONPObject;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.support.config.FastJsonConfig;
import com.alibaba.fastjson.support.jaxrs.FastJsonProvider;
import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.internal.InternalProperties;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.server.JSONP;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;
import org.junit.Assert;
import org.junit.Test;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Feature;
import javax.ws.rs.core.FeatureContext;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.MessageBodyWriter;
import java.util.Date;

import static org.junit.Assert.assertTrue;

public class Issue1341 extends JerseyTest {
    static class Book {

        private int bookId;
        private String bookName;
        private String publisher;
        private String isbn;
        private Date publishTime;
        private Object hello;

        public int getBookId() {
            return bookId;
        }

        public void setBookId(int bookId) {
            this.bookId = bookId;
        }

        public String getBookName() {
            return bookName;
        }

        public void setBookName(String bookName) {
            this.bookName = bookName;
        }

        public String getPublisher() {
            return publisher;
        }

        public void setPublisher(String publisher) {
            this.publisher = publisher;
        }

        public String getIsbn() {
            return isbn;
        }

        public void setIsbn(String isbn) {
            this.isbn = isbn;
        }

        public Date getPublishTime() {
            return publishTime;
        }

        public void setPublishTime(Date publishTime) {
            this.publishTime = publishTime;
        }

        public Object getHello() {
            return hello;
        }

        public void setHello(Object hello) {
            this.hello = hello;
        }
    }

    static class FastJsonFeature implements Feature {

        private final static String JSON_FEATURE = FastJsonFeature.class.getSimpleName();

        public boolean configure(final FeatureContext context) {
            final Configuration config = context.getConfiguration();
            final String jsonFeature = CommonProperties.getValue(config.getProperties(), config.getRuntimeType(), InternalProperties.JSON_FEATURE, JSON_FEATURE,
                    String.class);
            // Other JSON providers registered.
            if (!JSON_FEATURE.equalsIgnoreCase(jsonFeature)) {
                return false;
            }
            // Disable other JSON providers.
            context.property(PropertiesHelper.getPropertyNameForRuntime(InternalProperties.JSON_FEATURE, config.getRuntimeType()), JSON_FEATURE);
            // Register FastJson.
            if (!config.isRegistered(FastJsonProvider.class)) {
                //DisableCircularReferenceDetect
                FastJsonProvider fastJsonProvider = new FastJsonProvider();
                FastJsonConfig fastJsonConfig = new FastJsonConfig();
                //fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect,SerializerFeature.BrowserSecure);

                fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect);

                fastJsonProvider.setFastJsonConfig(fastJsonConfig);

                context.register(fastJsonProvider, MessageBodyReader.class, MessageBodyWriter.class);
            }
            return true;
        }
    }


    @Path("book")
    public static class BookRestFul {

        @GET
        @Path("{id}")
        @Produces({"application/javascript", "application/json"})
        @JSONP(queryParam = "callback")
        public Book getBookById(@PathParam("id") Long id) {

            Book book = new Book();
            book.setBookId(2);
            book.setBookName("Python");
            book.setPublisher("");
            book.setPublishTime(new Date());
            book.setIsbn("911122");

            return book;
        }
    }

    @Override
    protected void configureClient(ClientConfig config) {
        config.register(new FastJsonFeature()).register(FastJsonProvider.class);
    }

    @Override
    protected Application configure() {
        enable(TestProperties.LOG_TRAFFIC);
        enable(TestProperties.DUMP_ENTITY);

        ResourceConfig config = new ResourceConfig();

        config.register(new FastJsonFeature()).register(FastJsonProvider.class);
        config.packages("com.alibaba.json");
        return config;
    }

    @Test
    public void test() {

        final String reponse = target("book").path("123").request().accept("application/javascript").get(String.class);

        Assert.assertTrue(reponse.indexOf("Python") > 0);
        Assert.assertTrue(reponse.indexOf("") > 0);
        Assert.assertTrue(reponse.indexOf("\"hello\":null") > 0);
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_d93b71f_1c81635/rev_d93b71f-1c81635/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1367.java;<<<<<<< MINE
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
import com.alibaba.fastjson.support.spring.FastJsonpHttpMessageConverter4;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;

import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import java.io.Serializable;
import java.util.List;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Created by songlingdong on 8/5/17.
 */
@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration
public class Issue1367 {

    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac) //
                .addFilter(new CharacterEncodingFilter("UTF-8", true)) // UTF-8
                .build();
    }





    public static class AbstractController<ID extends Serializable, PO extends GenericEntity<ID>> {

        @PostMapping(path = "/typeVariableBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public PO save(@RequestBody PO dto) {
            //do something
            return dto;
        }

    }

    @RestController
    @RequestMapping()
    public static class BeanController extends AbstractController<Long, TypeVariableBean> {



        @PostMapping(path = "/parameterizedTypeBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public String parameterizedTypeBean(@RequestBody ParameterizedTypeBean<String> parameterizedTypeBean){
            return parameterizedTypeBean.t;
        }


    }


    @ComponentScan(basePackages = "com.alibaba.json.bvt.issue_1300")
    @Configuration
    @Order(Ordered.LOWEST_PRECEDENCE + 1)
    @EnableWebMvc
    public static class WebMvcConfig extends WebMvcConfigurerAdapter {
        @Override
        public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
            FastJsonpHttpMessageConverter4 converter = new FastJsonpHttpMessageConverter4();
            converters.add(converter);
        }


    }


    @Test
    public void testParameterizedTypeBean() throws Exception {
        mockMvc.perform(
                (post("/parameterizedTypeBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"t\": \"neil dong\"}")
                        )).andExpect(status().isOk()).andDo(print());
    }

    @Test
    public void testTypeVariableBean() throws Exception {
        mockMvc.perform(
                (post("/typeVariableBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"id\": 1}")
                        )).andExpect(status().isOk()).andDo(print());

    }





    static abstract class GenericEntity<ID extends Serializable> {
        public abstract ID getId();
    }

    static class TypeVariableBean extends GenericEntity<Long> {
        private Long id;

        @Override
        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }
    }

    static class ParameterizedTypeBean<T> {
        private T t;

        public T getT() {
            return t;
        }

        public void setT(T t) {
            this.t = t;
        }



    }
}=======
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
import com.alibaba.fastjson.support.spring.FastJsonpHttpMessageConverter4;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import java.io.Serializable;
import java.util.List;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Created by songlingdong on 8/5/17.
 */
@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration
public class Issue1367 {

    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac) //
                .addFilter(new CharacterEncodingFilter("UTF-8", true)) // UTF-8
                .build();
    }





    public static class AbstractController<ID extends Serializable, PO extends GenericEntity<ID>> {

        @PostMapping(path = "/typeVariableBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public PO save(@RequestBody PO dto) {
            //do something
            return dto;
        }

    }

    @RestController
    @RequestMapping()
    public static class BeanController extends AbstractController<Long, TypeVariableBean> {



        @PostMapping(path = "/parameterizedTypeBean",consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public String parameterizedTypeBean(@RequestBody ParameterizedTypeBean<String> parameterizedTypeBean){
            return parameterizedTypeBean.t;
        }


    }


    @ComponentScan(basePackages = "com.alibaba.json.bvt.issue_1300")
    @Configuration
    @Order(Ordered.LOWEST_PRECEDENCE + 1)
    @EnableWebMvc
    public static class WebMvcConfig extends WebMvcConfigurerAdapter {
        @Override
        public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
            FastJsonpHttpMessageConverter4 converter = new FastJsonpHttpMessageConverter4();
            converters.add(converter);
        }


    }


    @Test
    public void testParameterizedTypeBean() throws Exception {
        mockMvc.perform(
                (post("/parameterizedTypeBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"t\": \"neil dong\"}")
                        )).andExpect(status().isOk()).andDo(print());
    }

    @Test
    public void testTypeVariableBean() throws Exception {
        mockMvc.perform(
                (post("/typeVariableBean").characterEncoding("UTF-8")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content("{\"id\": 1}")
                        )).andExpect(status().isOk()).andDo(print());

    }





    static abstract class GenericEntity<ID extends Serializable> {
        public abstract ID getId();
    }

    static class TypeVariableBean extends GenericEntity<Long> {
        private Long id;

        @Override
        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }
    }

    static class ParameterizedTypeBean<T> {
        private T t;

        public T getT() {
            return t;
        }

        public void setT(T t) {
            this.t = t;
        }



    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_75cc1dc_f28a067/rev_75cc1dc-f28a067/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1369.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;
import org.junit.Assert;

/**
 * Created by kimmking on 03/08/2017.
 */
public class Issue1369 extends TestCase {
    public void test_for_issue() throws Exception {
        Foo foo = new Foo();
        foo.a = 1;
        foo.b = "b";
        foo.bars = new Bar();
        foo.bars.c = 3;
        String json = JSON.toJSONString(foo);
        System.out.println(json);
        Assert.assertTrue(json.indexOf("\\")<0);
    }

    public static class Foo {
        public int a;
        public String b;
        public Bar bars;
    }
    public static class Bar {
        public int c;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_75cc1dc_f28a067/rev_75cc1dc-f28a067/src/test/java/com/alibaba/json/bvt/issue_1300/Issue1368.java;<<<<<<< MINE
=======
package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSON;
import junit.framework.TestCase;
import org.junit.Assert;
import org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder;

/**
 * Created by kimmking on 03/08/2017.
 */
public class Issue1368 extends TestCase {
    public void test_for_issue() throws Exception {
        ExtendedServletRequestDataBinder binder = new ExtendedServletRequestDataBinder(new Object());
        String json = JSON.toJSONString(binder);
        System.out.println(json);
        Assert.assertTrue(json.indexOf("$ref")>=0);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Fastjson/revisions/rev_9d0290a_29ed34b/rev_9d0290a-29ed34b/src/main/java/com/alibaba/fastjson/util/TypeUtils.java;<<<<<<< MINE
    public static Type checkPrimitiveArray(GenericArrayType genericArrayType) {
        Type clz = genericArrayType;
        Type genericComponentType  = genericArrayType.getGenericComponentType();

        String prefix = "[";
        while (genericComponentType instanceof GenericArrayType) {
            genericComponentType = ((GenericArrayType) genericComponentType)
                    .getGenericComponentType();
            prefix += prefix;
        }

        if (genericComponentType instanceof Class<?>) {
            Class<?> ck = (Class<?>) genericComponentType;
            if (ck.isPrimitive()) {
                try {
                    if (ck == boolean.class) {
                        clz = Class.forName(prefix + "Z");
                    } else if (ck == char.class) {
                        clz = Class.forName(prefix + "C");
                    } else if (ck == byte.class) {
                        clz = Class.forName(prefix + "B");
                    } else if (ck == short.class) {
                        clz = Class.forName(prefix + "S");
                    } else if (ck == int.class) {
                        clz = Class.forName(prefix + "I");
                    } else if (ck == long.class) {
                        clz = Class.forName(prefix + "J");
                    } else if (ck == float.class) {
                        clz = Class.forName(prefix + "F");
                    } else if (ck == double.class) {
                        clz = Class.forName(prefix + "D");
                    }
                } catch (ClassNotFoundException e) {
                }
            }
        }

        return clz;
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    public static Collection createCollection(Type type) {
=======
    @SuppressWarnings({"rawtypes", "unchecked"})
    public static Collection createCollection(Type type){
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_0d899c0_35798bf/rev_0d899c0-35798bf/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java;<<<<<<< MINE
import java.lang.reflect.Method;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_61ddeae_18fab29/rev_61ddeae-18fab29/hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java;<<<<<<< MINE
                // success    
=======
                // success
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_61ddeae_18fab29/rev_61ddeae-18fab29/hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java;<<<<<<< MINE
                // success    
=======
                // success
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_61ddeae_18fab29/rev_61ddeae-18fab29/hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java;<<<<<<< MINE
     * 
=======
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_61ddeae_18fab29/rev_61ddeae-18fab29/hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java;<<<<<<< MINE
         * 
=======
         *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_da1198c_5b9bdae/rev_da1198c-5b9bdae/hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java;<<<<<<< MINE
        final AtomicBoolean hystrixThreadStartedExecuting = new AtomicBoolean(false);

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_da1198c_5b9bdae/rev_da1198c-5b9bdae/hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java;<<<<<<< MINE
                hystrixThreadStartedExecuting.set(true);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Hystrix/revisions/rev_da1198c_5b9bdae/rev_da1198c-5b9bdae/hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java;<<<<<<< MINE
            assertEquals(hystrixThreadStartedExecuting.get(), cmd.isExecutedInThread());
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_8a64e43_d4e3d3d/rev_8a64e43-d4e3d3d/src/jvm/backtype/storm/tuple/Tuple.java;<<<<<<< MINE
    private IPersistentMap _meta;

=======
    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_f597bb1_c1b8943/rev_f597bb1-c1b8943/src/jvm/backtype/storm/tuple/Tuple.java;<<<<<<< MINE
        // should change this to get by field name, and push metadata stuff like this
        // into metadata
        if(o.equals(STREAM_KEYWORD)) {
            return getSourceStreamId();
        } else if(o.equals(COMPONENT_KEYWORD)) {
            return getSourceComponent();
        } else if(o.equals(TASK_KEYWORD)) {
            return getSourceTask();
=======
        try {
            if(o instanceof Keyword) {
                return getValueByField(((Keyword) o).getName());
            } else if(o instanceof String) {
                return getValueByField((String) o);
            }
        } catch(IllegalArgumentException e) {
        }
        return null;
    }

    /* Seqable */
    public ISeq seq() {
        if(values.size() > 0) {
            return new Seq(getFields().toList(), values, 0);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_d84ac47_436ae85/rev_d84ac47-436ae85/src/jvm/backtype/storm/scheduler/SchedulerAssignment.java;<<<<<<< MINE
    public boolean isSlotOccupied(WorkerSlot slot);

    /**
     * is the executor assigned?
     * 
     * @param executor
     * @return
     */
    public boolean isExecutorAssigned(ExecutorDetails executor);
=======
    public void assign(WorkerSlot slot, Collection<ExecutorDetails> executors) {
        for (ExecutorDetails executor : executors) {
            this.executorToSlot.put(executor, slot);
        }
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_2d7affe_692b573/rev_2d7affe-692b573/src/jvm/storm/trident/topology/MasterBatchCoordinator.java;<<<<<<< MINE
import java.util.Random;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
=======
import org.apache.log4j.Logger;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_4026463_f2b212e/rev_4026463-f2b212e/src/jvm/backtype/storm/metric/api/IMetricsConsumer.java;<<<<<<< MINE
=======
        public TaskInfo() {}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_4026463_f2b212e/rev_4026463-f2b212e/src/jvm/backtype/storm/metric/api/IMetricsConsumer.java;<<<<<<< MINE
=======
        public DataPoint() {}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_4026463_f2b212e/rev_4026463-f2b212e/src/jvm/backtype/storm/serialization/SerializationFactory.java;<<<<<<< MINE
=======
        k.register(backtype.storm.metric.api.IMetricsConsumer.DataPoint.class);
        k.register(backtype.storm.metric.api.IMetricsConsumer.TaskInfo.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_e64ac0c_1f6237b/rev_e64ac0c-1f6237b/src/jvm/storm/trident/operation/TridentOperationContext.java;<<<<<<< MINE
import backtype.storm.metric.api.*;
=======
import backtype.storm.task.IMetricsContext;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_446037a_3e29f13/rev_446037a-3e29f13/src/jvm/backtype/storm/spout/SchemeAsMultiScheme.java;<<<<<<< MINE
    return Arrays.asList(scheme.deserialize(ser));
=======
    List<Object> o = scheme.deserialize(ser);
    if(o == null) return null;
    else return Arrays.asList(o);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/testing/MemoryBackingMap.java;<<<<<<< MINE
=======
package storm.trident.testing;

import storm.trident.state.map.IBackingMap;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MemoryBackingMap implements IBackingMap<Object> {
    Map _vals = new HashMap();

    @Override
    public List<Object> multiGet(List<List<Object>> keys) {
        List ret = new ArrayList();
        for(List key: keys) {
            ret.add(_vals.get(key));
        }
        return ret;
    }

    @Override
    public void multiPut(List<List<Object>> keys, List<Object> vals) {
        for(int i=0; i<keys.size(); i++) {
            List key = keys.get(i);
            Object val = vals.get(i);
            _vals.put(key, val);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
        return new CachedBatchReadsMap<T>(new TransactionalMap<T>(backing));
=======
        return new TransactionalMap<T>(backing);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
    
    IBackingMap<TransactionalValue> _backing;
=======

    CachedBatchReadsMap<TransactionalValue> _backing;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
        _backing = backing;
=======
        _backing = new CachedBatchReadsMap(backing);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
        List<TransactionalValue> vals = _backing.multiGet(keys);
=======
        List<CachedBatchReadsMap.RetVal<TransactionalValue>> vals = _backing.multiGet(keys);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
        for(TransactionalValue v: vals) {
=======
        for(CachedBatchReadsMap.RetVal<TransactionalValue> retval: vals) {
            TransactionalValue v = retval.val;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
        List<TransactionalValue> curr = _backing.multiGet(keys);
=======
        List<CachedBatchReadsMap.RetVal<TransactionalValue>> curr = _backing.multiGet(keys);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
=======
        List<List<Object>> newKeys = new ArrayList();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
            TransactionalValue<T> val = curr.get(i);
=======
            CachedBatchReadsMap.RetVal<TransactionalValue> retval = curr.get(i);
            TransactionalValue<T> val = retval.val;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
=======
            boolean changed = false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
=======
                changed = true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
                if(_currTx!=null && _currTx.equals(val.getTxid())) {
=======
                if(_currTx!=null && _currTx.equals(val.getTxid()) && !retval.cached) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
                }    
=======
                    changed = true;
                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
            newVals.add(newVal);
=======
            if(changed) {
                newVals.add(newVal);
                newKeys.add(keys.get(i));
            }
        }
        if(!newKeys.isEmpty()) {
            _backing.multiPut(newKeys, newVals);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
        _backing.multiPut(keys, newVals);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
=======
        _backing.reset();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/TransactionalMap.java;<<<<<<< MINE
    }  
=======
        _backing.reset();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
public class CachedBatchReadsMap<T> implements MapState<T> {
=======

public class CachedBatchReadsMap<T> {
    public static class RetVal<T> {
        public boolean cached;
        public T val;

        public RetVal(T v, boolean c) {
            val = v;
            cached = c;
        }
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
    public MapState<T> _delegate;
=======
    public IBackingMap<T> _delegate;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
    public CachedBatchReadsMap(MapState<T> delegate) {
=======
    public CachedBatchReadsMap(IBackingMap<T> delegate) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
=======

    public void reset() {
        _cached.clear();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
    @Override
    public List<T> multiGet(List<List<Object>> keys) {
        List<T> ret = _delegate.multiGet(keys);
        if(!_cached.isEmpty()) {
            ret = new ArrayList<T>(ret);
            for(int i=0; i<keys.size(); i++) {
                List<Object> key = keys.get(i);
                if(_cached.containsKey(key)) {
                    ret.set(i, _cached.get(key));
                }
=======
    public List<RetVal<T>> multiGet(List<List<Object>> keys) {
        // TODO: can optimize further by only querying backing map for keys not in the cache
        List<T> vals = _delegate.multiGet(keys);
        List<RetVal<T>> ret = new ArrayList(vals.size());
        for(int i=0; i<keys.size(); i++) {
            List<Object> key = keys.get(i);
            if(_cached.containsKey(key)) {
                ret.add(new RetVal(_cached.get(key), true));
            } else {
                ret.add(new RetVal(vals.get(i), false));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
    @Override
    public List<T> multiUpdate(List<List<Object>> keys, List<ValueUpdater> updaters) {
        List<T> vals = _delegate.multiUpdate(keys, updaters);
        cache(keys, vals);
        return vals;
    }

    @Override
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
    @Override
    public void beginCommit(Long txid) {
        _cached.clear(); //if a commit was pending and failed, we need to make sure to clear the cache
        _delegate.beginCommit(txid);
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/CachedBatchReadsMap.java;<<<<<<< MINE
    @Override
    public void commit(Long txid) {
        _cached.clear();
        _delegate.commit(txid);
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
        return new CachedBatchReadsMap<T>(new OpaqueMap<T>(backing));
=======
        return new OpaqueMap<T>(backing);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
    IBackingMap<OpaqueValue> _backing;
=======
    CachedBatchReadsMap<OpaqueValue> _backing;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
        _backing = backing;
=======
        _backing = new CachedBatchReadsMap(backing);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
        List<OpaqueValue> curr = _backing.multiGet(keys);
=======
        List<CachedBatchReadsMap.RetVal<OpaqueValue>> curr = _backing.multiGet(keys);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
        for(OpaqueValue val: curr) {
=======
        for(CachedBatchReadsMap.RetVal<OpaqueValue> retval: curr) {
            OpaqueValue val = retval.val;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
        List<OpaqueValue> curr = _backing.multiGet(keys);
=======
        List<CachedBatchReadsMap.RetVal<OpaqueValue>> curr = _backing.multiGet(keys);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
            OpaqueValue<T> val = curr.get(i);
=======
            CachedBatchReadsMap.RetVal<OpaqueValue> retval = curr.get(i);
            OpaqueValue<T> val = retval.val;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
                prev = val.get(_currTx);
=======
                if(retval.cached) {
                    prev = val.getCurr();
                } else {
                    prev = val.get(_currTx);
                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
=======
        _backing.reset();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/storm/trident/state/map/OpaqueMap.java;<<<<<<< MINE
=======
        _backing.reset();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/backtype/storm/utils/Utils.java;<<<<<<< MINE
                throw new RuntimeException("Found multiple " + name + " resources. You're probably bundling the Storm jars with your topology jar.");
=======
                throw new RuntimeException("Found multiple " + name + " resources. You're probably bundling the Storm jars with your topology jar. "
                  + resources);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_6398179_7970fee/rev_6398179-7970fee/src/jvm/backtype/storm/security/serialization/BlowfishTupleSerializer.java;<<<<<<< MINE
	try{
	    KeyGenerator kgen = KeyGenerator.getInstance("Blowfish");
	    SecretKey skey = kgen.generateKey();
	    byte[] raw = skey.getEncoded();
	    String keyString = new String(Hex.encodeHex(raw));
	    System.out.println("storm -c "+SECRET_KEY+"="+keyString+" -c "+Config.TOPOLOGY_TUPLE_SERIALIZER+"="+BlowfishTupleSerializer.class.getName() + " ..." );
	} catch (Exception ex) {
	    LOG.error(ex.getMessage());
	    ex.printStackTrace();
	}
=======
        try{
            KeyGenerator kgen = KeyGenerator.getInstance("Blowfish");
            SecretKey skey = kgen.generateKey();
            byte[] raw = skey.getEncoded();
            String keyString = new String(Hex.encodeHex(raw));
            System.out.println("storm -c "+SECRET_KEY+"="+keyString+" -c "+Config.TOPOLOGY_TUPLE_SERIALIZER+"="+BlowfishTupleSerializer.class.getName() + " ..." );
        } catch (Exception ex) {
            LOG.error(ex.getMessage());
            ex.printStackTrace();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_8e69347_af2c793/rev_8e69347-af2c793/src/jvm/backtype/storm/utils/NimbusClient.java;<<<<<<< MINE
public class NimbusClient extends ThriftClient {	
=======
public class NimbusClient extends ThriftClient {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_8e69347_af2c793/rev_8e69347-af2c793/src/jvm/backtype/storm/utils/NimbusClient.java;<<<<<<< MINE
            Integer timeout = new Integer(Utils.getInt(conf.get(Config.NIMBUS_TASK_TIMEOUT_SECS)));
=======
            Integer timeout = Utils.getInt(conf.get(Config.NIMBUS_TASK_TIMEOUT_SECS));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_dea4c8b_d12c335/rev_dea4c8b-d12c335/src/jvm/storm/trident/topology/state/RotatingTransactionalState.java;<<<<<<< MINE
=======
package storm.trident.topology.state;

import backtype.storm.utils.Utils;
import org.apache.zookeeper.KeeperException;

import java.util.HashSet;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;

public class RotatingTransactionalState {
    public static interface StateInitializer {
        Object init(long txid, Object lastState);
    }    

    private TransactionalState _state;
    private String _subdir;
    
    private TreeMap<Long, Object> _curr = new TreeMap<Long, Object>();
    
    public RotatingTransactionalState(TransactionalState state, String subdir) {
        _state = state;
        _subdir = subdir;
        state.mkdir(subdir);
        sync();
    }


    public Object getLastState() {
        if(_curr.isEmpty()) return null;
        else return _curr.lastEntry().getValue();
    }
    
    public void overrideState(long txid, Object state) {
        _state.setData(txPath(txid), state);
        _curr.put(txid, state);
    }

    public void removeState(long txid) {
        if(_curr.containsKey(txid)) {
            _curr.remove(txid);
            _state.delete(txPath(txid));
        }
    }
    
    public Object getState(long txid) {
        return _curr.get(txid);
    }
    
    public Object getState(long txid, StateInitializer init) {
        if(!_curr.containsKey(txid)) {
            SortedMap<Long, Object> prevMap = _curr.headMap(txid);
            SortedMap<Long, Object> afterMap = _curr.tailMap(txid);            
            
            Long prev = null;
            if(!prevMap.isEmpty()) prev = prevMap.lastKey();            
            
            Object data;
            if(afterMap.isEmpty()) {
                Object prevData;
                if(prev!=null) {
                    prevData = _curr.get(prev);
                } else {
                    prevData = null;
                }
                data = init.init(txid, prevData);
            } else {
                data = null;
            }
            _curr.put(txid, data);
            _state.setData(txPath(txid), data);
        }
        return _curr.get(txid);
    }
    
    public Object getPreviousState(long txid) {
        SortedMap<Long, Object> prevMap = _curr.headMap(txid);
        if(prevMap.isEmpty()) return null;
        else return prevMap.get(prevMap.lastKey());
    }
    
    public boolean hasCache(long txid) {
        return _curr.containsKey(txid);
    }
       
    /**
     * Returns null if it was created, the value otherwise.
     */
    public Object getStateOrCreate(long txid, StateInitializer init) {
        if(_curr.containsKey(txid)) {
            return _curr.get(txid);
        } else {
            getState(txid, init);
            return null;
        }
    }
    
    public void cleanupBefore(long txid) {
        SortedMap<Long, Object> toDelete = _curr.headMap(txid);
        for(long tx: new HashSet<Long>(toDelete.keySet())) {
            _curr.remove(tx);
            try {
                _state.delete(txPath(tx));
            } catch(RuntimeException e) {
                // Ignore NoNodeExists exceptions because when sync() it may populate _curr with stale data since
                // zookeeper reads are eventually consistent.
                if(!Utils.exceptionCauseIsInstanceOf(KeeperException.NoNodeException.class, e)) {
                    throw e;
                }
            }
        }
    }
    
    private void sync() {
        List<String> txids = _state.list(_subdir);
        for(String txid_s: txids) {
            Object data = _state.getData(txPath(txid_s));
            _curr.put(Long.parseLong(txid_s), data);
        }
    }
    
    private String txPath(long tx) {
        return txPath("" + tx);
    }

    private String txPath(String tx) {
        return _subdir + "/" + tx;
    }    
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_dea4c8b_d12c335/rev_dea4c8b-d12c335/src/jvm/backtype/storm/utils/Utils.java;<<<<<<< MINE
=======
package backtype.storm.utils;

import backtype.storm.Config;
import backtype.storm.generated.ComponentCommon;
import backtype.storm.generated.ComponentObject;
import backtype.storm.generated.StormTopology;
import clojure.lang.IFn;
import clojure.lang.RT;
import com.netflix.curator.framework.CuratorFramework;
import com.netflix.curator.framework.CuratorFrameworkFactory;
import com.netflix.curator.retry.RetryNTimes;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.WritableByteChannel;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;
import org.apache.commons.lang.StringUtils;
import org.apache.thrift7.TException;
import org.json.simple.JSONValue;
import org.yaml.snakeyaml.Yaml;

public class Utils {
    public static final String DEFAULT_STREAM_ID = "default";

    public static Object newInstance(String klass) {
        try {
            Class c = Class.forName(klass);
            return c.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    public static byte[] serialize(Object obj) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(obj);
            oos.close();
            return bos.toByteArray();
        } catch(IOException ioe) {
            throw new RuntimeException(ioe);
        }
    }

    public static Object deserialize(byte[] serialized) {
        try {
            ByteArrayInputStream bis = new ByteArrayInputStream(serialized);
            ObjectInputStream ois = new ObjectInputStream(bis);
            Object ret = ois.readObject();
            ois.close();
            return ret;
        } catch(IOException ioe) {
            throw new RuntimeException(ioe);
        } catch(ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    public static <T> String join(Iterable<T> coll, String sep) {
        Iterator<T> it = coll.iterator();
        String ret = "";
        while(it.hasNext()) {
            ret = ret + it.next();
            if(it.hasNext()) {
                ret = ret + sep;
            }
        }
        return ret;
    }

    public static void sleep(long millis) {
        try {
            Time.sleep(millis);
        } catch(InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    
    public static List<URL> findResources(String name) {
        try {
            Enumeration<URL> resources = Thread.currentThread().getContextClassLoader().getResources(name);
            List<URL> ret = new ArrayList<URL>();
            while(resources.hasMoreElements()) {
                ret.add(resources.nextElement());
            }
            return ret;
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map findAndReadConfigFile(String name, boolean mustExist) {
        try {
            List<URL> resources = findResources(name);
            if(resources.isEmpty()) {
                if(mustExist) throw new RuntimeException("Could not find config file on classpath " + name);
                else return new HashMap();
            }
            if(resources.size() > 1) {
                throw new RuntimeException("Found multiple " + name + " resources. You're probably bundling the Storm jars with your topology jar.");
            }
            URL resource = resources.get(0);
            Yaml yaml = new Yaml();
            Map ret = (Map) yaml.load(new InputStreamReader(resource.openStream()));
            if(ret==null) ret = new HashMap();
            

            return new HashMap(ret);
            
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map findAndReadConfigFile(String name) {
       return findAndReadConfigFile(name, true);
    }

    public static Map readDefaultConfig() {
        return findAndReadConfigFile("defaults.yaml", true);
    }
    
    public static Map readCommandLineOpts() {
        Map ret = new HashMap();
        String commandOptions = System.getProperty("storm.options");
        if(commandOptions != null) {
            commandOptions = commandOptions.replaceAll("%%%%", " ");
            String[] configs = commandOptions.split(",");
            for (String config : configs) {
                String[] options = config.split("=");
                if (options.length == 2) {
                    ret.put(options[0], options[1]);
                }
            }
        }
        return ret;
    }

    public static Map readStormConfig() {
        Map ret = readDefaultConfig();
        String confFile = System.getProperty("storm.conf.file");
        Map storm;
        if (confFile==null || confFile.equals("")) {
            storm = findAndReadConfigFile("storm.yaml", false);
        } else {
            storm = findAndReadConfigFile(confFile, true);
        }
        ret.putAll(storm);
        ret.putAll(readCommandLineOpts());
        return ret;
    }
    
    private static Object normalizeConf(Object conf) {
        if(conf==null) return new HashMap();
        if(conf instanceof Map) {
            Map confMap = new HashMap((Map) conf);
            for(Object key: confMap.keySet()) {
                Object val = confMap.get(key);
                confMap.put(key, normalizeConf(val));
            }
            return confMap;
        } else if(conf instanceof List) {
            List confList =  new ArrayList((List) conf);
            for(int i=0; i<confList.size(); i++) {
                Object val = confList.get(i);
                confList.set(i, normalizeConf(val));
            }
            return confList;
        } else if (conf instanceof Integer) {
            return ((Integer) conf).longValue();
        } else if(conf instanceof Float) {
            return ((Float) conf).doubleValue();
        } else {
            return conf;
        }
    }
    
    public static boolean isValidConf(Map<String, Object> stormConf) {
        return normalizeConf(stormConf).equals(normalizeConf((Map) JSONValue.parse(JSONValue.toJSONString(stormConf))));
    }

    public static Object getSetComponentObject(ComponentObject obj) {
        if(obj.getSetField()==ComponentObject._Fields.SERIALIZED_JAVA) {
            return Utils.deserialize(obj.get_serialized_java());
        } else if(obj.getSetField()==ComponentObject._Fields.JAVA_OBJECT) {
            return obj.get_java_object();
        } else {
            return obj.get_shell();
        }
    }

    public static <S, T> T get(Map<S, T> m, S key, T def) {
        T ret = m.get(key);
        if(ret==null) {
            ret = def;
        }
        return ret;
    }
    
    public static List<Object> tuple(Object... values) {
        List<Object> ret = new ArrayList<Object>();
        for(Object v: values) {
            ret.add(v);
        }
        return ret;
    }

    public static void downloadFromMaster(Map conf, String file, String localFile) throws IOException, TException {
        NimbusClient client = NimbusClient.getConfiguredClient(conf);
        String id = client.getClient().beginFileDownload(file);
        WritableByteChannel out = Channels.newChannel(new FileOutputStream(localFile));
        while(true) {
            ByteBuffer chunk = client.getClient().downloadChunk(id);
            int written = out.write(chunk);
            if(written==0) break;
        }
        out.close();
    }
    
    public static IFn loadClojureFn(String namespace, String name) {
        try {
          clojure.lang.Compiler.eval(RT.readString("(require '" + namespace + ")"));
        } catch (Exception e) {
          //if playing from the repl and defining functions, file won't exist
        }
        return (IFn) RT.var(namespace, name).deref();        
    }
    
    public static boolean isSystemId(String id) {
        return id.startsWith("__");
    }
        
    public static <K, V> Map<V, K> reverseMap(Map<K, V> map) {
        Map<V, K> ret = new HashMap<V, K>();
        for(K key: map.keySet()) {
            ret.put(map.get(key), key);
        }
        return ret;
    }
    
    public static ComponentCommon getComponentCommon(StormTopology topology, String id) {
        if(topology.get_spouts().containsKey(id)) {
            return topology.get_spouts().get(id).get_common();
        }
        if(topology.get_bolts().containsKey(id)) {
            return topology.get_bolts().get(id).get_common();
        }
        if(topology.get_state_spouts().containsKey(id)) {
            return topology.get_state_spouts().get(id).get_common();
        }
        throw new IllegalArgumentException("Could not find component with id " + id);
    }
    
    public static Integer getInt(Object o) {
        if(o instanceof Long) {
            return ((Long) o ).intValue();
        } else if (o instanceof Integer) {
            return (Integer) o;
        } else if (o instanceof Short) {
            return ((Short) o).intValue();
        } else {
            throw new IllegalArgumentException("Don't know how to convert " + o + " + to int");
        }
    }
    
    public static long secureRandomLong() {
        return UUID.randomUUID().getLeastSignificantBits();
    }
    
    
    public static CuratorFramework newCurator(Map conf, List<String> servers, Object port, String root) {
        return newCurator(conf, servers, port, root, null);
    }
    
    public static CuratorFramework newCurator(Map conf, List<String> servers, Object port, String root, ZookeeperAuthInfo auth) {
        List<String> serverPorts = new ArrayList<String>();
        for(String zkServer: (List<String>) servers) {
            serverPorts.add(zkServer + ":" + Utils.getInt(port));
        }
        String zkStr = StringUtils.join(serverPorts, ",") + root; 
        try {
            
            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()
                    .connectString(zkStr)
                    .connectionTimeoutMs(Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_CONNECTION_TIMEOUT)))
                    .sessionTimeoutMs(Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_SESSION_TIMEOUT)))
                    .retryPolicy(new RetryNTimes(Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_RETRY_TIMES)), Utils.getInt(conf.get(Config.STORM_ZOOKEEPER_RETRY_INTERVAL))));
            if(auth!=null && auth.scheme!=null) {
                builder = builder.authorization(auth.scheme, auth.payload);
            }            
            return builder.build();
        } catch (IOException e) {
           throw new RuntimeException(e);
        }
    }

    public static CuratorFramework newCurator(Map conf, List<String> servers, Object port) {
        return newCurator(conf, servers, port, "");
    }

    public static CuratorFramework newCuratorStarted(Map conf, List<String> servers, Object port, String root) {
        CuratorFramework ret = newCurator(conf, servers, port, root);
        ret.start();
        return ret;
    }

    public static CuratorFramework newCuratorStarted(Map conf, List<String> servers, Object port) {
        CuratorFramework ret = newCurator(conf, servers, port);
        ret.start();
        return ret;
    }    
    
    /**
     *
(defn integer-divided [sum num-pieces]
  (let [base (int (/ sum num-pieces))
        num-inc (mod sum num-pieces)
        num-bases (- num-pieces num-inc)]
    (if (= num-inc 0)
      {base num-bases}
      {base num-bases (inc base) num-inc}
      )))
     * @param sum
     * @param numPieces
     * @return 
     */
    
    public static TreeMap<Integer, Integer> integerDivided(int sum, int numPieces) {
        int base = sum / numPieces;
        int numInc = sum % numPieces;
        int numBases = numPieces - numInc;
        TreeMap<Integer, Integer> ret = new TreeMap<Integer, Integer>();
        ret.put(base, numBases);
        if(numInc!=0) {
            ret.put(base+1, numInc);
        }
        return ret;
    }

    public static byte[] toByteArray(ByteBuffer buffer) {
        byte[] ret = new byte[buffer.remaining()];
        buffer.get(ret, 0, ret.length);
        return ret;
    }

    public static boolean exceptionCauseIsInstanceOf(Class klass, Throwable throwable) {
        Throwable t = throwable;
        while(t != null) {
            if(klass.isInstance(t)) {
                return true;
            }
            t = t.getCause();
        }
        return false;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_dea4c8b_d12c335/rev_dea4c8b-d12c335/src/jvm/backtype/storm/metric/SystemBolt.java;<<<<<<< MINE
=======
package backtype.storm.metric;

import backtype.storm.Config;
import backtype.storm.metric.api.AssignableMetric;
import backtype.storm.metric.api.IMetric;
import backtype.storm.task.IBolt;
import backtype.storm.task.OutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.tuple.Tuple;
import clojure.lang.AFn;
import clojure.lang.IFn;
import clojure.lang.RT;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.management.*;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


// There is one task inside one executor for each worker of the topology.
// TaskID is always -1, therefore you can only send-unanchored tuples to co-located SystemBolt.
// This bolt was conceived to export worker stats via metrics api.
public class SystemBolt implements IBolt {
    private static Logger LOG = LoggerFactory.getLogger(SystemBolt.class);
    private static boolean _prepareWasCalled = false;

    private static class MemoryUsageMetric implements IMetric {
        IFn _getUsage;
        public MemoryUsageMetric(IFn getUsage) {
            _getUsage = getUsage;
        }
        @Override
        public Object getValueAndReset() {
            MemoryUsage memUsage = (MemoryUsage)_getUsage.invoke();
            HashMap m = new HashMap();
            m.put("maxBytes", memUsage.getMax());
            m.put("committedBytes", memUsage.getCommitted());
            m.put("initBytes", memUsage.getInit());
            m.put("usedBytes", memUsage.getUsed());
            m.put("virtualFreeBytes", memUsage.getMax() - memUsage.getUsed());
            m.put("unusedBytes", memUsage.getCommitted() - memUsage.getUsed());
            return m;
        }
    }

    // canonically the metrics data exported is time bucketed when doing counts.
    // convert the absolute values here into time buckets.
    private static class GarbageCollectorMetric implements IMetric {
        GarbageCollectorMXBean _gcBean;
        Long _collectionCount;
        Long _collectionTime;
        public GarbageCollectorMetric(GarbageCollectorMXBean gcBean) {
            _gcBean = gcBean;
        }
        @Override
        public Object getValueAndReset() {
            Long collectionCountP = _gcBean.getCollectionCount();
            Long collectionTimeP = _gcBean.getCollectionCount();

            Map ret = null;
            if(_collectionCount!=null && _collectionTime!=null) {
                ret = new HashMap();
                ret.put("count", collectionCountP - _collectionCount);
                ret.put("timeMs", collectionTimeP - _collectionTime);
            }

            _collectionCount = collectionCountP;
            _collectionTime = collectionTimeP;
            return ret;
        }
    }

    @Override
    public void prepare(final Map stormConf, TopologyContext context, OutputCollector collector) {
        if(_prepareWasCalled && stormConf.get(Config.STORM_CLUSTER_MODE) != "local") {
            throw new RuntimeException("A single worker should have 1 SystemBolt instance.");
        }
        _prepareWasCalled = true;

        int bucketSize = RT.intCast(stormConf.get(Config.TOPOLOGY_BUILTIN_METRICS_BUCKET_SIZE_SECS));

        final RuntimeMXBean jvmRT = ManagementFactory.getRuntimeMXBean();

        context.registerMetric("uptimeSecs", new IMetric() {
            @Override
            public Object getValueAndReset() {
                return jvmRT.getUptime()/1000.0;
            }
        }, bucketSize);

        context.registerMetric("startTimeSecs", new IMetric() {
            @Override
            public Object getValueAndReset() {
                return jvmRT.getStartTime()/1000.0;
            }
        }, bucketSize);

        context.registerMetric("newWorkerEvent", new IMetric() {
            boolean doEvent = true;

            @Override
            public Object getValueAndReset() {
                if (doEvent) {
                    doEvent = false;
                    return 1;
                } else return 0;
            }
        }, bucketSize);

        final MemoryMXBean jvmMemRT = ManagementFactory.getMemoryMXBean();

        context.registerMetric("memory/heap", new MemoryUsageMetric(new AFn() {
            public Object invoke() {
                return jvmMemRT.getHeapMemoryUsage();
            }
        }), bucketSize);
        context.registerMetric("memory/nonHeap", new MemoryUsageMetric(new AFn() {
            public Object invoke() {
                return jvmMemRT.getNonHeapMemoryUsage();
            }
        }), bucketSize);

        for(GarbageCollectorMXBean b : ManagementFactory.getGarbageCollectorMXBeans()) {
            context.registerMetric("GC/" + b.getName().replaceAll("\\W", ""), new GarbageCollectorMetric(b), bucketSize);
        }
    }

    @Override
    public void execute(Tuple input) {
        throw new RuntimeException("Non-system tuples should never be sent to __system bolt.");
    }

    @Override
    public void cleanup() {
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Storm/revisions/rev_f9cf61d_a29958c/rev_f9cf61d-a29958c/storm-core/src/jvm/backtype/storm/Config.java;<<<<<<< MINE
    public static final String DRPC_REQUEST_TIMEOUT_SECS  = "drpc.request.timeout.secs";
    public static final Object DRPC_REQUEST_TIMEOUT_SECS_SCHEMA = Number.class;

=======
    public static final String DRPC_REQUEST_TIMEOUT_SECS  = "drpc.request.timeout.secs";

    /**
     * Childopts for Storm DRPC Java process.
     */
    public static final String DRPC_CHILDOPTS = "drpc.childopts";
  
    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_45b00ee_1b85fe9/rev_45b00ee-1b85fe9/vertx-platform/src/main/java/org/vertx/java/platform/impl/WrappedVertx.java;<<<<<<< MINE

  @Override
  public DnsClient createDnsClient(InetSocketAddress... dnsServers) {
    return vertx.createDnsClient(dnsServers);
  }
=======

  @Override
  public <T> void executeBlocking(Action<T> action, Handler<AsyncResult<T>> resultHandler) {
    vertx.executeBlocking(action, resultHandler);
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_20e5475_00eceab/rev_20e5475-00eceab/vertx-testsuite/src/test/java/vertx/tests/core/net/TestClient.java;<<<<<<< MINE
    client.connect(1234, "somehost", new AsyncResultHandler<NetSocket>() {
=======
    client.connect(1234, "127.0.0.2", new AsyncResultHandler<NetSocket>() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_f1396aa_b015967/rev_f1396aa-b015967/vertx-core/src/main/java/org/vertx/java/core/json/JsonElement.java;<<<<<<< MINE
=======

  protected boolean needsCopy;

  protected void setNeedsCopy() {
    // We actually do the copy lazily if the object is subsequently mutated
    needsCopy = true;
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_f1396aa_b015967/rev_f1396aa-b015967/vertx-core/src/main/java/org/vertx/java/core/impl/VertxExecutorFactory.java;<<<<<<< MINE
    int poolSize = Integer.getInteger("vertx.pool.eventloop.size", Runtime.getRuntime().availableProcessors());
=======
    int poolSize = Integer.getInteger("vertx.pool.eventloop.size", 2 * Runtime.getRuntime().availableProcessors());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_f1396aa_b015967/rev_f1396aa-b015967/vertx-core/src/main/java/org/vertx/java/core/file/impl/DefaultFileSystem.java;<<<<<<< MINE
            raf.getChannel().truncate(len);
=======
            raf.setLength(len);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_f1396aa_b015967/rev_f1396aa-b015967/vertx-testsuite/src/test/java/org/vertx/java/tests/core/filesystem/JavaFileSystemTest.java;<<<<<<< MINE
=======
  public void testTruncateExtendsFile() throws Exception {
    startTest(getMethodName());
  }

  @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_111d6e5_ed1b42c/rev_111d6e5-ed1b42c/vertx-testsuite/src/test/java/vertx/tests/core/websockets/WebsocketsTestClient.java;<<<<<<< MINE
  public void testContinuationWriteFromConnectHybi08() throws Exception {
    testContinuationWriteFromConnectHandler(WebSocketVersion.HYBI_08);
  }

  public void testContinuationWriteFromConnectHybi17() throws Exception {
    testContinuationWriteFromConnectHandler(WebSocketVersion.RFC6455);
  }

=======
  public void testValidSubProtocolHybi00() throws Exception {
    testValidSubProtocol(WebSocketVersion.HYBI_00);
  }

  public void testValidSubProtocolHybi08() throws Exception {
    testValidSubProtocol(WebSocketVersion.HYBI_08);
  }

  public void testValidSubProtocolHybi17() throws Exception {
    testValidSubProtocol(WebSocketVersion.RFC6455);
  }

  public void testInvalidSubProtocolHybi00() throws Exception {
    testInvalidSubProtocol(WebSocketVersion.HYBI_00);
  }

  public void testInvalidSubProtocolHybi08() throws Exception {
    testInvalidSubProtocol(WebSocketVersion.HYBI_08);
  }

  public void testInvalidSubProtocolHybi17() throws Exception {
    testInvalidSubProtocol(WebSocketVersion.RFC6455);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_709b147_b492e29/rev_709b147-b492e29/vertx-core/src/main/java/org/vertx/java/core/logging/impl/JULLogDelegate.java;<<<<<<< MINE

    logger.log(Level.SEVERE, message == null ? "NULL" : message.toString(), t);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/main/java/io/vertx/core/buffer/Buffer.java;<<<<<<< MINE
import io.vertx.codegen.annotations.Fluent;
import io.vertx.codegen.annotations.GenIgnore;
import io.vertx.codegen.annotations.VertxGen;
import io.vertx.core.ServiceHelper;
=======
import io.vertx.core.gen.Fluent;
import io.vertx.core.gen.GenIgnore;
import io.vertx.core.gen.VertxGen;
import io.vertx.core.shareddata.impl.ClusterSerializable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/main/java/io/vertx/core/buffer/Buffer.java;<<<<<<< MINE
  static final BufferFactory factory = ServiceHelper.loadFactory(BufferFactory.class);

=======
  static final BufferFactory factory = loadFactory();

  @GenIgnore
  static BufferFactory loadFactory() {
    ServiceLoader<BufferFactory> factories = ServiceLoader.load(BufferFactory.class);
    if (factories.iterator().hasNext()) {
      return factories.iterator().next();
    } else {
      throw new IllegalStateException("Cannot find BufferFactory service");
    }
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/main/java/io/vertx/core/spi/cluster/AsyncMap.java;<<<<<<< MINE
/*
 * Copyright (c) 2011-2013 The original author or authors
 * ------------------------------------------------------
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Apache License v2.0 which accompanies this distribution.
 *
 *     The Eclipse Public License is available at
 *     http://www.eclipse.org/legal/epl-v10.html
 *
 *     The Apache License v2.0 is available at
 *     http://www.opensource.org/licenses/apache2.0.php
 *
 * You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.spi.cluster;

import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;


/**
 *
 * An asynchronous map.
 *
 * The cluster implementation should ensure that any entries placed in the map from any node are available on any
 * node of the cluster.
 *
 * @author <a href="http://tfox.org">Tim Fox</a>
 *
 */
public interface AsyncMap<K, V> {

  /**
   * Get a value from the map, asynchronously.
   * @param k The key
   * @param resultHandler - this will be called some time later with the async result.
   */
  void get(K k, Handler<AsyncResult<V>> resultHandler);

  /**
   * Put a value in the map, asynchronously.
   * @param k The key
   * @param v The value
   * @param completionHandler - this will be called some time later to signify the value has been put
   */
  void put(K k, V v, Handler<AsyncResult<Void>> completionHandler);

  /**
   * Remove a value from the map, asynchronously.
   * @param k The key
   * @param resultHandler - this will be called some time later to signify the value has been removed
   */
  void remove(K k, Handler<AsyncResult<Void>> resultHandler);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/main/java/io/vertx/core/spi/cluster/ClusterManager.java;<<<<<<< MINE
=======
import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;
import io.vertx.core.shareddata.AsyncMap;
import io.vertx.core.shareddata.Counter;
import io.vertx.core.shareddata.Lock;
import io.vertx.core.shareddata.MapOptions;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/main/java/io/vertx/core/Vertx.java;<<<<<<< MINE
  @GenIgnore
  @CacheReturn
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_12bde32_11d3eee/rev_12bde32-11d3eee/vertx-core/src/test/java/io/vertx/test/core/SharedDataTest.java;<<<<<<< MINE
/*
 * Copyright 2014 Red Hat, Inc.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Apache License v2.0 which accompanies this distribution.
 *
 * The Eclipse Public License is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * The Apache License v2.0 is available at
 * http://www.opensource.org/licenses/apache2.0.php
 *
 * You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.test.core;

import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.shareddata.SharedData;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Map;
import java.util.Random;
import java.util.Set;

import static org.junit.Assert.*;

/**
 * @author <a href="http://tfox.org">Tim Fox</a>
 */
public class SharedDataTest {

  private Vertx vertx;
  private SharedData sharedData;

  @Before
  public void setUp() {
    vertx = Vertx.vertx();
    sharedData = vertx.sharedData();
  }

  @After
  public void teardown() {
    vertx.close();
  }

  @Test
  public void testMap() throws Exception {

    Map<String, String> map = sharedData.getMap("foo");
    Map<String, String> map2 = sharedData.getMap("foo");
    assertTrue(map == map2);
    Map<String, String> map3 = sharedData.getMap("bar");
    assertFalse(map3 == map2);
    assertTrue(sharedData.removeMap("foo"));
    Map<String, String> map4 = sharedData.getMap("foo");
    assertFalse(map4 == map3);
  }

  @Test
  public void testMapTypes() throws Exception {

    Map<String, Object> map = sharedData.getMap("foo");

    String key = "key";

    double d = new Random().nextDouble();
    map.put(key, d);
    assertEquals(d, map.get(key));

    float f = new Random().nextFloat();
    map.put(key, f);
    assertEquals(f, map.get(key));

    byte b = (byte)new Random().nextInt();
    map.put(key, b);
    assertEquals(b, map.get(key));

    short s = (short)new Random().nextInt();
    map.put(key, s);
    assertEquals(s, map.get(key));

    int i = new Random().nextInt();
    map.put(key, i);
    assertEquals(i, map.get(key));

    long l = new Random().nextLong();
    map.put(key, l);
    assertEquals(l, map.get(key));

    map.put(key, true);
    assertTrue((Boolean)map.get(key));

    map.put(key, false);
    assertFalse((Boolean) map.get(key));

    char c = (char)new Random().nextLong();
    map.put(key, c);
    assertEquals(c, map.get(key));

    Buffer buff = TestUtils.randomBuffer(100);
    map.put(key, buff);
    Buffer got1 = (Buffer)map.get(key);
    assertTrue(got1 != buff); // Make sure it's copied
    assertEquals(buff, map.get(key));
    Buffer got2 = (Buffer)map.get(key);
    assertTrue(got1 != got2); // Should be copied each time
    assertTrue(got2 != buff);
    assertEquals(buff, map.get(key));


    byte[] bytes = TestUtils.randomByteArray(100);
    map.put(key, bytes);
    byte[] bgot1 = (byte[]) map.get(key);
    assertTrue(bgot1 != bytes);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot1));
    byte[] bgot2 = (byte[]) map.get(key);
    assertTrue(bgot2 != bytes);
    assertTrue(bgot1 != bgot2);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot2));

    try {
      map.put(key, new SomeOtherClass());
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      //OK
    }
  }

  @Test
  public void testSetTypes() throws Exception {

    Set<Object> set = sharedData.getSet("foo");

    double d = new Random().nextDouble();
    set.add(d);
    assertEquals(d, set.iterator().next());
    set.clear();

    float f = new Random().nextFloat();
    set.add(f);
    assertEquals(f, set.iterator().next());
    set.clear();

    byte b = (byte)new Random().nextInt();
    set.add(b);
    assertEquals(b, set.iterator().next());
    set.clear();

    short s = (short)new Random().nextInt();
    set.add(s);
    assertEquals(s, set.iterator().next());
    set.clear();

    int i = new Random().nextInt();
    set.add(i);
    assertEquals(i, set.iterator().next());
    set.clear();

    long l = new Random().nextLong();
    set.add(l);
    assertEquals(l, set.iterator().next());
    set.clear();

    set.add(true);
    assertTrue((Boolean)set.iterator().next());
    set.clear();

    set.add(false);
    assertFalse((Boolean) set.iterator().next());
    set.clear();

    char c = (char)new Random().nextLong();
    set.add(c);
    assertEquals(c, set.iterator().next());
    set.clear();

    Buffer buff = TestUtils.randomBuffer(100);
    set.add(buff);
    Buffer got1 = (Buffer)set.iterator().next();
    assertTrue(got1 != buff); // Make sure it's copied
    assertEquals(buff, set.iterator().next());
    Buffer got2 = (Buffer)set.iterator().next();
    assertTrue(got1 != got2); // Should be copied on each get
    assertTrue(got2 != buff);
    assertEquals(buff, set.iterator().next());
    set.clear();


    byte[] bytes = TestUtils.randomByteArray(100);
    set.add(bytes);
    byte[] bgot1 = (byte[]) set.iterator().next();
    assertTrue(bgot1 != bytes);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot1));
    byte[] bgot2 = (byte[]) set.iterator().next();
    assertTrue(bgot2 != bytes);
    assertTrue(bgot1 != bgot2);
    assertTrue(TestUtils.byteArraysEqual(bytes, bgot2));
    set.clear();

    try {
      set.add(new SomeOtherClass());
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      //OK
    }
  }


  @Test
  public void testSet() throws Exception {

    Set<String> set = sharedData.getSet("foo");
    Set<String> set2 = sharedData.getSet("foo");
    assert (set == set2);
    Set<String> set3 = sharedData.getSet("bar");
    assert (set3 != set2);
    assert (sharedData.removeSet("foo"));
    Set<String> set4 = sharedData.getSet("foo");
    assert (set4 != set3);
  }

  class SomeOtherClass {
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3376863_96dceab/rev_3376863-96dceab/vertx-core/src/main/java/io/vertx/core/net/NetClientOptions.java;<<<<<<< MINE
  NetClientOptions setReconnectAttempts(int attempts);
=======
  @Override
  public NetClientOptions setIdleTimeout(int idleTimeout) {
    super.setIdleTimeout(idleTimeout);
    return this;
  }

  @Override
  public NetClientOptions setTcpNoDelay(boolean tcpNoDelay) {
    super.setTcpNoDelay(tcpNoDelay);
    return this;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3376863_96dceab/rev_3376863-96dceab/vertx-core/src/main/java/io/vertx/core/net/NetServerOptions.java;<<<<<<< MINE
  NetServerOptions addCrlValue(Buffer crlValue);
=======
  @Override
  public NetServerOptions setIdleTimeout(int idleTimeout) {
    super.setIdleTimeout(idleTimeout);
    return this;
  }

  @Override
  public NetServerOptions setTcpNoDelay(boolean tcpNoDelay) {
    super.setTcpNoDelay(tcpNoDelay);
    return this;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3376863_96dceab/rev_3376863-96dceab/vertx-core/src/main/java/io/vertx/core/http/HttpClientOptions.java;<<<<<<< MINE
  HttpClientOptions setPipelining(boolean pipelining);
=======
  @Override
  public HttpClientOptions setTrafficClass(int trafficClass) {
    super.setTrafficClass(trafficClass);
    return this;
  }

  @Override
  public HttpClientOptions setIdleTimeout(int idleTimeout) {
    super.setIdleTimeout(idleTimeout);
    return this;
  }

  @Override
  public HttpClientOptions setTcpNoDelay(boolean tcpNoDelay) {
    super.setTcpNoDelay(tcpNoDelay);
    return this;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_cf96769_d9b83ec/rev_cf96769-d9b83ec/vertx-core/src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java;<<<<<<< MINE
  public ServerWebSocketImpl(VertxInternal vertx, String uri, String path, String query, MultiMap headers,
                             ConnectionBase conn, boolean supportsContinuation, Runnable connectRunnable) {
    super(vertx, conn, supportsContinuation);
=======
  public ServerWebSocketImpl(VertxInternal vertx, String uri, String path, String query, Headers headers,
                             ConnectionBase conn, Runnable connectRunnable) {
    super(vertx, conn);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_8b210bf_22f077e/rev_8b210bf-22f077e/vertx-core/src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java;<<<<<<< MINE
import java.text.SimpleDateFormat;
import java.util.Date;
=======
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_8b210bf_22f077e/rev_8b210bf-22f077e/vertx-core/src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java;<<<<<<< MINE
    Date date = new Date();
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
=======
    OffsetDateTime date = fromMillis(record.getMillis());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_8b210bf_22f077e/rev_8b210bf-22f077e/vertx-core/src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java;<<<<<<< MINE
    date.setTime(record.getMillis());
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_8b210bf_22f077e/rev_8b210bf-22f077e/vertx-core/src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java;<<<<<<< MINE
    sb.append(dateFormat.format(date)).append(" ");
=======
    sb.append(date.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)).append(" ");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_8b210bf_22f077e/rev_8b210bf-22f077e/vertx-core/src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java;<<<<<<< MINE
=======
  private static OffsetDateTime fromMillis(long epochMillis) {
    return OffsetDateTime.ofInstant(Instant.ofEpochMilli(epochMillis), ZoneId.systemDefault());
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_fdb03e8_2e78ec2/rev_fdb03e8-2e78ec2/vertx-core/src/main/java/io/vertx/core/datagram/DatagramSocket.java;<<<<<<< MINE
public interface DatagramSocket extends ReadStream<DatagramPacket> {
=======
public interface DatagramSocket extends Measured {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_6cc6bb4_c9aea8c/rev_6cc6bb4-c9aea8c/vertx-core/src/main/java/io/vertx/core/eventbus/Message.java;<<<<<<< MINE
=======

  /**
   * Indicates whether or not this message has been received as a result of a forward operation
   * versus a send or publish.
   * 
   * @return whether or not the message has been fowarded
   */
  boolean isForward();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_464dede_c381820/rev_464dede-c381820/vertx-core/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
  public static final long DEFAULT_BLOCKED_THREAD_CHECK_PERIOD = 1000;
=======
  public static final long DEFAULT_CLUSTER_PING_INTERVAL = 20000;
  public static final long DEFAULT_CLUSTER_PING_REPLY_INTERVAL = 20000;
  public static final int DEFAULT_BLOCKED_THREAD_CHECK_PERIOD = 1000;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
  public static final long DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME = 2000l * 1000000;
=======
  public static final long DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME = 2l * 1000 * 1000000;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
=======
  /**
   * The default value of warning exception time 5000000000 ns (5 seconds)
   * If a thread is blocked longer than this threshold, the warning log
   * contains a stack trace
   */
  private static final long DEFAULT_WARNING_EXECPTION_TIME = 5l * 1000 * 1000000;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
=======
  private long warningExceptionTime = DEFAULT_WARNING_EXECPTION_TIME;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
=======
    this.warningExceptionTime = other.warningExceptionTime;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
=======
    this.warningExceptionTime = json.getLong("warningExceptionTime", DEFAULT_WARNING_EXECPTION_TIME);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
=======
  /**
   * Get the threshold value above this, the blocked warning contains a stack trace.
   *
   * @return the warning exception time threshold
   */
  public long getWarningExceptionTime() {
    return warningExceptionTime;
  }

  /**
   * Set the threshold value above this, the blocked warning contains a stack trace.
   *
   * @param warningExceptionTime
   * @return a reference to this, so the API can be used fluently
   */
  public VertxOptions setWarningExceptionTime(long warningExceptionTime) {
    if (warningExceptionTime < 1) {
      throw new IllegalArgumentException("warningExceptionTime must be > 0");
    }
    this.warningExceptionTime = warningExceptionTime;
    return this;
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
=======
    if (warningExceptionTime != that.warningExceptionTime) return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/main/java/io/vertx/core/VertxOptions.java;<<<<<<< MINE
=======
    result = 31 * result + (int) (warningExceptionTime ^ (warningExceptionTime >>> 32));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/BlockedThreadCheckerTest.java;<<<<<<< MINE
=======
package io.vertx.test.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Verticle;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;

import org.junit.Test;

/**
 * please note that this test class does not assert anything about the log output (this would require a kind of log
 * mock), it just runs the different methods to get coverage
 *
 * @author <a href="http://oss.lehmann.cx/">Alexander Lehmann</a>
 */
public class BlockedThreadCheckerTest extends VertxTestBase {

  @Test
  public void testBlockCheckDefault() throws Exception {
    Verticle verticle = new AbstractVerticle() {
      @Override
      public void start() throws InterruptedException {
        Thread.sleep(6000);
        testComplete();
      }
    };
    vertx.deployVerticle(verticle);
    await();
  }

  @Test
  public void testBlockCheckExceptionTimeLimit() throws Exception {
    Verticle verticle = new AbstractVerticle() {
      @Override
      public void start() throws InterruptedException {
        Thread.sleep(2000);
        testComplete();
      }
    };
    // set warning threshold to 1s and the exception threshold as well
    VertxOptions vertxOptions = new VertxOptions();
    vertxOptions.setMaxEventLoopExecuteTime(1000000000);
    vertxOptions.setWarningExceptionTime(1000000000);
    Vertx newVertx = Vertx.vertx(vertxOptions);
    newVertx.deployVerticle(verticle);
    await();
  }

  @Test
  public void testBlockCheckWorker() throws Exception {
    Verticle verticle = new AbstractVerticle() {
      @Override
      public void start() throws InterruptedException {
        Thread.sleep(2000);
        testComplete();
      }
    };
    // set warning threshold to 1s and the exception threshold as well
    VertxOptions vertxOptions = new VertxOptions();
    vertxOptions.setMaxWorkerExecuteTime(1000000000);
    vertxOptions.setWarningExceptionTime(1000000000);
    Vertx newVertx = Vertx.vertx(vertxOptions);
    DeploymentOptions depolymentOptions = new DeploymentOptions();
    depolymentOptions.setWorker(true);
    newVertx.deployVerticle(verticle, depolymentOptions);
    await();
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======

    try {
      options.setWarningExceptionTime(-1);
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      // OK
    }
    assertEquals(options, options.setWarningExceptionTime(1000000000l));
    assertEquals(1000000000l, options.getWarningExceptionTime());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
    long warningExceptionTime = TestUtils.randomPositiveLong();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
    options.setWarningExceptionTime(warningExceptionTime);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
    assertEquals(warningExceptionTime, options.getWarningExceptionTime());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
    assertEquals(def.getWarningExceptionTime(), json.getWarningExceptionTime());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
    assertEquals(5000000000l, options.getWarningExceptionTime());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
    long warningExceptionTime = TestUtils.randomPositiveLong();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
        put("warningExceptionTime", warningExceptionTime).
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_7d544f7_04e43e2/rev_7d544f7-04e43e2/src/test/java/io/vertx/test/core/VertxOptionsTest.java;<<<<<<< MINE
=======
    assertEquals(warningExceptionTime, options.getWarningExceptionTime());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_9276cbb_a2331d0/rev_9276cbb-a2331d0/src/main/java/io/vertx/core/json/impl/Json.java;<<<<<<< MINE
=======
/*
 * Copyright (c) 2011-2014 The original author or authors
 * ------------------------------------------------------
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Apache License v2.0 which accompanies this distribution.
 *
 *     The Eclipse Public License is available at
 *     http://www.eclipse.org/legal/epl-v10.html
 *
 *     The Apache License v2.0 is available at
 *     http://www.opensource.org/licenses/apache2.0.php
 *
 * You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.json.impl;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.module.SimpleModule;
import io.vertx.core.json.DecodeException;
import io.vertx.core.json.EncodeException;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Base64;
import java.util.List;
import java.util.Map;

/**
 * @author <a href="http://tfox.org">Tim Fox</a>
 */
public class Json {

  private final static ObjectMapper mapper = new ObjectMapper();
  private final static ObjectMapper prettyMapper = new ObjectMapper();

  static {
    // Non-standard JSON but we allow C style comments in our JSON
    mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);

    prettyMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
    prettyMapper.configure(SerializationFeature.INDENT_OUTPUT, true);

    SimpleModule module = new SimpleModule();
    module.addSerializer(JsonObject.class, new JsonObjectSerializer());
    module.addSerializer(JsonArray.class, new JsonArraySerializer());
    mapper.registerModule(module);
    prettyMapper.registerModule(module);
  }

  @SuppressWarnings("unchecked")
  public static Object checkAndCopy(Object val, boolean copy) {
    if (val == null) {
      // OK
    } else if (val instanceof Number && !(val instanceof BigDecimal)) {
      // OK
    } else if (val instanceof Boolean) {
      // OK
    } else if (val instanceof String) {
      // OK
    } else if (val instanceof CharSequence) {
      val = val.toString();
    } else if (val instanceof JsonObject) {
      if (copy) {
        val = ((JsonObject) val).copy();
      }
    } else if (val instanceof JsonArray) {
      if (copy) {
        val = ((JsonArray) val).copy();
      }
    } else if (val instanceof Map) {
      if (copy) {
        val = (new JsonObject((Map)val)).copy();
      } else {
        val = new JsonObject((Map)val);
      }
    } else if (val instanceof List) {
      if (copy) {
        val = (new JsonArray((List)val)).copy();
      } else {
        val = new JsonArray((List)val);
      }
    } else if (val instanceof byte[]) {
      val = Base64.getEncoder().encodeToString((byte[])val);
    } else {
      throw new IllegalStateException("Illegal type in JsonObject: " + val.getClass());
    }
    return val;
  }

  public static String encode(Object obj) throws EncodeException {
    try {
      return mapper.writeValueAsString(obj);
    } catch (Exception e) {
      throw new EncodeException("Failed to encode as JSON: " + e.getMessage());
    }
  }

  public static String encodePrettily(Object obj) throws EncodeException {
    try {
      return prettyMapper.writeValueAsString(obj);
    } catch (Exception e) {
      throw new EncodeException("Failed to encode as JSON: " + e.getMessage());
    }
  }

  public static <T> T decodeValue(String str, Class<T> clazz) throws DecodeException {
    try {
      return mapper.readValue(str, clazz);
    }
    catch (Exception e) {
      throw new DecodeException("Failed to decode:" + e.getMessage());
    }
  }

  private static class JsonObjectSerializer extends JsonSerializer<JsonObject> {
    @Override
    public void serialize(JsonObject value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
      jgen.writeObject(value.getMap());
    }
  }

  private static class JsonArraySerializer extends JsonSerializer<JsonArray> {
    @Override
    public void serialize(JsonArray value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
      jgen.writeObject(value.getList());
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_cf58372_20ac5eb/rev_cf58372-20ac5eb/src/main/java/io/vertx/core/Context.java;<<<<<<< MINE
  /**
   * @return The Vertx instance that created the context
   */
  Vertx owner();

=======
  /**
   * Get the number of instances of the verticle that were started
   */
  int getInstanceCount();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/StartCommandFactory.java;<<<<<<< MINE
=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.impl.launcher.commands;

import io.vertx.core.spi.launcher.DefaultCommandFactory;

/**
 * Defines the `start` command.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class StartCommandFactory extends DefaultCommandFactory<StartCommand> {

  /**
   * Creates a new instance of {@link StartCommandFactory}.
   */
  public StartCommandFactory() {
    super(StartCommand.class);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/StopCommandFactory.java;<<<<<<< MINE
=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.impl.launcher.commands;

import io.vertx.core.spi.launcher.DefaultCommandFactory;

/**
 * Defines the `stop` command.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class StopCommandFactory extends DefaultCommandFactory<StopCommand> {

  /**
   * Creates a new instance of {@link StopCommandFactory}.
   */
  public StopCommandFactory() {
    super(StopCommand.class);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/ExecUtils.java;<<<<<<< MINE
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */
package io.vertx.core.impl.launcher.commands;

import java.util.List;

/**
 * A couple of utility methods easing process creation.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class ExecUtils {

  private static final String SINGLE_QUOTE = "\'";
  private static final String DOUBLE_QUOTE = "\"";

  /**
   * The {@code os.name} property is mandatory (from the Java Virtual Machine specification).
   */
  private static String osName = System.getProperty("os.name").toLowerCase();

  /**
   * Puts quotes around the given String if necessary.
   * <p>
   * If the argument doesn't include spaces or quotes, return it as is. If it
   * contains double quotes, use single quotes - else surround the argument by
   * double quotes.
   * </p>
   *
   * @param argument the argument to be quoted
   * @return the quoted argument
   * @throws IllegalArgumentException If argument contains both types of quotes
   */
  public static String quoteArgument(final String argument) {

    String cleanedArgument = argument.trim();

    // strip the quotes from both ends
    while (cleanedArgument.startsWith(SINGLE_QUOTE) || cleanedArgument.startsWith(DOUBLE_QUOTE)) {
      cleanedArgument = cleanedArgument.substring(1);
    }

    while (cleanedArgument.endsWith(SINGLE_QUOTE) || cleanedArgument.endsWith(DOUBLE_QUOTE)) {
      cleanedArgument = cleanedArgument.substring(0, cleanedArgument.length() - 1);
    }

    final StringBuilder buf = new StringBuilder();
    if (cleanedArgument.contains(DOUBLE_QUOTE)) {
      if (cleanedArgument.contains(SINGLE_QUOTE)) {
        throw new IllegalArgumentException(
            "Can't handle single and double quotes in same argument");
      }
      return buf.append(SINGLE_QUOTE).append(cleanedArgument).append(
          SINGLE_QUOTE).toString();
    } else if (cleanedArgument.contains(SINGLE_QUOTE)
        || cleanedArgument.contains(" ")) {
      return buf.append(DOUBLE_QUOTE).append(cleanedArgument).append(
          DOUBLE_QUOTE).toString();
    } else {
      return cleanedArgument;
    }
  }

  /**
   * Adds an argument to the given list. It automatially add quotes to the argument if necessary.
   *
   * @param args the list of arguments
   * @param argument the argument to add
   */
  public static void addArgument(List<String> args, String argument) {
    args.add(quoteArgument(argument));
  }

  /**
   * @return {@code true} if the current operating system belongs to the "windows" family.
   */
  public static boolean isWindows() {
    return osName.contains("windows");
  }


}=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */
package io.vertx.core.impl.launcher.commands;

import java.util.List;

/**
 * A couple of utility methods easing process creation.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class ExecUtils {

  private static final String SINGLE_QUOTE = "\'";
  private static final String DOUBLE_QUOTE = "\"";

  /**
   * The {@code os.name} property is mandatory (from the Java Virtual Machine specification).
   */
  private static String osName = System.getProperty("os.name").toLowerCase();

  /**
   * Puts quotes around the given String if necessary.
   * <p>
   * If the argument doesn't include spaces or quotes, return it as is. If it
   * contains double quotes, use single quotes - else surround the argument by
   * double quotes.
   * </p>
   *
   * @param argument the argument to be quoted
   * @return the quoted argument
   * @throws IllegalArgumentException If argument contains both types of quotes
   */
  public static String quoteArgument(final String argument) {

    String cleanedArgument = argument.trim();

    // strip the quotes from both ends
    while (cleanedArgument.startsWith(SINGLE_QUOTE) && cleanedArgument.endsWith(SINGLE_QUOTE)
        || cleanedArgument.startsWith(DOUBLE_QUOTE)  && cleanedArgument.endsWith(DOUBLE_QUOTE)) {
      cleanedArgument = cleanedArgument.substring(1, cleanedArgument.length() - 1);
    }

    final StringBuilder buf = new StringBuilder();
    if (cleanedArgument.contains(DOUBLE_QUOTE)) {
      if (cleanedArgument.contains(SINGLE_QUOTE)) {
        throw new IllegalArgumentException(
            "Can't handle single and double quotes in same argument");
      }
      return buf.append(SINGLE_QUOTE).append(cleanedArgument).append(
          SINGLE_QUOTE).toString();
    } else if (cleanedArgument.contains(SINGLE_QUOTE)
        || cleanedArgument.contains(" ")) {
      return buf.append(DOUBLE_QUOTE).append(cleanedArgument).append(
          DOUBLE_QUOTE).toString();
    } else {
      return cleanedArgument;
    }
  }

  /**
   * Adds an argument to the given list. It automatially add quotes to the argument if necessary.
   *
   * @param args the list of arguments
   * @param argument the argument to add
   */
  public static void addArgument(List<String> args, String argument) {
    args.add(quoteArgument(argument));
  }

  /**
   * @return {@code true} if the current operating system belongs to the "windows" family.
   */
  public static boolean isWindows() {
    return osName.contains("windows");
  }


}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/impl/launcher/commands/ListCommandFactory.java;<<<<<<< MINE
=======
/*
 *  Copyright (c) 2011-2015 The original author or authors
 *  ------------------------------------------------------
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *       The Eclipse Public License is available at
 *       http://www.eclipse.org/legal/epl-v10.html
 *
 *       The Apache License v2.0 is available at
 *       http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.core.impl.launcher.commands;

import io.vertx.core.spi.launcher.DefaultCommandFactory;

/**
 * Defines the `list` command.
 *
 * @author Clement Escoffier <clement@apache.org>
 */
public class ListCommandFactory extends DefaultCommandFactory<ListCommand> {
  /**
   * Creates a new {@link ListCommandFactory}.
   */
  public ListCommandFactory() {
    super(ListCommand.class);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/spi/launcher/DefaultCommand.java;<<<<<<< MINE
  private List<String> props;
=======
  protected List<String> systemProperties;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/spi/launcher/DefaultCommand.java;<<<<<<< MINE
    this.props = props;
=======
    this.systemProperties = props;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/spi/launcher/DefaultCommand.java;<<<<<<< MINE
    if (props != null) {
      for (String prop : props) {
=======
    if (systemProperties != null) {
      for (String prop : systemProperties) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_3d6677c_7ef9592/rev_3d6677c-7ef9592/src/main/java/io/vertx/core/spi/launcher/DefaultCommand.java;<<<<<<< MINE
    if (props != null) {
      for (String prop : props) {
=======
    if (systemProperties != null) {
      for (String prop : systemProperties) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_b16aeeb_da5749f/rev_b16aeeb-da5749f/src/main/java/io/vertx/core/http/impl/HttpClientConnection.java;<<<<<<< MINE
import io.vertx.core.Context;
import io.vertx.core.http.HttpConnection;
=======
import io.vertx.core.impl.ContextImpl;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_1ff48fe_08f2ffc/rev_1ff48fe-08f2ffc/src/test/java/io/vertx/test/core/JsonMapperTest.java;<<<<<<< MINE
import java.time.Instant;

import static java.time.format.DateTimeFormatter.ISO_INSTANT;

=======
import java.util.Collections;
import java.util.List;
import java.util.Map;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_1ff48fe_08f2ffc/rev_1ff48fe-08f2ffc/src/test/java/io/vertx/test/core/JsonMapperTest.java;<<<<<<< MINE

  @Test
  public void encodeCustomTypeInstant() {
    Instant now = Instant.now();
    String json = Json.encode(now);
    assertNotNull(json);
    // the RFC is one way only
    Instant decoded = Instant.from(ISO_INSTANT.parse(json.substring(1, json.length() - 1)));
    assertEquals(now, decoded);

  }

  @Test
  public void encodeCustomTypeInstantNull() {
    Instant now = null;
    String json = Json.encode(now);
    assertNotNull(json);
    assertEquals("null", json);
  }

  @Test
  public void encodeCustomTypeBinary() {
    byte[] data = new byte[] { 'h', 'e', 'l', 'l', 'o'};
    String json = Json.encode(data);
    assertNotNull(json);
    // base64 encoded hello
    assertEquals("\"aGVsbG8=\"", json);
  }

  @Test
  public void encodeCustomTypeBinaryNull() {
    byte[] data = null;
    String json = Json.encode(data);
    assertNotNull(json);
    assertEquals("null", json);
  }
=======

  @Test
  public void testGenericDecoding() {
    Pojo original = new Pojo();
    original.value = "test";

    String json = Json.encode(Collections.singletonList(original));

    List<Pojo> correct = Json.decodeValue(json, new TypeReference<List<Pojo>>() {});
    assertTrue(((List)correct).get(0) instanceof Pojo);
    assertEquals(original.value, correct.get(0).value);

    List incorrect = Json.decodeValue(json, List.class);
    assertFalse(incorrect.get(0) instanceof Pojo);
    assertTrue(incorrect.get(0) instanceof Map);
    assertEquals(original.value, ((Map)(incorrect.get(0))).get("value"));
  }

  private static class Pojo {
    @JsonProperty
    String value;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Vert.x-Core/revisions/rev_f3e0802_d71e802/rev_f3e0802-d71e802/src/test/java/io/vertx/test/core/JsonMapperTest.java;<<<<<<< MINE

  @Test
  public void encodeToBuffer() {
    Buffer json = Json.encodeToBuffer("Hello World!");
    assertNotNull(json);
    // json strings are always UTF8
    assertEquals("\"Hello World!\"", json.toString("UTF-8"));
  }
=======

  @Test
  public void testGenericDecoding() {
    Pojo original = new Pojo();
    original.value = "test";

    String json = Json.encode(Collections.singletonList(original));

    List<Pojo> correct = Json.decodeValue(json, new TypeReference<List<Pojo>>() {});
    assertTrue(((List)correct).get(0) instanceof Pojo);
    assertEquals(original.value, correct.get(0).value);

    List incorrect = Json.decodeValue(json, List.class);
    assertFalse(incorrect.get(0) instanceof Pojo);
    assertTrue(incorrect.get(0) instanceof Map);
    assertEquals(original.value, ((Map)(incorrect.get(0))).get("value"));
  }

  private static class Pojo {
    @JsonProperty
    String value;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_cff6c96_6e8180b/rev_cff6c96-6e8180b/websocket/binary/src/test/java/org/javaee7/websocket/binary/test/WebsocketByteBufferEndpointTest.java;<<<<<<< MINE
=======
/**
 *
 */
package org.javaee7.websocket.binary.test;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import javax.websocket.ContainerProvider;
import javax.websocket.DeploymentException;
import javax.websocket.WebSocketContainer;

import org.javaee7.websocket.binary.MyEndpointByteArray;
import org.javaee7.websocket.binary.MyEndpointByteBuffer;
import org.javaee7.websocket.binary.MyEndpointClient;
import org.javaee7.websocket.binary.MyEndpointInputStream;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.container.test.api.TargetsContainer;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * @author Nikos "cirix" Ballas
 *
 */
@RunWith(Arquillian.class)
public class WebsocketByteBufferEndpointTest {

    private static final String WEBAPP_SRC = "src/main/webapp";

    /**
     * Arquillian specific method for creating a file which can be deployed
     * while executing the test.
     *
     * @return a war file
     */
    @Deployment(testable = false)
    @TargetsContainer("wildfly-arquillian")
    public static WebArchive createDeployment() {
        WebArchive war = ShrinkWrap.create(WebArchive.class).
                addClass(MyEndpointByteBuffer.class).
                addClass(MyEndpointByteArray.class).
                addClass(MyEndpointInputStream.class).
                addAsWebResource(new File(WEBAPP_SRC, "index.jsp")).
                addAsWebResource(new File(WEBAPP_SRC, "websocket.js"));
        return war;
    }

    /**
     * The basic test method for the class {@link MyEndpointByteBuffer}
     *
     * @throws URISyntaxException
     * @throws DeploymentException
     * @throws IOException
     */
    @Test
    public void testEndPointByteBuffer() throws URISyntaxException, DeploymentException, IOException {
        WebSocketContainer wSocketContainer = ContainerProvider.getWebSocketContainer();
        wSocketContainer.connectToServer(MyEndpointClient.class, new URI("ws://localhost:8080/binary/bytearray"));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_b77bf39_ed4cb65/rev_b77bf39-ed4cb65/cdi/decorators/src/main/java/org/javaee7/cdi/decorators/MyDecorator.java;<<<<<<< MINE
        return greeting.greet(name + " <b>very much!</b>");
=======
        return greeting.greet(name + " very much!");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_b77bf39_ed4cb65/rev_b77bf39-ed4cb65/cdi/decorators/src/test/java/org/javaee7/cdi/decorators/DecoratorTest.java;<<<<<<< MINE
=======
package org.javaee7.cdi.decorators;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Test;
import org.junit.runner.RunWith;

import javax.inject.Inject;
import java.io.File;
import java.net.URISyntaxException;

import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;

/**
 * @author Korneliusz Rabczak
 */
@RunWith(Arquillian.class)
public class DecoratorTest {

    @Inject
    Greeting greeting;

    @Deployment
    public static Archive<?> deploy() throws URISyntaxException {
        return ShrinkWrap.create(JavaArchive.class)
                .addAsManifestResource(new File("src/main/webapp/WEB-INF/beans.xml"), "beans.xml")
                .addPackage(SimpleGreeting.class.getPackage());
    }

    @Test
    public void test() {
        assertThat(greeting.greet("Duke"), is("Hello Duke very much!"));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/main/java/org/javaee7/jaspic/asyncauthentication/sam/SamAutoRegistrationListener.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication.sam;

import javax.servlet.ServletContextEvent;
import javax.servlet.annotation.WebListener;

import org.javaee7.jaspic.common.BaseServletContextListener;
import org.javaee7.jaspic.common.JaspicUtils;

/**
 * 
 * @author Arjan Tijms
 * 
 */
@WebListener
public class SamAutoRegistrationListener extends BaseServletContextListener {

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        JaspicUtils.registerSAM(sce.getServletContext(), new TestServerAuthModule());
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/main/java/org/javaee7/jaspic/asyncauthentication/servlet/AsyncServlet.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication.servlet;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.AsyncContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.javaee7.jaspic.asyncauthentication.bean.AsyncBean;

/**
 * 
 * @author Arjan Tijms
 * 
 */
@WebServlet(urlPatterns = "/public/asyncServlet", asyncSupported = true)
public class AsyncServlet extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @EJB
    private AsyncBean asyncBean;
    
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        
        AsyncContext asyncContext = request.startAsync();
        asyncContext.setTimeout(5000);
        
        asyncBean.doAsync(asyncContext);
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/main/java/org/javaee7/jaspic/asyncauthentication/bean/AsyncBean.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication.bean;

import static java.lang.Thread.interrupted;
import static java.lang.Thread.sleep;

import java.io.IOException;

import javax.ejb.Asynchronous;
import javax.ejb.Stateless;
import javax.servlet.AsyncContext;

/**
 * 
 * @author Arjan Tijms
 *
 */
@Stateless
public class AsyncBean {

    @Asynchronous
    public void doAsync(AsyncContext asyncContext) {
        
        try {
            sleep(1000);
        } catch (InterruptedException e) {
            interrupted();
        }
        
        try {
            asyncContext.getResponse().getWriter().write("async response");
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        asyncContext.complete();
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_bd9e098_a4b91fd/rev_bd9e098-a4b91fd/jaspic/async-authentication/src/test/java/org/javaee7/jaspic/asyncauthentication/AsyncAuthenticationPublicTest.java;<<<<<<< MINE
=======
package org.javaee7.jaspic.asyncauthentication;

import static org.junit.Assert.assertTrue;

import java.io.IOException;

import org.javaee7.jaspic.common.ArquillianBase;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.xml.sax.SAXException;

/**
 * 
 * 
 * @author Arjan Tijms
 * 
 */
@RunWith(Arquillian.class)
public class AsyncAuthenticationPublicTest extends ArquillianBase {

    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return defaultArchive();
    }

    /**
     * This tests that an async response works at all in the mere presence of
     * a JASPIC SAM (that does nothing)
     */
    @Test
    public void testBasicAsync() throws IOException, SAXException {

        String response = getFromServerPath("public/asyncServlet");
        assertTrue(response.contains("async response"));
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_76589b5_a4b91fd/rev_76589b5-a4b91fd/jms/jms-xa/src/main/java/org/javaee7/jms/xa/JMSMailman.java;<<<<<<< MINE
import javax.jms.TextMessage;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Javaee7-samples/revisions/rev_76589b5_a4b91fd/rev_76589b5-a4b91fd/jms/jms-xa/src/main/java/org/javaee7/jms/xa/JMSMailman.java;<<<<<<< MINE
            TextMessage tm = (TextMessage) message;
            logger.info("Message received (async): " + tm.getText());
=======
            String text = message.getBody(String.class);
            logger.info("Message received (async): " + text);
>>>>>>> YOURS
